<TYPEDEF>
<NAME>FILE</NAME>
typedef void FILE;
</TYPEDEF>
<TYPEDEF>
<NAME>size_t</NAME>
typedef int size_t;
</TYPEDEF>
<TYPEDEF>
<NAME>ssize_t</NAME>
typedef int ssize_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint16_t</NAME>
typedef unsigned short int uint16_t;
</TYPEDEF>
<FUNCTION>
<NAME>prelude_io_new</NAME>
<RETURNS>prelude_io_t  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_destroy</NAME>
<RETURNS>void  </RETURNS>
prelude_io_t *pio
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_set_file_io</NAME>
<RETURNS>void  </RETURNS>
prelude_io_t *pio, FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_set_ssl_io</NAME>
<RETURNS>void  </RETURNS>
prelude_io_t *pio, void *ssl
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_set_sys_io</NAME>
<RETURNS>void  </RETURNS>
prelude_io_t *pio, int fd
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_close</NAME>
<RETURNS>int  </RETURNS>
prelude_io_t *pio
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_read</NAME>
<RETURNS>ssize_t  </RETURNS>
prelude_io_t *pio, void *buf, size_t count
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_read_wait</NAME>
<RETURNS>ssize_t  </RETURNS>
prelude_io_t *pio, void *buf, size_t count
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_read_delimited</NAME>
<RETURNS>ssize_t  </RETURNS>
prelude_io_t *pio, void **buf
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_write</NAME>
<RETURNS>ssize_t  </RETURNS>
prelude_io_t *pio, const void *buf, size_t count
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_write_delimited</NAME>
<RETURNS>int  </RETURNS>
prelude_io_t *pio, const void *buf, uint16_t count
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_forward</NAME>
<RETURNS>ssize_t  </RETURNS>
prelude_io_t *dst, prelude_io_t *src, size_t count
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_get_fd</NAME>
<RETURNS>int  </RETURNS>
prelude_io_t *pio
</FUNCTION>
<FUNCTION>
<NAME>prelude_io_get_fdptr</NAME>
<RETURNS>void  *</RETURNS>
prelude_io_t *pio
</FUNCTION>
<FUNCTION>
<NAME>plugin_search_by_name</NAME>
<RETURNS>plugin_generic_t  *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>plugin_load_from_dir</NAME>
<RETURNS>int  </RETURNS>
const char *dirname, int argc, char **argv,int (*subscribe)(plugin_container_t *p), void (*unsubscribe)(plugin_container_t *pc)
</FUNCTION>
<FUNCTION>
<NAME>plugin_add</NAME>
<RETURNS>int  </RETURNS>
plugin_container_t *pc, struct list_head *h, const char *infos
</FUNCTION>
<FUNCTION>
<NAME>plugin_del</NAME>
<RETURNS>void  </RETURNS>
plugin_container_t *pc
</FUNCTION>
<FUNCTION>
<NAME>plugin_print_stats</NAME>
<RETURNS>void  </RETURNS>
plugin_container_t *pc
</FUNCTION>
<FUNCTION>
<NAME>plugins_print_stats</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>plugins_print_opts</NAME>
<RETURNS>void  </RETURNS>
const char *dirname
</FUNCTION>
<FUNCTION>
<NAME>plugin_get_highest_id</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>plugin_run</NAME>
#define plugin_run(pc, type, member, arg...) do {                              \
        struct timeval start, end;                                             \
                                                                               \
        gettimeofday(&start, NULL);                                            \
        ((type *)pc->plugin)->member(arg);                                     \
        gettimeofday(&end, NULL);                                              \
        pc->p_time += (double) end.tv_sec + (double) (end.tv_usec * 1e-6);     \
        pc->p_time -= (double) start.tv_sec + (double) (start.tv_usec * 1e-6); \
        pc->p_count++;                                                         \
} while (0)
</MACRO>
<MACRO>
<NAME>plugin_run_with_return_value</NAME>
#define plugin_run_with_return_value(pc, type, member, ret, arg...) do {       \
        struct timeval start, end;                                             \
                                                                               \
        gettimeofday(&start, NULL);                                            \
        ret = ((type *)pc->plugin)->member(arg);                               \
        gettimeofday(&end, NULL);                                              \
        pc->p_time += (double) end.tv_sec + (double) (end.tv_usec * 1e-6);     \
        pc->p_time -= (double) start.tv_sec + (double) (start.tv_usec * 1e-6); \
        pc->p_count++;                                                         \
} while (0)
</MACRO>
<FUNCTION>
<NAME>variable_set</NAME>
<RETURNS>int  </RETURNS>
char *variable, char *value
</FUNCTION>
<FUNCTION>
<NAME>variable_unset</NAME>
<RETURNS>int  </RETURNS>
const char *variable
</FUNCTION>
<FUNCTION>
<NAME>variable_get</NAME>
<RETURNS>char  *</RETURNS>
const char *variable
</FUNCTION>
<MACRO>
<NAME>PRELUDE_MSG_IDMEF</NAME>
#define PRELUDE_MSG_IDMEF       0
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_OPTION_LIST</NAME>
#define PRELUDE_MSG_OPTION_LIST 1
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_OPTION_SET</NAME>
#define PRELUDE_MSG_OPTION_SET  2
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_ID</NAME>
#define PRELUDE_MSG_ID          3
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH</NAME>
#define PRELUDE_MSG_AUTH        4
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_ID_REQUEST</NAME>
#define PRELUDE_MSG_ID_REQUEST  0
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_ID_REPLY</NAME>
#define PRELUDE_MSG_ID_REPLY    1
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_ID_DECLARE</NAME>
#define PRELUDE_MSG_ID_DECLARE  3
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_HAVE_SSL</NAME>
#define PRELUDE_MSG_AUTH_HAVE_SSL       0
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_HAVE_PLAINTEXT</NAME>
#define PRELUDE_MSG_AUTH_HAVE_PLAINTEXT 1
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_SSL</NAME>
#define PRELUDE_MSG_AUTH_SSL       2
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_PLAINTEXT</NAME>
#define PRELUDE_MSG_AUTH_PLAINTEXT 3
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_USERNAME</NAME>
#define PRELUDE_MSG_AUTH_USERNAME  4
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_PASSWORD</NAME>
#define PRELUDE_MSG_AUTH_PASSWORD  5
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_SUCCEED</NAME>
#define PRELUDE_MSG_AUTH_SUCCEED   6
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_FAILED</NAME>
#define PRELUDE_MSG_AUTH_FAILED    7
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_AUTH_EXIST</NAME>
#define PRELUDE_MSG_AUTH_EXIST     8
</MACRO>
<FUNCTION>
<NAME>prelude_log_use_syslog</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_log_get_prefix</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_log_set_prefix</NAME>
<RETURNS>void  </RETURNS>
char *prefix
</FUNCTION>
<FUNCTION>
<NAME>prelude_log</NAME>
<RETURNS>void  </RETURNS>
int priority, const char *file, const char *function, int line, const char *fmt, ...
</FUNCTION>
<MACRO>
<NAME>log</NAME>
#define log(priority, args...) \
        prelude_log(priority, __FILE__, __FUNCTION__, __LINE__, args)
</MACRO>
<MACRO>
<NAME>do_init</NAME>
#define do_init(func, name) do {                         \
        char *old_prefix = prelude_log_get_prefix();     \
        prelude_log_set_prefix(NULL);                    \
        log(LOG_INFO, "- %s\n", name);                   \
        prelude_log_set_prefix(old_prefix);              \
        if ( (func) < 0 )                                \
                exit(1);                                 \
        prelude_log_set_prefix(old_prefix);              \
} while(0);
</MACRO>
<MACRO>
<NAME>do_init_nofail</NAME>
#define do_init_nofail(func, name) do {                  \
        char *old_prefix = prelude_log_get_prefix();     \
        prelude_log_set_prefix(NULL);                    \
        log(LOG_INFO, "- %s\n", name);                   \
        prelude_log_set_prefix(old_prefix);              \
        (func);                                          \
} while(0);
</MACRO>
<FUNCTION>
<NAME>ssl_init_client</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ssl_connect_server</NAME>
<RETURNS>SSL  *</RETURNS>
int socket
</FUNCTION>
<FUNCTION>
<NAME>prelude_ssl_ask_settings</NAME>
<RETURNS>void  </RETURNS>
int *keysize, int *expire
</FUNCTION>
<FUNCTION>
<NAME>prelude_auth_create_account</NAME>
<RETURNS>int  </RETURNS>
const char *filename, char **user, char **pass,int crypted, uid_t uid
</FUNCTION>
<FUNCTION>
<NAME>prelude_auth_create_account_noprompt</NAME>
<RETURNS>int  </RETURNS>
const char *filename, const char *user,const char *pass, int crypted, uid_t uid
</FUNCTION>
<FUNCTION>
<NAME>prelude_auth_check</NAME>
<RETURNS>int  </RETURNS>
const char *authfile, const char *user, const char *pass
</FUNCTION>
<MACRO>
<NAME>user_does_not_exist</NAME>
#define user_does_not_exist      -2
</MACRO>
<MACRO>
<NAME>password_does_not_match</NAME>
#define password_does_not_match  -3
</MACRO>
<FUNCTION>
<NAME>prelude_auth_read_entry</NAME>
<RETURNS>int  </RETURNS>
const char *authfile, const char *wanted_user,const char *wanted_pass, char **user, char **pass
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_string</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, uint8_t tag, idmef_string_t *string
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_uint64</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, uint8_t tag, uint64_t *data
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_uint32</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, uint8_t tag, uint32_t data
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_uint16</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, uint8_t tag, uint16_t data
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_time</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, uint8_t tag, idmef_time_t *time
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_additional_data</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_additional_data_t *data
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_additional_data_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_web_service_arg</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_webservice_arg_t *arg
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_web_service</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_webservice_t *web
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_snmp_service</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_snmpservice_t *snmp
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_service</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_service_t *service
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_address</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_address_t *address
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_address_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *address_list
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_string_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, uint8_t tag, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_process</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_process_t *process
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_node</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_node_t *node
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_userid</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_userid_t *uid
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_userid_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_user</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_user_t *user
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_source</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_source_t *source
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_source_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_file_access</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_file_access_t *access
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_file_access_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_linkage</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_linkage_t *linkage
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_linkage_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_inode</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_inode_t *inode
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_file</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_file_t *file
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_file_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_target</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_target_t *target
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_target_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_analyzer</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_analyzer_t *analyzer
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_create_time</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_time_t *time
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_classification</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_classification_t *classification
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_classification_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_confidence</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_confidence_t *confidence
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_action</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_action_t *action
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_action_list</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, struct list_head *head
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_impact</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_impact_t *impact
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_alert</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_heartbeat</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_heartbeat_t *hb
</FUNCTION>
<FUNCTION>
<NAME>idmef_send_assessment</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msg, idmef_assessment_t *assessment
</FUNCTION>
<FUNCTION>
<NAME>idmef_msg_send</NAME>
<RETURNS>int  </RETURNS>
prelude_msgbuf_t *msgbuf, idmef_message_t *idmef, uint8_t priority
</FUNCTION>
<FUNCTION>
<NAME>prelude_ident_inc</NAME>
<RETURNS>uint64_t  </RETURNS>
prelude_ident_t *ident
</FUNCTION>
<FUNCTION>
<NAME>prelude_ident_dec</NAME>
<RETURNS>uint64_t  </RETURNS>
prelude_ident_t *ident
</FUNCTION>
<FUNCTION>
<NAME>prelude_ident_destroy</NAME>
<RETURNS>void  </RETURNS>
prelude_ident_t *ident
</FUNCTION>
<FUNCTION>
<NAME>prelude_ident_new</NAME>
<RETURNS>prelude_ident_t  *</RETURNS>
const char *filename
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_destroy</NAME>
<RETURNS>void  </RETURNS>
prelude_client_t *client
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_new</NAME>
<RETURNS>prelude_client_t  *</RETURNS>
const char *addr, uint16_t port
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_send_msg</NAME>
<RETURNS>int  </RETURNS>
prelude_client_t *client, prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_connect</NAME>
<RETURNS>int  </RETURNS>
prelude_client_t *client
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_forward</NAME>
<RETURNS>ssize_t  </RETURNS>
prelude_client_t *client, prelude_io_t *src, size_t count
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_get_saddr</NAME>
<RETURNS>const char  *</RETURNS>
prelude_client_t *client
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_get_daddr</NAME>
<RETURNS>const char  *</RETURNS>
prelude_client_t *client
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_get_sport</NAME>
<RETURNS>uint16_t  </RETURNS>
prelude_client_t *client
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_get_dport</NAME>
<RETURNS>uint16_t  </RETURNS>
prelude_client_t *client
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_is_alive</NAME>
<RETURNS>int  </RETURNS>
prelude_client_t *client
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_get_analyzerid</NAME>
<RETURNS>uint64_t  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>prelude_async_func_t</NAME>
<RETURNS>void </RETURNS>
void *object, void *data
</USER_FUNCTION>
<MACRO>
<NAME>PRELUDE_ASYNC_OBJECT</NAME>
#define PRELUDE_ASYNC_OBJECT                   \
        PRELUDE_LINKED_OBJECT;                 \
        void *data;                            \
        prelude_async_func_t func
</MACRO>
<TYPEDEF>
<NAME>prelude_async_object_t</NAME>
typedef struct {
        PRELUDE_ASYNC_OBJECT;
} prelude_async_object_t;
</TYPEDEF>
<FUNCTION>
<NAME>prelude_async_init</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_async_add</NAME>
<RETURNS>void  </RETURNS>
prelude_async_object_t *obj
</FUNCTION>
<FUNCTION>
<NAME>prelude_async_del</NAME>
<RETURNS>void  </RETURNS>
prelude_async_object_t *obj
</FUNCTION>
<MACRO>
<NAME>PRELUDE_LINKED_OBJECT</NAME>
#define PRELUDE_LINKED_OBJECT \
        struct list_head list
</MACRO>
<TYPEDEF>
<NAME>prelude_linked_object_t</NAME>
typedef struct {
        PRELUDE_LINKED_OBJECT;
} prelude_linked_object_t;
</TYPEDEF>
<MACRO>
<NAME>prelude_list_get_object</NAME>
#define prelude_list_get_object(listentry, type)  \
        (type *) list_entry(listentry, prelude_linked_object_t, list)
</MACRO>
<FUNCTION>
<NAME>start_routine</NAME>
<RETURNS>return  </RETURNS>
arg
</FUNCTION>
<MACRO>
<NAME>pthread_create</NAME>
#define pthread_create gprof_pthread_create
</MACRO>
<MACRO>
<NAME>SSL_REGISTRATION_MSG_H</NAME>
#define SSL_REGISTRATION_MSG_H
</MACRO>
<MACRO>
<NAME>HEAD</NAME>
#define HEAD "PRELUDE_REGISTRATION_REQUEST"
</MACRO>
<MACRO>
<NAME>HEADLENGTH</NAME>
#define HEADLENGTH 29
</MACRO>
<MACRO>
<NAME>ACK</NAME>
#define ACK "REGISTRATION_COMPLETE"
</MACRO>
<MACRO>
<NAME>ACKLENGTH</NAME>
#define ACKLENGTH 21
</MACRO>
<MACRO>
<NAME>BUFMAXSIZE</NAME>
#define BUFMAXSIZE 1400
</MACRO>
<MACRO>
<NAME>PADMAXSIZE</NAME>
#define PADMAXSIZE 7
</MACRO>
<MACRO>
<NAME>SYSTEM_ERROR</NAME>
#define SYSTEM_ERROR          -1
</MACRO>
<MACRO>
<NAME>NOT_INSTALL_MSG</NAME>
#define NOT_INSTALL_MSG       -2
</MACRO>
<MACRO>
<NAME>INSTALL_MSG_CORRUPTED</NAME>
#define INSTALL_MSG_CORRUPTED -3
</MACRO>
<MACRO>
<NAME>WRONG_SIZE</NAME>
#define WRONG_SIZE            -4
</MACRO>
<MACRO>
<NAME>SUCCESS</NAME>
#define SUCCESS                0
</MACRO>
<FUNCTION>
<NAME>x509_to_msg</NAME>
<RETURNS>int  </RETURNS>
X509 * x509, char *msg, int msglen,des_key_schedule * key1, des_key_schedule * key2
</FUNCTION>
<FUNCTION>
<NAME>load_x509</NAME>
<RETURNS>X509  *</RETURNS>
const char *certfilename
</FUNCTION>
<FUNCTION>
<NAME>build_install_msg</NAME>
<RETURNS>int  </RETURNS>
BUF_MEM * input, char *output, int outputlen,des_key_schedule * key1, des_key_schedule * key2
</FUNCTION>
<FUNCTION>
<NAME>analyse_install_msg</NAME>
<RETURNS>int  </RETURNS>
char *input, int inputlen, char *output,int outpulen, des_key_schedule * key1,des_key_schedule * key2
</FUNCTION>
<FUNCTION>
<NAME>prelude_ssl_recv_cert</NAME>
<RETURNS>int  </RETURNS>
prelude_io_t *pio, char *out, int outlen,des_key_schedule *skey1, des_key_schedule *skey2
</FUNCTION>
<FUNCTION>
<NAME>prelude_ssl_send_cert</NAME>
<RETURNS>int  </RETURNS>
prelude_io_t *pio, const char *filename,des_key_schedule *skey1, des_key_schedule *skey2
</FUNCTION>
<FUNCTION>
<NAME>prelude_ssl_save_cert</NAME>
<RETURNS>int  </RETURNS>
const char *filename, char *cert, int certlen, uid_t uid
</FUNCTION>
<FUNCTION>
<NAME>config_get_section</NAME>
<RETURNS>int  </RETURNS>
config_t *cfg, const char *section
</FUNCTION>
<FUNCTION>
<NAME>config_get</NAME>
<RETURNS>const char  *</RETURNS>
config_t *cfg, const char *section, const char *entry
</FUNCTION>
<FUNCTION>
<NAME>config_set</NAME>
<RETURNS>int  </RETURNS>
config_t *cfg, const char *section, const char *entry, const char *val
</FUNCTION>
<FUNCTION>
<NAME>config_open</NAME>
<RETURNS>config_t  *</RETURNS>
const char *filename
</FUNCTION>
<FUNCTION>
<NAME>config_close</NAME>
<RETURNS>int  </RETURNS>
config_t *cfg
</FUNCTION>
<FUNCTION>
<NAME>prelude_get_socket_filename</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_get_auth_filename</NAME>
<RETURNS>void  </RETURNS>
char *buf, size_t size
</FUNCTION>
<FUNCTION>
<NAME>prelude_get_ssl_cert_filename</NAME>
<RETURNS>void  </RETURNS>
char *buf, size_t size
</FUNCTION>
<FUNCTION>
<NAME>prelude_get_ssl_key_filename</NAME>
<RETURNS>void  </RETURNS>
char *buf, size_t size
</FUNCTION>
<FUNCTION>
<NAME>prelude_get_backup_filename</NAME>
<RETURNS>void  </RETURNS>
char *buf, size_t size
</FUNCTION>
<FUNCTION>
<NAME>prelude_get_program_userid</NAME>
<RETURNS>uid_t  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_set_program_name</NAME>
<RETURNS>void  </RETURNS>
const char *sname
</FUNCTION>
<FUNCTION>
<NAME>prelude_set_program_userid</NAME>
<RETURNS>void  </RETURNS>
uid_t uid
</FUNCTION>
<FUNCTION>
<NAME>prelude_get_sensor_name</NAME>
<RETURNS>const char  *</RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>prelude_timer_t</NAME>
typedef struct {
        struct list_head list;

        short int expire;
        time_t start_time;

        void *data;
        void (*function)(void *data);
} prelude_timer_t;
</TYPEDEF>
<MACRO>
<NAME>timer_expire</NAME>
#define timer_expire(timer) (timer)->expire
</MACRO>
<MACRO>
<NAME>timer_data</NAME>
#define timer_data(timer) (timer)->data
</MACRO>
<MACRO>
<NAME>timer_func</NAME>
#define timer_func(timer) (timer)->function
</MACRO>
<MACRO>
<NAME>timer_set_expire</NAME>
#define timer_set_expire(timer, x) timer_expire((timer)) = (x)
</MACRO>
<MACRO>
<NAME>timer_set_data</NAME>
#define timer_set_data(timer, x) timer_data((timer)) = (x)
</MACRO>
<MACRO>
<NAME>timer_set_callback</NAME>
#define timer_set_callback(timer, x) timer_func((timer)) = (x)
</MACRO>
<FUNCTION>
<NAME>timer_init</NAME>
<RETURNS>void  </RETURNS>
prelude_timer_t *timer
</FUNCTION>
<FUNCTION>
<NAME>timer_destroy_current</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>timer_reset_current</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>timer_reset</NAME>
<RETURNS>void  </RETURNS>
prelude_timer_t *timer
</FUNCTION>
<FUNCTION>
<NAME>timer_destroy</NAME>
<RETURNS>void  </RETURNS>
prelude_timer_t *timer
</FUNCTION>
<FUNCTION>
<NAME>timer_elapsed</NAME>
<RETURNS>void  </RETURNS>
prelude_timer_t *timer, struct timeval *tv
</FUNCTION>
<FUNCTION>
<NAME>prelude_wake_up_timer</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_realloc</NAME>
<RETURNS>void  *</RETURNS>
void *ptr, size_t size
</FUNCTION>
<FUNCTION>
<NAME>prelude_resolve_addr</NAME>
<RETURNS>int  </RETURNS>
const char *hostname, struct in_addr *addr
</FUNCTION>
<FUNCTION>
<NAME>prelude_open_persistant_tmpfile</NAME>
<RETURNS>int  </RETURNS>
const char *filename, int flags, mode_t mode
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_mgr_broadcast</NAME>
<RETURNS>void  </RETURNS>
prelude_client_mgr_t *cmgr, prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_mgr_broadcast_async</NAME>
<RETURNS>void  </RETURNS>
prelude_client_mgr_t *cmgr, prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_mgr_new</NAME>
<RETURNS>prelude_client_mgr_t  *</RETURNS>
const char *cfgline
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_mgr_notify_connection</NAME>
<RETURNS>void  </RETURNS>
prelude_client_mgr_t *mgr, void (*callback)(struct list_head *clist)
</FUNCTION>
<MACRO>
<NAME>PLUGIN_GENERIC</NAME>
#define PLUGIN_GENERIC                 \
        char *name; int namelen;       \
        char *author; int authorlen;   \
        char *contact; int contactlen; \
        char *desc; int desclen
</MACRO>
<TYPEDEF>
<NAME>plugin_generic_t</NAME>
typedef struct {
        PLUGIN_GENERIC;
} plugin_generic_t;
</TYPEDEF>
<MACRO>
<NAME>plugin_name</NAME>
#define plugin_name(p) (p)->name
</MACRO>
<MACRO>
<NAME>plugin_name_len</NAME>
#define plugin_name_len(p) (p)->namelen
</MACRO>
<MACRO>
<NAME>plugin_author</NAME>
#define plugin_author(p) (p)->author
</MACRO>
<MACRO>
<NAME>plugin_author_len</NAME>
#define plugin_author_len(p) (p)->authorlen
</MACRO>
<MACRO>
<NAME>plugin_contact</NAME>
#define plugin_contact(p) (p)->contact
</MACRO>
<MACRO>
<NAME>plugin_contact_len</NAME>
#define plugin_contact_len(p) (p)->contactlen
</MACRO>
<MACRO>
<NAME>plugin_desc</NAME>
#define plugin_desc(p) (p)->desc
</MACRO>
<MACRO>
<NAME>plugin_desc_len</NAME>
#define plugin_desc_len(p) (p)->desclen
</MACRO>
<MACRO>
<NAME>plugin_set_name</NAME>
#define plugin_set_name(p, str) plugin_name(p) = (str); \
                                plugin_name_len(p) = sizeof((str))
</MACRO>
<MACRO>
<NAME>plugin_set_author</NAME>
#define plugin_set_author(p, str) plugin_author(p) = (str); \
                                  plugin_author_len(p) = sizeof((str))
</MACRO>
<MACRO>
<NAME>plugin_set_contact</NAME>
#define plugin_set_contact(p, str) plugin_contact(p) = (str); \
                                   plugin_contact_len(p) = sizeof((str))
</MACRO>
<MACRO>
<NAME>plugin_set_desc</NAME>
#define plugin_set_desc(p, str) plugin_desc(p) = (str); \
                                plugin_desc_len(p) = sizeof((str))
</MACRO>
<FUNCTION>
<NAME>plugin_subscribe</NAME>
<RETURNS>int  </RETURNS>
plugin_generic_t *plugin
</FUNCTION>
<FUNCTION>
<NAME>plugin_unsubscribe</NAME>
<RETURNS>int  </RETURNS>
plugin_generic_t *plugin
</FUNCTION>
<FUNCTION>
<NAME>plugin_request_new_id</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>PRELUDE_OPTION_START</NAME>
#define PRELUDE_OPTION_START 0
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_END</NAME>
#define PRELUDE_OPTION_END   1
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_NAME</NAME>
#define PRELUDE_OPTION_NAME  2
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_DESC</NAME>
#define PRELUDE_OPTION_DESC  3
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_HAS_ARG</NAME>
#define PRELUDE_OPTION_HAS_ARG 4
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_HELP</NAME>
#define PRELUDE_OPTION_HELP 5
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_INPUT_VALIDATION</NAME>
#define PRELUDE_OPTION_INPUT_VALIDATION 6
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_INPUT_TYPE</NAME>
#define PRELUDE_OPTION_INPUT_TYPE 7
</MACRO>
<MACRO>
<NAME>PRELUDE_OPTION_ARG</NAME>
#define PRELUDE_OPTION_ARG 8
</MACRO>
<MACRO>
<NAME>LIST_H</NAME>
#define LIST_H
</MACRO>
<MACRO>
<NAME>LIST_HEAD_INIT</NAME>
#define LIST_HEAD_INIT(name) { &(name), &(name) }
</MACRO>
<MACRO>
<NAME>LIST_HEAD</NAME>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)
</MACRO>
<MACRO>
<NAME>INIT_LIST_HEAD</NAME>
#define INIT_LIST_HEAD(ptr) do { \
	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
} while (0)
</MACRO>
<MACRO>
<NAME>list_entry</NAME>
#define list_entry(ptr, type, member) \
	((type *)((void *)(ptr) - (void *)(&((type *)0)->member)))
</MACRO>
<MACRO>
<NAME>list_for_each</NAME>
#define list_for_each(pos, head) \
	for (pos = (head)->next; pos != (head); pos = pos->next)
</MACRO>
<MACRO>
<NAME>list_for_each_safe</NAME>
#define list_for_each_safe(pos, n, head) \
        for (pos = (head)->next, n = pos->next; pos != (head); \
                pos = n, n = pos->next)
</MACRO>
<MACRO>
<NAME>prelude_assert</NAME>
#define prelude_assert(expr) \
        ((expr) ? 0 : _prelude_assert(#expr, __FILE__, __LINE__, __FUNCTION__))
</MACRO>
<FUNCTION>
<NAME>prelude_realloc</NAME>
<RETURNS>void  *</RETURNS>
void *ptr, size_t size
</FUNCTION>
<FUNCTION>
<NAME>prelude_resolve_addr</NAME>
<RETURNS>int  </RETURNS>
const char *hostname, struct in_addr *addr
</FUNCTION>
<FUNCTION>
<NAME>prelude_open_persistant_tmpfile</NAME>
<RETURNS>int  </RETURNS>
const char *filename, int flags, mode_t mode
</FUNCTION>
<FUNCTION>
<NAME>prelude_sensor_send_msg</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_sensor_send_msg_async</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_sensor_get_option_msg</NAME>
<RETURNS>prelude_msg_t  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_sensor_init</NAME>
<RETURNS>int  </RETURNS>
const char *sname, const char *filename, int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>prelude_sensor_get_ident</NAME>
<RETURNS>uint64_t  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_sensor_set_ident</NAME>
<RETURNS>void  </RETURNS>
uint64_t *ident
</FUNCTION>
<FUNCTION>
<NAME>prelude_set_sensor_name</NAME>
<RETURNS>void  </RETURNS>
const char *sname
</FUNCTION>
<FUNCTION>
<NAME>prelude_sensor_notify_mgr_connection</NAME>
<RETURNS>void  </RETURNS>
void (*cb)(struct list_head *clist)
</FUNCTION>
<FUNCTION>
<NAME>prelude_ssl_gen_crypto</NAME>
<RETURNS>int  </RETURNS>
int keysize, int expire, const char *keyout, int crypt, uid_t uid
</FUNCTION>
<MACRO>
<NAME>CLI_HOOK</NAME>
#define CLI_HOOK 0x1 /* Option to be hooked to command line */
</MACRO>
<MACRO>
<NAME>CFG_HOOK</NAME>
#define CFG_HOOK 0x2 /* Option to be hooked to config file  */
</MACRO>
<MACRO>
<NAME>WIDE_HOOK</NAME>
#define WIDE_HOOK 0x4
</MACRO>
<MACRO>
<NAME>prelude_option_success</NAME>
#define prelude_option_success 0
</MACRO>
<MACRO>
<NAME>prelude_option_end</NAME>
#define prelude_option_end 1
</MACRO>
<MACRO>
<NAME>prelude_option_error</NAME>
#define prelude_option_error -1
</MACRO>
<ENUM>
<NAME>prelude_option_argument_t</NAME>
typedef enum {
        required_argument,
        optionnal_argument,
        no_argument,
} prelude_option_argument_t;
</ENUM>
<MACRO>
<NAME>option_run_last</NAME>
#define option_run_last      -1
</MACRO>
<MACRO>
<NAME>option_run_first</NAME>
#define option_run_first     -2
</MACRO>
<MACRO>
<NAME>option_run_no_order</NAME>
#define option_run_no_order   0
</MACRO>
<FUNCTION>
<NAME>prelude_option_set_priority</NAME>
<RETURNS>void  </RETURNS>
prelude_option_t *option, int priority
</FUNCTION>
<FUNCTION>
<NAME>prelude_option_print</NAME>
<RETURNS>void  </RETURNS>
int flags, int descoff
</FUNCTION>
<FUNCTION>
<NAME>prelude_option_wide_get_msg</NAME>
<RETURNS>prelude_msg_t  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>prelude_option_destroy</NAME>
<RETURNS>void  </RETURNS>
prelude_option_t *option
</FUNCTION>
<FUNCTION>
<NAME>prelude_option_parse_arguments</NAME>
<RETURNS>int  </RETURNS>
prelude_option_t *option,const char *filename, int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>prelude_option_add</NAME>
<RETURNS>prelude_option_t  *</RETURNS>
prelude_option_t *parent, int flags,char shortopt, const char *longopt, const char *desc,prelude_option_argument_t has_arg, int (*set)(const char *optarg),int (*get)(char *buf, size_t size)
</FUNCTION>
<MACRO>
<NAME>OPT_INVAL</NAME>
#define OPT_INVAL     0x1
</MACRO>
<MACRO>
<NAME>OPT_INVAL_ARG</NAME>
#define OPT_INVAL_ARG 0x2
</MACRO>
<FUNCTION>
<NAME>prelude_option_set_warnings</NAME>
<RETURNS>void  </RETURNS>
int flags, int *old_flags
</FUNCTION>
<TYPEDEF>
<NAME>idmef_msg_send_t</NAME>
typedef struct {
        int msglen;
        int msgcount;
} idmef_msg_send_t;
</TYPEDEF>
<FUNCTION>
<NAME>idmef_source_node_new</NAME>
<RETURNS>idmef_node_t  *</RETURNS>
idmef_source_t *source
</FUNCTION>
<FUNCTION>
<NAME>idmef_source_user_new</NAME>
<RETURNS>idmef_user_t  *</RETURNS>
idmef_source_t *source
</FUNCTION>
<FUNCTION>
<NAME>idmef_source_process_new</NAME>
<RETURNS>idmef_process_t  *</RETURNS>
idmef_source_t *source
</FUNCTION>
<FUNCTION>
<NAME>idmef_source_service_new</NAME>
<RETURNS>idmef_service_t  *</RETURNS>
idmef_source_t *source
</FUNCTION>
<MACRO>
<NAME>idmef_target_node_new</NAME>
#define idmef_target_node_new(target) idmef_source_node_new((idmef_source_t *) (target))
</MACRO>
<MACRO>
<NAME>idmef_target_user_new</NAME>
#define idmef_target_user_new(target) idmef_source_user_new((idmef_source_t *) (target))
</MACRO>
<MACRO>
<NAME>idmef_target_process_new</NAME>
#define idmef_target_process_new(target) idmef_source_process_new((idmef_source_t *) (target))
</MACRO>
<MACRO>
<NAME>idmef_target_service_new</NAME>
#define idmef_target_service_new(target) idmef_source_service_new((idmef_source_t *) (target))
</MACRO>
<FUNCTION>
<NAME>idmef_analyzer_node_new</NAME>
<RETURNS>void  </RETURNS>
idmef_analyzer_t *analyzer
</FUNCTION>
<FUNCTION>
<NAME>idmef_analyzer_process_new</NAME>
<RETURNS>void  </RETURNS>
idmef_analyzer_t *analyzer
</FUNCTION>
<FUNCTION>
<NAME>idmef_process_env_new</NAME>
<RETURNS>idmef_process_env_t  *</RETURNS>
idmef_process_t *process
</FUNCTION>
<FUNCTION>
<NAME>idmef_process_arg_new</NAME>
<RETURNS>idmef_process_arg_t  *</RETURNS>
idmef_process_t *process
</FUNCTION>
<FUNCTION>
<NAME>idmef_user_userid_new</NAME>
<RETURNS>idmef_userid_t  *</RETURNS>
idmef_user_t *user
</FUNCTION>
<FUNCTION>
<NAME>idmef_node_address_new</NAME>
<RETURNS>idmef_address_t  *</RETURNS>
idmef_node_t *node
</FUNCTION>
<FUNCTION>
<NAME>idmef_webservice_arg_new</NAME>
<RETURNS>idmef_webservice_arg_t  *</RETURNS>
idmef_webservice_t *w
</FUNCTION>
<FUNCTION>
<NAME>idmef_service_webservice_new</NAME>
<RETURNS>idmef_webservice_t  *</RETURNS>
idmef_service_t *service
</FUNCTION>
<FUNCTION>
<NAME>idmef_service_snmpservice_new</NAME>
<RETURNS>idmef_snmpservice_t  *</RETURNS>
idmef_service_t *service
</FUNCTION>
<FUNCTION>
<NAME>idmef_tool_alert_new</NAME>
<RETURNS>void  </RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_overflow_alert_new</NAME>
<RETURNS>void  </RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_correlation_alert_new</NAME>
<RETURNS>void  </RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_tool_alert_alertident_new</NAME>
<RETURNS>idmef_alertident_t  *</RETURNS>
idmef_tool_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_correlation_alert_alertident_new</NAME>
<RETURNS>idmef_alertident_t  *</RETURNS>
idmef_correlation_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_assessment_impact_new</NAME>
<RETURNS>void  </RETURNS>
idmef_assessment_t *assessment
</FUNCTION>
<FUNCTION>
<NAME>idmef_assessment_confidence_new</NAME>
<RETURNS>void  </RETURNS>
idmef_assessment_t *assessment
</FUNCTION>
<FUNCTION>
<NAME>idmef_assessment_action_new</NAME>
<RETURNS>idmef_action_t  *</RETURNS>
idmef_assessment_t *assessment
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_new</NAME>
<RETURNS>void  </RETURNS>
idmef_message_t *message
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_assessment_new</NAME>
<RETURNS>void  </RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_detect_time_new</NAME>
<RETURNS>void  </RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_analyzer_time_new</NAME>
<RETURNS>void  </RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_source_new</NAME>
<RETURNS>idmef_source_t  *</RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_target_new</NAME>
<RETURNS>idmef_target_t  *</RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_classification_new</NAME>
<RETURNS>idmef_classification_t  *</RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_alert_additional_data_new</NAME>
<RETURNS>idmef_additional_data_t  *</RETURNS>
idmef_alert_t *alert
</FUNCTION>
<FUNCTION>
<NAME>idmef_heartbeat_new</NAME>
<RETURNS>void  </RETURNS>
idmef_message_t *message
</FUNCTION>
<FUNCTION>
<NAME>idmef_heartbeat_analyzer_time_new</NAME>
<RETURNS>void  </RETURNS>
idmef_heartbeat_t *heartbeat
</FUNCTION>
<FUNCTION>
<NAME>idmef_heartbeat_additional_data_new</NAME>
<RETURNS>idmef_additional_data_t  *</RETURNS>
idmef_heartbeat_t *heartbeat
</FUNCTION>
<FUNCTION>
<NAME>idmef_message_new</NAME>
<RETURNS>idmef_message_t  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>idmef_message_free</NAME>
<RETURNS>void  </RETURNS>
idmef_message_t *msg
</FUNCTION>
<FUNCTION>
<NAME>idmef_additional_data_free</NAME>
<RETURNS>void  </RETURNS>
idmef_additional_data_t *data
</FUNCTION>
<MACRO>
<NAME>idmef_string</NAME>
#define idmef_string(s) (s)->string
</MACRO>
<MACRO>
<NAME>idmef_string_len</NAME>
#define idmef_string_len(s) (s)->len
</MACRO>
<MACRO>
<NAME>idmef_string_copy</NAME>
#define idmef_string_copy(dst, src) do {                   \
        (dst)->len = (src)->len;                           \
        (dst)->string = (src)->string;                     \
} while(0)
</MACRO>
<MACRO>
<NAME>idmef_string_set_constant</NAME>
#define idmef_string_set_constant(s, str) do {             \
	(s)->string = (str); (s)->len = sizeof((str));     \
} while (0)
</MACRO>
<MACRO>
<NAME>idmef_string_set</NAME>
#define idmef_string_set(s, str) do {                      \
	(s)->string = (str); (s)->len = strlen((str)) + 1; \
} while (0)
</MACRO>
<MACRO>
<NAME>IDMEF_VERSION</NAME>
#define IDMEF_VERSION "0.6"
</MACRO>
<TYPEDEF>
<NAME>idmef_string_t</NAME>
typedef struct {
        uint16_t len;
        const char *string;
} idmef_string_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_time_t</NAME>
typedef struct {
        uint32_t sec;
        uint32_t usec;
} idmef_time_t;
</TYPEDEF>
<MACRO>
<NAME>idmef_create_time_t</NAME>
#define idmef_create_time_t idmef_time_t
</MACRO>
<MACRO>
<NAME>idmef_detect_time_t</NAME>
#define idmef_detect_time_t idmef_time_t
</MACRO>
<MACRO>
<NAME>idmef_analyzer_time_t</NAME>
#define idmef_analyzer_time_t idmef_time_t
</MACRO>
<ENUM>
<NAME>idmef_additional_data_type_t</NAME>
typedef enum {
        string    = 0,
        boolean   = 1,
        byte      = 2,
        character = 3,
        date_time = 4,
        integer   = 5,
        ntpstamp  = 6,
        portlist  = 7,
        real      = 8,
        xml       = 9,
} idmef_additional_data_type_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_additional_data_t</NAME>
typedef struct {
        struct list_head list;
        idmef_additional_data_type_t type;
        idmef_string_t meaning;
        idmef_string_t data;
} idmef_additional_data_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_classification_origin_t</NAME>
typedef enum {
        origin_unknown  = 0,
        bugtraqid       = 1,
        cve             = 2,
        vendor_specific = 3,
} idmef_classification_origin_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_classification_t</NAME>
typedef struct {
        struct list_head list;
        idmef_classification_origin_t origin;
        idmef_string_t name;
        idmef_string_t url;
} idmef_classification_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_userid_type_t</NAME>
typedef enum {
        original_user = 0,
        current_user  = 1,
        target_user   = 2,
        user_privs    = 3,
        current_group = 4,
        group_privs   = 5,
        other_privs   = 6,
} idmef_userid_type_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_userid_t</NAME>
typedef struct {
        struct list_head list;

        uint64_t ident;
        idmef_userid_type_t type;
        idmef_string_t name;
        uint32_t number;
} idmef_userid_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_user_category_t</NAME>
typedef enum {
        cat_unknown  = 0,
        application  = 1,
        os_device    = 2,
} idmef_user_category_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_user_t</NAME>
typedef struct {
        uint64_t ident;
        idmef_user_category_t category;
        struct list_head userid_list;
} idmef_user_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_address_category_t</NAME>
typedef enum {
        addr_unknown  = 0,
        atm           = 1,
        e_mail        = 2,
        lotus_notes   = 3,
        mac           = 4,
        sna           = 5,
        vm            = 6,
        ipv4_addr     = 7,
        ipv4_addr_hex = 8,
        ipv4_net      = 9,
        ipv4_net_mask = 10,
        ipv6_addr     = 11,
        ipv6_addr_hex = 12,
        ipv6_net      = 13,
        ipv6_net_mask = 14,
} idmef_address_category_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_address_t</NAME>
typedef struct {
        struct list_head list;
        
        uint64_t ident;
        idmef_address_category_t category;
        idmef_string_t vlan_name;
        int vlan_num;
        idmef_string_t address;
        idmef_string_t netmask;
} idmef_address_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_string_item_t</NAME>
typedef struct {
        idmef_string_t string;
        struct list_head list;
} idmef_string_item_t;
</TYPEDEF>
<MACRO>
<NAME>idmef_process_env_t</NAME>
#define idmef_process_env_t idmef_string_item_t
</MACRO>
<MACRO>
<NAME>idmef_process_arg_t</NAME>
#define idmef_process_arg_t idmef_string_item_t
</MACRO>
<TYPEDEF>
<NAME>idmef_process_t</NAME>
typedef struct {
        uint64_t ident;
        idmef_string_t name;
        uint32_t pid;
        idmef_string_t path;

        struct list_head arg_list;
        struct list_head env_list;
} idmef_process_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_webservice_arg_t</NAME>
typedef struct {
        struct list_head list;
        idmef_string_t arg;
} idmef_webservice_arg_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_webservice_t</NAME>
typedef struct {
        idmef_string_t url;
        idmef_string_t cgi;
        idmef_string_t http_method;
        struct list_head arg_list;
} idmef_webservice_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_snmpservice_t</NAME>
typedef struct {
        idmef_string_t oid;
        idmef_string_t community;
        idmef_string_t command;
} idmef_snmpservice_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_service_type_t</NAME>
typedef enum {
        no_specific_service = 0,
        web_service = 1,
        snmp_service = 2,
} idmef_service_type_t;
</ENUM>
<TYPEDEF>
<NAME>specific</NAME>
typedef struct {
        uint64_t ident;
        idmef_string_t name;
        uint16_t port;
        idmef_string_t portlist;
        idmef_string_t protocol;

        idmef_service_type_t type;
        union {
                idmef_webservice_t *web;
                idmef_snmpservice_t *snmp;
        } specific;
        
</TYPEDEF>
<ENUM>
<NAME>idmef_node_category_t</NAME>
typedef enum {
        node_unknown = 0,
        ads          = 1,
        afs          = 2,
        coda         = 3,
        dfs          = 4,
        dns          = 5,
        hosts        = 6,
        kerberos     = 7,
        nds          = 8,
        nis          = 9,
        nisplus      = 10,
        nt           = 11,
        wfw          = 12,
} idmef_node_category_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_node_t</NAME>
typedef struct {
        uint64_t ident;
        idmef_node_category_t category;
        idmef_string_t location;
        idmef_string_t name;
        struct list_head address_list;
} idmef_node_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_spoofed_t</NAME>
typedef enum {
        unknown = 0,
        yes     = 1,
        no      = 2,
} idmef_spoofed_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_source_t</NAME>
typedef struct {
        struct list_head list;
    
        uint64_t ident;
        idmef_spoofed_t spoofed;
        idmef_string_t interface;

        idmef_node_t *node;
        idmef_user_t *user;
        idmef_process_t *process;
        idmef_service_t *service;
        
} idmef_source_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_file_access_t</NAME>
typedef struct {
        struct list_head list;
        idmef_userid_t userid;
        idmef_string_t permission;
} idmef_file_access_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_linkage_category_t</NAME>
typedef enum {
        hard_link     = 1,
        mount_point   = 2,
        reparse_point = 3,
        shortcut      = 4,
        stream        = 5,
        symbolic_link = 6,
} idmef_linkage_category_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_linkage_t</NAME>
typedef struct {
        struct list_head list;
        
        idmef_linkage_category_t category;
        idmef_string_t name;
        idmef_string_t path;
        struct idmef_file *file;
} idmef_linkage_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_inode_t</NAME>
typedef struct {
        idmef_time_t change_time;
        uint32_t number;
        uint32_t major_device;
        uint32_t minor_device;
        uint32_t c_major_device;
        uint32_t c_minor_device;
} idmef_inode_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_file_category_t</NAME>
typedef enum {
        current  = 1,
        original = 2,
} idmef_file_category_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_target_t</NAME>
typedef struct {
        struct list_head list;
        
        uint64_t ident;
        idmef_spoofed_t decoy;
        idmef_string_t interface;

        idmef_node_t *node;
        idmef_user_t *user;
        idmef_process_t *process;
        idmef_service_t *service;
        struct list_head file_list;
} idmef_target_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_analyzer_t</NAME>
typedef struct {
        uint64_t analyzerid;
        idmef_string_t manufacturer;
        idmef_string_t model;
        idmef_string_t version;
        idmef_string_t class;
        idmef_string_t ostype;
        idmef_string_t osversion;
        
        idmef_node_t *node;
        idmef_process_t *process;
} idmef_analyzer_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_alertident_t</NAME>
typedef struct {
        struct list_head list;
        uint64_t alertident;
        uint64_t analyzerid;
} idmef_alertident_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_impact_severity_t</NAME>
typedef enum {
        impact_low    = 1,
        impact_medium = 2,
        impact_high   = 3,
} idmef_impact_severity_t;
</ENUM>
<ENUM>
<NAME>idmef_impact_completion_t</NAME>
typedef enum {
        failed     = 1,
        succeeded  = 2,
} idmef_impact_completion_t;
</ENUM>
<ENUM>
<NAME>idmef_impact_type_t</NAME>
typedef enum {
        other      = 0,
        admin      = 1,
        dos        = 2,
        file       = 3,
        recon      = 4,
        user       = 5,
} idmef_impact_type_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_impact_t</NAME>
typedef struct {
        idmef_impact_severity_t severity;
        idmef_impact_completion_t completion;
        idmef_impact_type_t type;
        idmef_string_t description;
} idmef_impact_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_action_category_t</NAME>
typedef enum {
        action_other       = 0,
        block_installed    = 1,
        notification_sent  = 2,
        taken_offline      = 3,
} idmef_action_category_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_action_t</NAME>
typedef struct {
        struct list_head list;
        idmef_action_category_t category;
        idmef_string_t description;
} idmef_action_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_confidence_rating_t</NAME>
typedef enum {
        numeric = 0,
        low     = 1,
        medium  = 2,
        high    = 3,
} idmef_confidence_rating_t;
</ENUM>
<TYPEDEF>
<NAME>idmef_confidence_t</NAME>
typedef struct {
        idmef_confidence_rating_t rating;
        float confidence;
} idmef_confidence_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_assessment_t</NAME>
typedef struct {
        idmef_impact_t *impact;
        struct list_head action_list;
        idmef_confidence_t *confidence;
} idmef_assessment_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_tool_alert_t</NAME>
typedef struct {
        idmef_string_t name;
        idmef_string_t command;
        struct list_head alertident_list;
} idmef_tool_alert_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_correlation_alert_t</NAME>
typedef struct {
        idmef_string_t name;
        struct list_head alertident_list;
} idmef_correlation_alert_t;
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_overflow_alert_t</NAME>
typedef struct {
        idmef_string_t program;
        uint32_t size;
        const unsigned char *buffer;
} idmef_overflow_alert_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_alert_type_t</NAME>
typedef enum {
        idmef_default           = 0,
        idmef_tool_alert        = 1,
        idmef_correlation_alert = 2,
        idmef_overflow_alert    = 3,
} idmef_alert_type_t;
</ENUM>
<TYPEDEF>
<NAME>detail</NAME>
typedef struct {
        uint64_t ident;

        idmef_assessment_t *assessment;
    
        idmef_analyzer_t analyzer;
    
        idmef_time_t create_time;
        idmef_time_t *detect_time;
        idmef_time_t *analyzer_time;

        struct list_head source_list;
        struct list_head target_list;
        struct list_head classification_list;
        struct list_head additional_data_list;

        idmef_alert_type_t type;
        union {
                idmef_tool_alert_t *tool_alert;
                idmef_correlation_alert_t *correlation_alert;
                idmef_overflow_alert_t *overflow_alert;
        } detail;
        
</TYPEDEF>
<TYPEDEF>
<NAME>idmef_heartbeat_t</NAME>
typedef struct {
        uint64_t ident;
        idmef_analyzer_t analyzer;

        idmef_time_t create_time;
        idmef_time_t *analyzer_time;

        struct list_head additional_data_list;
} idmef_heartbeat_t;
</TYPEDEF>
<ENUM>
<NAME>idmef_message_type_t</NAME>
typedef enum {
        idmef_alert_message     = 1,
        idmef_heartbeat_message = 2,
} idmef_message_type_t;
</ENUM>
<TYPEDEF>
<NAME>message</NAME>
typedef struct {        

        /*
         * end of specific things.
         */
        idmef_string_t version;

        idmef_message_type_t type;
        union {
                idmef_alert_t *alert;
                idmef_heartbeat_t *heartbeat;
        } message;
        
</TYPEDEF>
<FUNCTION>
<NAME>prelude_msgbuf_new</NAME>
<RETURNS>prelude_msgbuf_t  *</RETURNS>
int async_send
</FUNCTION>
<FUNCTION>
<NAME>prelude_msgbuf_close</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msgbuf
</FUNCTION>
<FUNCTION>
<NAME>prelude_msgbuf_mark_end</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msgbuf
</FUNCTION>
<FUNCTION>
<NAME>prelude_msgbuf_set</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msgbuf, uint8_t tag, uint32_t len, const void *data
</FUNCTION>
<FUNCTION>
<NAME>prelude_msgbuf_set_header</NAME>
<RETURNS>void  </RETURNS>
prelude_msgbuf_t *msgbuf, uint8_t tag, uint8_t priority
</FUNCTION>
<TYPEDEF>
<NAME>size_t</NAME>
 typedef unsigned int size_t;
</TYPEDEF>
<TYPEDEF>
<NAME>ssize_t</NAME>
 typedef int ssize_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint8_t</NAME>
 typedef unsigned char uint8_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint16_t</NAME>
 typedef unsigned short int uint16_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint32_t</NAME>
 typedef unsigned int uint32_t;
</TYPEDEF>
<MACRO>
<NAME>PRELUDE_MSG_PRIORITY_HIGH</NAME>
#define PRELUDE_MSG_PRIORITY_HIGH 0
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_PRIORITY_MID</NAME>
#define PRELUDE_MSG_PRIORITY_MID  1
</MACRO>
<MACRO>
<NAME>PRELUDE_MSG_PRIORITY_LOW</NAME>
#define PRELUDE_MSG_PRIORITY_LOW  2
</MACRO>
<ENUM>
<NAME>prelude_msg_status_t</NAME>
typedef enum {
        prelude_msg_error      = -1,
        prelude_msg_eof        =  0,
        prelude_msg_unfinished =  1,
        prelude_msg_finished   =  2,
} prelude_msg_status_t;
</ENUM>
<FUNCTION>
<NAME>prelude_msg_read</NAME>
<RETURNS>prelude_msg_status_t  </RETURNS>
prelude_msg_t **msg, prelude_io_t *pio
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_forward</NAME>
<RETURNS>int  </RETURNS>
prelude_msg_t *msg, prelude_io_t *dst, prelude_io_t *src
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_get</NAME>
<RETURNS>int  </RETURNS>
prelude_msg_t *msg, uint8_t *tag, uint32_t *len, void **buf
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_recycle</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_mark_end</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_dynamic_new</NAME>
<RETURNS>prelude_msg_t  *</RETURNS>
uint8_t tag, uint8_t priority, void *data,prelude_msg_t *(*flush_msg_cb)(void *data)
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_new</NAME>
<RETURNS>prelude_msg_t  *</RETURNS>
size_t msgcount, size_t msglen, uint8_t tag, uint8_t priority
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_set</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg, uint8_t tag, uint32_t len, const void *data
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_write</NAME>
<RETURNS>int  </RETURNS>
prelude_msg_t *msg, prelude_io_t *dst
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_set_tag</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg, uint8_t tag
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_set_priority</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg, uint8_t priority
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_get_tag</NAME>
<RETURNS>uint8_t  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_get_version</NAME>
<RETURNS>uint8_t  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_get_priority</NAME>
<RETURNS>uint8_t  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_get_datalen</NAME>
<RETURNS>uint32_t  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_destroy</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>prelude_msg_reset</NAME>
<RETURNS>void  </RETURNS>
prelude_msg_t *msg
</FUNCTION>
<FUNCTION>
<NAME>ntohs</NAME>
<RETURNS>return  </RETURNS>
tmp
</FUNCTION>
<FUNCTION>
<NAME>ntohl</NAME>
<RETURNS>return  </RETURNS>
tmp
</FUNCTION>
<MACRO>
<NAME>extract_uint16</NAME>
#define extract_uint16(x) ntohs((*(const uint16_t *) (x)))
</MACRO>
<MACRO>
<NAME>extract_uint32</NAME>
#define extract_uint32(x) ntohl((*(const uint32_t *) (x)))
</MACRO>
<MACRO>
<NAME>extract_ipv4_addr</NAME>
#define extract_ipv4_addr(x) *((const struct in_addr *) (x))
</MACRO>
<TYPEDEF>
<NAME>bm_string_t</NAME>
typedef struct {

	char *pattern;
	int length;

	int *bad_character_shift;
	int *good_suffix_shift;

} bm_string_t;
</TYPEDEF>
<FUNCTION>
<NAME>BoyerMoore_Init</NAME>
<RETURNS>bm_string_t  *</RETURNS>
 char *y, int n
</FUNCTION>
<FUNCTION>
<NAME>BoyerMoore_MakeCaseInsensitive</NAME>
<RETURNS>void  </RETURNS>
 bm_string_t *string
</FUNCTION>
<FUNCTION>
<NAME>BoyerMoore_StringMatching</NAME>
<RETURNS>int  </RETURNS>
char *y, int n, char *x, int m,int bm_bc[], int bm_gs[]
</FUNCTION>
<FUNCTION>
<NAME>BoyerMoore_CI_StringMatching</NAME>
<RETURNS>int  </RETURNS>
char *y, int n, char *x, int m,int bm_bc[], int bm_gs[]
</FUNCTION>
<FUNCTION>
<NAME>BoyerMoore_GoodSuffixShift</NAME>
<RETURNS>void  </RETURNS>
char *x, int m, int bm_gs[]
</FUNCTION>
<FUNCTION>
<NAME>BoyerMoore_BadCharacterShift</NAME>
<RETURNS>void  </RETURNS>
char *x, int m, int bm_bc[]
</FUNCTION>
<MACRO>
<NAME>MSG_ALERT_TAG</NAME>
#define MSG_ALERT_TAG                                    0
</MACRO>
<MACRO>
<NAME>MSG_CREATE_TIME_TAG</NAME>
#define MSG_CREATE_TIME_TAG                              1
</MACRO>
<MACRO>
<NAME>MSG_DETECT_TIME_TAG</NAME>
#define MSG_DETECT_TIME_TAG                              2
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_TIME_TAG</NAME>
#define MSG_ANALYZER_TIME_TAG                            3
</MACRO>
<MACRO>
<NAME>MSG_SOURCE_TAG</NAME>
#define MSG_SOURCE_TAG                                   4
</MACRO>
<MACRO>
<NAME>MSG_NODE_TAG</NAME>
#define MSG_NODE_TAG                                     5
</MACRO>
<MACRO>
<NAME>MSG_ADDRESS_TAG</NAME>
#define MSG_ADDRESS_TAG                                  6
</MACRO>
<MACRO>
<NAME>MSG_USER_TAG</NAME>
#define MSG_USER_TAG                                     7
</MACRO>
<MACRO>
<NAME>MSG_USERID_TAG</NAME>
#define MSG_USERID_TAG                                   8
</MACRO>
<MACRO>
<NAME>MSG_PROCESS_TAG</NAME>
#define MSG_PROCESS_TAG                                  9
</MACRO>
<MACRO>
<NAME>MSG_SERVICE_TAG</NAME>
#define MSG_SERVICE_TAG                                 10
</MACRO>
<MACRO>
<NAME>MSG_WEBSERVICE_TAG</NAME>
#define MSG_WEBSERVICE_TAG                              11
</MACRO>
<MACRO>
<NAME>MSG_SNMPSERVICE_TAG</NAME>
#define MSG_SNMPSERVICE_TAG                             12
</MACRO>
<MACRO>
<NAME>MSG_CLASSIFICATION_TAG</NAME>
#define MSG_CLASSIFICATION_TAG                          13
</MACRO>
<MACRO>
<NAME>MSG_ADDITIONALDATA_TAG</NAME>
#define MSG_ADDITIONALDATA_TAG                          14
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_TAG</NAME>
#define MSG_ANALYZER_TAG                                15
</MACRO>
<MACRO>
<NAME>MSG_TARGET_TAG</NAME>
#define MSG_TARGET_TAG                                  16
</MACRO>
<MACRO>
<NAME>MSG_HEARTBEAT_TAG</NAME>
#define MSG_HEARTBEAT_TAG                               17
</MACRO>
<MACRO>
<NAME>MSG_TOOL_ALERT_TAG</NAME>
#define MSG_TOOL_ALERT_TAG                              18
</MACRO>
<MACRO>
<NAME>MSG_CORRELATION_ALERT_TAG</NAME>
#define MSG_CORRELATION_ALERT_TAG                       19
</MACRO>
<MACRO>
<NAME>MSG_OVERFLOW_ALERT_TAG</NAME>
#define MSG_OVERFLOW_ALERT_TAG                          20
</MACRO>
<MACRO>
<NAME>MSG_ALERTIDENT_TAG</NAME>
#define MSG_ALERTIDENT_TAG                              21
</MACRO>
<MACRO>
<NAME>MSG_FILE_TAG</NAME>
#define MSG_FILE_TAG                                    22
</MACRO>
<MACRO>
<NAME>MSG_ACCESS_TAG</NAME>
#define MSG_ACCESS_TAG                                  23
</MACRO>
<MACRO>
<NAME>MSG_LINKAGE_TAG</NAME>
#define MSG_LINKAGE_TAG                                 24
</MACRO>
<MACRO>
<NAME>MSG_INODE_TAG</NAME>
#define MSG_INODE_TAG                                   25
</MACRO>
<MACRO>
<NAME>MSG_CONFIDENCE_TAG</NAME>
#define MSG_CONFIDENCE_TAG                              26
</MACRO>
<MACRO>
<NAME>MSG_ACTION_TAG</NAME>
#define MSG_ACTION_TAG                                  27
</MACRO>
<MACRO>
<NAME>MSG_IMPACT_TAG</NAME>
#define MSG_IMPACT_TAG                                  28
</MACRO>
<MACRO>
<NAME>MSG_ASSESSMENT_TAG</NAME>
#define MSG_ASSESSMENT_TAG                              29
</MACRO>
<MACRO>
<NAME>MSG_OWN_FORMAT</NAME>
#define MSG_OWN_FORMAT                                 253
</MACRO>
<MACRO>
<NAME>MSG_END_OF_TAG</NAME>
#define MSG_END_OF_TAG                                 254
</MACRO>
<MACRO>
<NAME>MSG_FORMAT_PRELUDE_NIDS</NAME>
#define MSG_FORMAT_PRELUDE_NIDS 1
</MACRO>
<MACRO>
<NAME>MSG_CONFIDENCE_RATING</NAME>
#define MSG_CONFIDENCE_RATING 0
</MACRO>
<MACRO>
<NAME>MSG_CONFIDENCE_CONFIDENCE</NAME>
#define MSG_CONFIDENCE_CONFIDENCE 1
</MACRO>
<MACRO>
<NAME>MSG_ACTION_CATEGORY</NAME>
#define MSG_ACTION_CATEGORY 0
</MACRO>
<MACRO>
<NAME>MSG_ACTION_DESCRIPTION</NAME>
#define MSG_ACTION_DESCRIPTION 1
</MACRO>
<MACRO>
<NAME>MSG_IMPACT_SEVERITY</NAME>
#define MSG_IMPACT_SEVERITY 0
</MACRO>
<MACRO>
<NAME>MSG_IMPACT_COMPLETION</NAME>
#define MSG_IMPACT_COMPLETION 1
</MACRO>
<MACRO>
<NAME>MSG_IMPACT_TYPE</NAME>
#define MSG_IMPACT_TYPE 2
</MACRO>
<MACRO>
<NAME>MSG_IMPACT_DESCRIPTION</NAME>
#define MSG_IMPACT_DESCRIPTION 3
</MACRO>
<MACRO>
<NAME>MSG_FILE_IDENT</NAME>
#define MSG_FILE_IDENT 0
</MACRO>
<MACRO>
<NAME>MSG_FILE_CATEGORY</NAME>
#define MSG_FILE_CATEGORY 1
</MACRO>
<MACRO>
<NAME>MSG_FILE_FSTYPE</NAME>
#define MSG_FILE_FSTYPE 2
</MACRO>
<MACRO>
<NAME>MSG_FILE_NAME</NAME>
#define MSG_FILE_NAME 3
</MACRO>
<MACRO>
<NAME>MSG_FILE_PATH</NAME>
#define MSG_FILE_PATH 4
</MACRO>
<MACRO>
<NAME>MSG_FILE_CREATE_TIME_TAG</NAME>
#define MSG_FILE_CREATE_TIME_TAG 5
</MACRO>
<MACRO>
<NAME>MSG_FILE_MODIFY_TIME_TAG</NAME>
#define MSG_FILE_MODIFY_TIME_TAG 6
</MACRO>
<MACRO>
<NAME>MSG_FILE_ACCESS_TIME_TAG</NAME>
#define MSG_FILE_ACCESS_TIME_TAG 7
</MACRO>
<MACRO>
<NAME>MSG_FILE_DATASIZE</NAME>
#define MSG_FILE_DATASIZE 8
</MACRO>
<MACRO>
<NAME>MSG_FILE_DISKSIZE</NAME>
#define MSG_FILE_DISKSIZE 9
</MACRO>
<MACRO>
<NAME>MSG_LINKAGE_CATEGORY</NAME>
#define MSG_LINKAGE_CATEGORY 0
</MACRO>
<MACRO>
<NAME>MSG_LINKAGE_NAME</NAME>
#define MSG_LINKAGE_NAME 1
</MACRO>
<MACRO>
<NAME>MSG_LINKAGE_PATH</NAME>
#define MSG_LINKAGE_PATH 2
</MACRO>
<MACRO>
<NAME>MSG_LINKAGE_FILE</NAME>
#define MSG_LINKAGE_FILE 3
</MACRO>
<MACRO>
<NAME>MSG_INODE_CHANGE_TIME</NAME>
#define MSG_INODE_CHANGE_TIME 0
</MACRO>
<MACRO>
<NAME>MSG_INODE_NUMBER</NAME>
#define MSG_INODE_NUMBER 1
</MACRO>
<MACRO>
<NAME>MSG_INODE_MAJOR_DEVICE</NAME>
#define MSG_INODE_MAJOR_DEVICE 2
</MACRO>
<MACRO>
<NAME>MSG_INODE_MINOR_DEVICE</NAME>
#define MSG_INODE_MINOR_DEVICE 3
</MACRO>
<MACRO>
<NAME>MSG_INODE_C_MAJOR_DEVICE</NAME>
#define MSG_INODE_C_MAJOR_DEVICE 4
</MACRO>
<MACRO>
<NAME>MSG_INODE_C_MINOR_DEVICE</NAME>
#define MSG_INODE_C_MINOR_DEVICE 5
</MACRO>
<MACRO>
<NAME>MSG_ACCESS_PERMISSION</NAME>
#define MSG_ACCESS_PERMISSION 0
</MACRO>
<MACRO>
<NAME>MSG_ALERT_IDENT</NAME>
#define MSG_ALERT_IDENT  0
</MACRO>
<MACRO>
<NAME>MSG_SOURCE_IDENT</NAME>
#define MSG_SOURCE_IDENT     0
</MACRO>
<MACRO>
<NAME>MSG_SOURCE_SPOOFED</NAME>
#define MSG_SOURCE_SPOOFED   1
</MACRO>
<MACRO>
<NAME>MSG_SOURCE_INTERFACE</NAME>
#define MSG_SOURCE_INTERFACE 2
</MACRO>
<MACRO>
<NAME>MSG_NODE_IDENT</NAME>
#define MSG_NODE_IDENT       0
</MACRO>
<MACRO>
<NAME>MSG_NODE_CATEGORY</NAME>
#define MSG_NODE_CATEGORY    1
</MACRO>
<MACRO>
<NAME>MSG_NODE_LOCATION</NAME>
#define MSG_NODE_LOCATION    2
</MACRO>
<MACRO>
<NAME>MSG_NODE_NAME</NAME>
#define MSG_NODE_NAME        3
</MACRO>
<MACRO>
<NAME>MSG_ADDRESS_IDENT</NAME>
#define MSG_ADDRESS_IDENT     0
</MACRO>
<MACRO>
<NAME>MSG_ADDRESS_CATEGORY</NAME>
#define MSG_ADDRESS_CATEGORY  1
</MACRO>
<MACRO>
<NAME>MSG_ADDRESS_VLAN_NAME</NAME>
#define MSG_ADDRESS_VLAN_NAME 2
</MACRO>
<MACRO>
<NAME>MSG_ADDRESS_VLAN_NUM</NAME>
#define MSG_ADDRESS_VLAN_NUM  3
</MACRO>
<MACRO>
<NAME>MSG_ADDRESS_ADDRESS</NAME>
#define MSG_ADDRESS_ADDRESS   4
</MACRO>
<MACRO>
<NAME>MSG_ADDRESS_NETMASK</NAME>
#define MSG_ADDRESS_NETMASK   5
</MACRO>
<MACRO>
<NAME>MSG_USER_IDENT</NAME>
#define MSG_USER_IDENT    0
</MACRO>
<MACRO>
<NAME>MSG_USER_CATEGORY</NAME>
#define MSG_USER_CATEGORY 1
</MACRO>
<MACRO>
<NAME>MSG_USERID_IDENT</NAME>
#define MSG_USERID_IDENT  0
</MACRO>
<MACRO>
<NAME>MSG_USERID_TYPE</NAME>
#define MSG_USERID_TYPE   1
</MACRO>
<MACRO>
<NAME>MSG_USERID_NAME</NAME>
#define MSG_USERID_NAME   2
</MACRO>
<MACRO>
<NAME>MSG_USERID_NUMBER</NAME>
#define MSG_USERID_NUMBER 3
</MACRO>
<MACRO>
<NAME>MSG_PROCESS_IDENT</NAME>
#define MSG_PROCESS_IDENT 0
</MACRO>
<MACRO>
<NAME>MSG_PROCESS_NAME</NAME>
#define MSG_PROCESS_NAME  1
</MACRO>
<MACRO>
<NAME>MSG_PROCESS_PID</NAME>
#define MSG_PROCESS_PID   2
</MACRO>
<MACRO>
<NAME>MSG_PROCESS_PATH</NAME>
#define MSG_PROCESS_PATH  3
</MACRO>
<MACRO>
<NAME>MSG_PROCESS_ARG</NAME>
#define MSG_PROCESS_ARG   4
</MACRO>
<MACRO>
<NAME>MSG_PROCESS_ENV</NAME>
#define MSG_PROCESS_ENV   5
</MACRO>
<MACRO>
<NAME>MSG_SERVICE_IDENT</NAME>
#define MSG_SERVICE_IDENT     0
</MACRO>
<MACRO>
<NAME>MSG_SERVICE_NAME</NAME>
#define MSG_SERVICE_NAME      1
</MACRO>
<MACRO>
<NAME>MSG_SERVICE_PORT</NAME>
#define MSG_SERVICE_PORT      2
</MACRO>
<MACRO>
<NAME>MSG_SERVICE_PORTLIST</NAME>
#define MSG_SERVICE_PORTLIST  3
</MACRO>
<MACRO>
<NAME>MSG_SERVICE_PROTOCOL</NAME>
#define MSG_SERVICE_PROTOCOL  4
</MACRO>
<MACRO>
<NAME>MSG_WEBSERVICE_URL</NAME>
#define MSG_WEBSERVICE_URL         0
</MACRO>
<MACRO>
<NAME>MSG_WEBSERVICE_CGI</NAME>
#define MSG_WEBSERVICE_CGI         1
</MACRO>
<MACRO>
<NAME>MSG_WEBSERVICE_HTTP_METHOD</NAME>
#define MSG_WEBSERVICE_HTTP_METHOD 2
</MACRO>
<MACRO>
<NAME>MSG_WEBSERVICE_ARG</NAME>
#define MSG_WEBSERVICE_ARG         3
</MACRO>
<MACRO>
<NAME>MSG_SNMPSERVICE_OID</NAME>
#define MSG_SNMPSERVICE_OID       0
</MACRO>
<MACRO>
<NAME>MSG_SNMPSERVICE_COMMUNITY</NAME>
#define MSG_SNMPSERVICE_COMMUNITY 1
</MACRO>
<MACRO>
<NAME>MSG_SNMPSERVICE_COMMAND</NAME>
#define MSG_SNMPSERVICE_COMMAND   2
</MACRO>
<MACRO>
<NAME>MSG_CLASSIFICATION_ORIGIN</NAME>
#define MSG_CLASSIFICATION_ORIGIN 0
</MACRO>
<MACRO>
<NAME>MSG_CLASSIFICATION_NAME</NAME>
#define MSG_CLASSIFICATION_NAME   1
</MACRO>
<MACRO>
<NAME>MSG_CLASSIFICATION_URL</NAME>
#define MSG_CLASSIFICATION_URL    2
</MACRO>
<MACRO>
<NAME>MSG_ADDITIONALDATA_TYPE</NAME>
#define MSG_ADDITIONALDATA_TYPE    0
</MACRO>
<MACRO>
<NAME>MSG_ADDITIONALDATA_MEANING</NAME>
#define MSG_ADDITIONALDATA_MEANING 1
</MACRO>
<MACRO>
<NAME>MSG_ADDITIONALDATA_DATA</NAME>
#define MSG_ADDITIONALDATA_DATA    2
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_ID</NAME>
#define MSG_ANALYZER_ID            0
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_MANUFACTURER</NAME>
#define MSG_ANALYZER_MANUFACTURER  1
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_MODEL</NAME>
#define MSG_ANALYZER_MODEL         2
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_VERSION</NAME>
#define MSG_ANALYZER_VERSION       3
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_CLASS</NAME>
#define MSG_ANALYZER_CLASS         4
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_OSTYPE</NAME>
#define MSG_ANALYZER_OSTYPE        6
</MACRO>
<MACRO>
<NAME>MSG_ANALYZER_OSVERSION</NAME>
#define MSG_ANALYZER_OSVERSION     7
</MACRO>
<MACRO>
<NAME>MSG_TARGET_IDENT</NAME>
#define MSG_TARGET_IDENT           0
</MACRO>
<MACRO>
<NAME>MSG_TARGET_DECOY</NAME>
#define MSG_TARGET_DECOY           1
</MACRO>
<MACRO>
<NAME>MSG_TARGET_INTERFACE</NAME>
#define MSG_TARGET_INTERFACE       2
</MACRO>
<MACRO>
<NAME>MSG_HEARTBEAT_IDENT</NAME>
#define MSG_HEARTBEAT_IDENT        0
</MACRO>
<MACRO>
<NAME>MSG_TOOL_ALERT_NAME</NAME>
#define MSG_TOOL_ALERT_NAME        0
</MACRO>
<MACRO>
<NAME>MSG_TOOL_ALERT_COMMAND</NAME>
#define MSG_TOOL_ALERT_COMMAND     1
</MACRO>
<MACRO>
<NAME>MSG_TOOL_ALERT_ANALYZER_ID</NAME>
#define MSG_TOOL_ALERT_ANALYZER_ID 2
</MACRO>
<MACRO>
<NAME>MSG_CORRELATION_ALERT_NAME</NAME>
#define MSG_CORRELATION_ALERT_NAME  0 
</MACRO>
<MACRO>
<NAME>MSG_CORRELATION_ALERT_IDENT</NAME>
#define MSG_CORRELATION_ALERT_IDENT 1
</MACRO>
<MACRO>
<NAME>MSG_OVERFLOW_ALERT_PROGRAM</NAME>
#define MSG_OVERFLOW_ALERT_PROGRAM 0
</MACRO>
<MACRO>
<NAME>MSG_OVERFLOW_ALERT_SIZE</NAME>
#define MSG_OVERFLOW_ALERT_SIZE    1
</MACRO>
<MACRO>
<NAME>MSG_OVERFLOW_ALERT_BUFFER</NAME>
#define MSG_OVERFLOW_ALERT_BUFFER  2
</MACRO>
<MACRO>
<NAME>MSG_TIME_SEC</NAME>
#define MSG_TIME_SEC  0
</MACRO>
<MACRO>
<NAME>MSG_TIME_USEC</NAME>
#define MSG_TIME_USEC 1
</MACRO>
<MACRO>
<NAME>MSG_ALERTIDENT_IDENT</NAME>
#define MSG_ALERTIDENT_IDENT           0
</MACRO>
<MACRO>
<NAME>MSG_ALERTIDENT_ANALYZER_IDENT</NAME>
#define MSG_ALERTIDENT_ANALYZER_IDENT  1
</MACRO>
<FUNCTION>
<NAME>prelude_daemonize</NAME>
<RETURNS>int  </RETURNS>
const char *lockfile
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_ident_send</NAME>
<RETURNS>int  </RETURNS>
prelude_io_t *fd
</FUNCTION>
<FUNCTION>
<NAME>prelude_client_ident_init</NAME>
<RETURNS>int  </RETURNS>
const char *sname
</FUNCTION>
