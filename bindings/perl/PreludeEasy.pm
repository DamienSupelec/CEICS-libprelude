# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package PreludeEasy;
use base qw(Exporter);
use base qw(DynaLoader);
package PreludeEasyc;
bootstrap PreludeEasy;
package PreludeEasy;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package PreludeEasy;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package PreludeEasy;

*CheckVersion = *PreludeEasyc::CheckVersion;

############# Class : PreludeEasy::ClientProfile ##############

package PreludeEasy::ClientProfile;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_ClientProfile(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_ClientProfile($self);
        delete $OWNER{$self};
    }
}

*GetUid = *PreludeEasyc::ClientProfile_GetUid;
*GetGid = *PreludeEasyc::ClientProfile_GetGid;
*GetName = *PreludeEasyc::ClientProfile_GetName;
*SetName = *PreludeEasyc::ClientProfile_SetName;
*GetAnalyzerId = *PreludeEasyc::ClientProfile_GetAnalyzerId;
*GetConfigFilename = *PreludeEasyc::ClientProfile_GetConfigFilename;
*GetAnalyzeridFilename = *PreludeEasyc::ClientProfile_GetAnalyzeridFilename;
*GetTlsKeyFilename = *PreludeEasyc::ClientProfile_GetTlsKeyFilename;
*GetTlsServerCaCertFilename = *PreludeEasyc::ClientProfile_GetTlsServerCaCertFilename;
*GetTlsServerKeyCertFilename = *PreludeEasyc::ClientProfile_GetTlsServerKeyCertFilename;
*GetTlsServerCrlFilename = *PreludeEasyc::ClientProfile_GetTlsServerCrlFilename;
*GetTlsClientKeyCertFilename = *PreludeEasyc::ClientProfile_GetTlsClientKeyCertFilename;
*GetTlsClientTrustedCertFilename = *PreludeEasyc::ClientProfile_GetTlsClientTrustedCertFilename;
*GetBackupDirname = *PreludeEasyc::ClientProfile_GetBackupDirname;
*GetProfileDirname = *PreludeEasyc::ClientProfile_GetProfileDirname;
*SetPrefix = *PreludeEasyc::ClientProfile_SetPrefix;
*GetPrefix = *PreludeEasyc::ClientProfile_GetPrefix;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::Connection ##############

package PreludeEasy::Connection;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_Connection($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_Connection(@_);
    bless $self, $pkg if defined($self);
}

*GetConnection = *PreludeEasyc::Connection_GetConnection;
*Close = *PreludeEasyc::Connection_Close;
*Connect = *PreludeEasyc::Connection_Connect;
*SetState = *PreludeEasyc::Connection_SetState;
*GetState = *PreludeEasyc::Connection_GetState;
*SetData = *PreludeEasyc::Connection_SetData;
*GetData = *PreludeEasyc::Connection_GetData;
*GetPermission = *PreludeEasyc::Connection_GetPermission;
*SetPeerAnalyzerid = *PreludeEasyc::Connection_SetPeerAnalyzerid;
*GetPeerAnalyzerid = *PreludeEasyc::Connection_GetPeerAnalyzerid;
*GetLocalAddr = *PreludeEasyc::Connection_GetLocalAddr;
*GetLocalPort = *PreludeEasyc::Connection_GetLocalPort;
*GetPeerAddr = *PreludeEasyc::Connection_GetPeerAddr;
*GetPeerPort = *PreludeEasyc::Connection_GetPeerPort;
*IsAlive = *PreludeEasyc::Connection_IsAlive;
*GetFd = *PreludeEasyc::Connection_GetFd;
*RecvIDMEF = *PreludeEasyc::Connection_RecvIDMEF;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::ConnectionPool ##############

package PreludeEasy::ConnectionPool;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_ConnectionPool($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_ConnectionPool(@_);
    bless $self, $pkg if defined($self);
}

*Init = *PreludeEasyc::ConnectionPool_Init;
*SetConnectionString = *PreludeEasyc::ConnectionPool_SetConnectionString;
*GetConnectionString = *PreludeEasyc::ConnectionPool_GetConnectionString;
*GetConnectionList = *PreludeEasyc::ConnectionPool_GetConnectionList;
*SetFlags = *PreludeEasyc::ConnectionPool_SetFlags;
*GetFlags = *PreludeEasyc::ConnectionPool_GetFlags;
*SetData = *PreludeEasyc::ConnectionPool_SetData;
*GetData = *PreludeEasyc::ConnectionPool_GetData;
*AddConnection = *PreludeEasyc::ConnectionPool_AddConnection;
*DelConnection = *PreludeEasyc::ConnectionPool_DelConnection;
*SetConnectionAlive = *PreludeEasyc::ConnectionPool_SetConnectionAlive;
*SetConnectionDead = *PreludeEasyc::ConnectionPool_SetConnectionDead;
*SetRequiredPermission = *PreludeEasyc::ConnectionPool_SetRequiredPermission;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::Client ##############

package PreludeEasy::Client;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy::ClientProfile PreludeEasy );
%OWNER = ();
%ITERATORS = ();
*ASYNC_SEND = *PreludeEasyc::Client_ASYNC_SEND;
*FLAGS_ASYNC_SEND = *PreludeEasyc::Client_FLAGS_ASYNC_SEND;
*ASYNC_TIMER = *PreludeEasyc::Client_ASYNC_TIMER;
*FLAGS_ASYNC_TIMER = *PreludeEasyc::Client_FLAGS_ASYNC_TIMER;
*HEARTBEAT = *PreludeEasyc::Client_HEARTBEAT;
*FLAGS_HEARTBEAT = *PreludeEasyc::Client_FLAGS_HEARTBEAT;
*CONNECT = *PreludeEasyc::Client_CONNECT;
*FLAGS_CONNECT = *PreludeEasyc::Client_FLAGS_CONNECT;
*AUTOCONFIG = *PreludeEasyc::Client_AUTOCONFIG;
*FLAGS_AUTOCONFIG = *PreludeEasyc::Client_FLAGS_AUTOCONFIG;
*IDMEF_READ = *PreludeEasyc::Client_IDMEF_READ;
*PERMISSION_IDMEF_READ = *PreludeEasyc::Client_PERMISSION_IDMEF_READ;
*ADMIN_READ = *PreludeEasyc::Client_ADMIN_READ;
*PERMISSION_ADMIN_READ = *PreludeEasyc::Client_PERMISSION_ADMIN_READ;
*IDMEF_WRITE = *PreludeEasyc::Client_IDMEF_WRITE;
*PERMISSION_IDMEF_WRITE = *PreludeEasyc::Client_PERMISSION_IDMEF_WRITE;
*ADMIN_WRITE = *PreludeEasyc::Client_ADMIN_WRITE;
*PERMISSION_ADMIN_WRITE = *PreludeEasyc::Client_PERMISSION_ADMIN_WRITE;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_Client($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_Client(@_);
    bless $self, $pkg if defined($self);
}

*Start = *PreludeEasyc::Client_Start;
*Init = *PreludeEasyc::Client_Init;
*GetClient = *PreludeEasyc::Client_GetClient;
*SendIDMEF = *PreludeEasyc::Client_SendIDMEF;
*RecvIDMEF = *PreludeEasyc::Client_RecvIDMEF;
*GetFlags = *PreludeEasyc::Client_GetFlags;
*SetFlags = *PreludeEasyc::Client_SetFlags;
*GetRequiredPermission = *PreludeEasyc::Client_GetRequiredPermission;
*SetRequiredPermission = *PreludeEasyc::Client_SetRequiredPermission;
*GetConfigFilename = *PreludeEasyc::Client_GetConfigFilename;
*SetConfigFilename = *PreludeEasyc::Client_SetConfigFilename;
*GetConnectionPool = *PreludeEasyc::Client_GetConnectionPool;
*SetConnectionPool = *PreludeEasyc::Client_SetConnectionPool;
*__lshift__ = *PreludeEasyc::Client___lshift__;
*__rshift__ = *PreludeEasyc::Client___rshift__;
*SetRecvTimeout = *PreludeEasyc::Client_SetRecvTimeout;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::PreludeLog ##############

package PreludeEasy::PreludeLog;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
*DEBUG = *PreludeEasyc::PreludeLog_DEBUG;
*INFO = *PreludeEasyc::PreludeLog_INFO;
*WARNING = *PreludeEasyc::PreludeLog_WARNING;
*ERROR = *PreludeEasyc::PreludeLog_ERROR;
*CRITICAL = *PreludeEasyc::PreludeLog_CRITICAL;
*QUIET = *PreludeEasyc::PreludeLog_QUIET;
*SYSLOG = *PreludeEasyc::PreludeLog_SYSLOG;
*SetLevel = *PreludeEasyc::PreludeLog_SetLevel;
*SetDebugLevel = *PreludeEasyc::PreludeLog_SetDebugLevel;
*SetFlags = *PreludeEasyc::PreludeLog_SetFlags;
*GetFlags = *PreludeEasyc::PreludeLog_GetFlags;
*SetLogfile = *PreludeEasyc::PreludeLog_SetLogfile;
*SetCallback = *PreludeEasyc::PreludeLog_SetCallback;
sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_PreludeLog(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_PreludeLog($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::PreludeError ##############

package PreludeEasy::PreludeError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_PreludeError($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_PreludeError(@_);
    bless $self, $pkg if defined($self);
}

*GetCode = *PreludeEasyc::PreludeError_GetCode;
*what = *PreludeEasyc::PreludeError_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::ClientEasy ##############

package PreludeEasy::ClientEasy;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy::Client PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_ClientEasy(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_ClientEasy($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::IDMEFCriterion ##############

package PreludeEasy::IDMEFCriterion;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
*OPERATOR_NOT = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT;
*OPERATOR_NOCASE = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOCASE;
*OPERATOR_EQUAL = *PreludeEasyc::IDMEFCriterion_OPERATOR_EQUAL;
*OPERATOR_EQUAL_NOCASE = *PreludeEasyc::IDMEFCriterion_OPERATOR_EQUAL_NOCASE;
*OPERATOR_NOT_EQUAL = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT_EQUAL;
*OPERATOR_NOT_EQUAL_NOCASE = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT_EQUAL_NOCASE;
*OPERATOR_LESSER = *PreludeEasyc::IDMEFCriterion_OPERATOR_LESSER;
*OPERATOR_LESSER_OR_EQUAL = *PreludeEasyc::IDMEFCriterion_OPERATOR_LESSER_OR_EQUAL;
*OPERATOR_GREATER = *PreludeEasyc::IDMEFCriterion_OPERATOR_GREATER;
*OPERATOR_GREATER_OR_EQUAL = *PreludeEasyc::IDMEFCriterion_OPERATOR_GREATER_OR_EQUAL;
*OPERATOR_SUBSTR = *PreludeEasyc::IDMEFCriterion_OPERATOR_SUBSTR;
*OPERATOR_SUBSTR_NOCASE = *PreludeEasyc::IDMEFCriterion_OPERATOR_SUBSTR_NOCASE;
*OPERATOR_NOT_SUBSTR = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT_SUBSTR;
*OPERATOR_NOT_SUBSTR_NOCASE = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT_SUBSTR_NOCASE;
*OPERATOR_REGEX = *PreludeEasyc::IDMEFCriterion_OPERATOR_REGEX;
*OPERATOR_REGEX_NOCASE = *PreludeEasyc::IDMEFCriterion_OPERATOR_REGEX_NOCASE;
*OPERATOR_NOT_REGEX = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT_REGEX;
*OPERATOR_NOT_REGEX_NOCASE = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT_REGEX_NOCASE;
*OPERATOR_NULL = *PreludeEasyc::IDMEFCriterion_OPERATOR_NULL;
*OPERATOR_NOT_NULL = *PreludeEasyc::IDMEFCriterion_OPERATOR_NOT_NULL;
sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_IDMEFCriterion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_IDMEFCriterion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::IDMEFCriteria ##############

package PreludeEasy::IDMEFCriteria;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_IDMEFCriteria($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_IDMEFCriteria(@_);
    bless $self, $pkg if defined($self);
}

*Match = *PreludeEasyc::IDMEFCriteria_Match;
*Clone = *PreludeEasyc::IDMEFCriteria_Clone;
*ANDCriteria = *PreludeEasyc::IDMEFCriteria_ANDCriteria;
*ORCriteria = *PreludeEasyc::IDMEFCriteria_ORCriteria;
*ToString = *PreludeEasyc::IDMEFCriteria_ToString;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::IDMEFValue ##############

package PreludeEasy::IDMEFValue;
use overload
    "<=" => sub { $_[0]->__le__($_[1])},
    ">=" => sub { $_[0]->__ge__($_[1])},
    "<" => sub { $_[0]->__lt__($_[1])},
    "!=" => sub { $_[0]->__ne__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    ">" => sub { $_[0]->__gt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
*TYPE_UNKNOWN = *PreludeEasyc::IDMEFValue_TYPE_UNKNOWN;
*TYPE_INT8 = *PreludeEasyc::IDMEFValue_TYPE_INT8;
*TYPE_UINT8 = *PreludeEasyc::IDMEFValue_TYPE_UINT8;
*TYPE_INT16 = *PreludeEasyc::IDMEFValue_TYPE_INT16;
*TYPE_UINT16 = *PreludeEasyc::IDMEFValue_TYPE_UINT16;
*TYPE_INT32 = *PreludeEasyc::IDMEFValue_TYPE_INT32;
*TYPE_UINT32 = *PreludeEasyc::IDMEFValue_TYPE_UINT32;
*TYPE_INT64 = *PreludeEasyc::IDMEFValue_TYPE_INT64;
*TYPE_UINT64 = *PreludeEasyc::IDMEFValue_TYPE_UINT64;
*TYPE_FLOAT = *PreludeEasyc::IDMEFValue_TYPE_FLOAT;
*TYPE_DOUBLE = *PreludeEasyc::IDMEFValue_TYPE_DOUBLE;
*TYPE_STRING = *PreludeEasyc::IDMEFValue_TYPE_STRING;
*TYPE_TIME = *PreludeEasyc::IDMEFValue_TYPE_TIME;
*TYPE_DATA = *PreludeEasyc::IDMEFValue_TYPE_DATA;
*TYPE_ENUM = *PreludeEasyc::IDMEFValue_TYPE_ENUM;
*TYPE_LIST = *PreludeEasyc::IDMEFValue_TYPE_LIST;
*TYPE_CLASS = *PreludeEasyc::IDMEFValue_TYPE_CLASS;
*GetType = *PreludeEasyc::IDMEFValue_GetType;
*IsNull = *PreludeEasyc::IDMEFValue_IsNull;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_IDMEFValue($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_IDMEFValue(@_);
    bless $self, $pkg if defined($self);
}

*Match = *PreludeEasyc::IDMEFValue_Match;
*Clone = *PreludeEasyc::IDMEFValue_Clone;
*ToString = *PreludeEasyc::IDMEFValue_ToString;
*__le__ = *PreludeEasyc::IDMEFValue___le__;
*__ge__ = *PreludeEasyc::IDMEFValue___ge__;
*__lt__ = *PreludeEasyc::IDMEFValue___lt__;
*__gt__ = *PreludeEasyc::IDMEFValue___gt__;
*__eq__ = *PreludeEasyc::IDMEFValue___eq__;
*__ne__ = *PreludeEasyc::IDMEFValue___ne__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::IDMEFPath ##############

package PreludeEasy::IDMEFPath;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_IDMEFPath(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_IDMEFPath($self);
        delete $OWNER{$self};
    }
}

*Set = *PreludeEasyc::IDMEFPath_Set;
*GetClass = *PreludeEasyc::IDMEFPath_GetClass;
*GetValueType = *PreludeEasyc::IDMEFPath_GetValueType;
*SetIndex = *PreludeEasyc::IDMEFPath_SetIndex;
*UndefineIndex = *PreludeEasyc::IDMEFPath_UndefineIndex;
*GetIndex = *PreludeEasyc::IDMEFPath_GetIndex;
*MakeChild = *PreludeEasyc::IDMEFPath_MakeChild;
*MakeParent = *PreludeEasyc::IDMEFPath_MakeParent;
*Compare = *PreludeEasyc::IDMEFPath_Compare;
*Clone = *PreludeEasyc::IDMEFPath_Clone;
*CheckOperator = *PreludeEasyc::IDMEFPath_CheckOperator;
*GetApplicableOperators = *PreludeEasyc::IDMEFPath_GetApplicableOperators;
*GetName = *PreludeEasyc::IDMEFPath_GetName;
*IsAmbiguous = *PreludeEasyc::IDMEFPath_IsAmbiguous;
*HasLists = *PreludeEasyc::IDMEFPath_HasLists;
*IsList = *PreludeEasyc::IDMEFPath_IsList;
*GetDepth = *PreludeEasyc::IDMEFPath_GetDepth;
*Get = *PreludeEasyc::IDMEFPath_Get;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::IDMEFTime ##############

package PreludeEasy::IDMEFTime;
use overload
    "<=" => sub { $_[0]->__le__($_[1])},
    "!=" => sub { $_[0]->__ne__($_[1])},
    ">=" => sub { $_[0]->__ge__($_[1])},
    "<" => sub { $_[0]->__lt__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    ">" => sub { $_[0]->__gt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_IDMEFTime(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_IDMEFTime($self);
        delete $OWNER{$self};
    }
}

*Set = *PreludeEasyc::IDMEFTime_Set;
*SetSec = *PreludeEasyc::IDMEFTime_SetSec;
*SetUSec = *PreludeEasyc::IDMEFTime_SetUSec;
*SetGmtOffset = *PreludeEasyc::IDMEFTime_SetGmtOffset;
*GetSec = *PreludeEasyc::IDMEFTime_GetSec;
*GetUSec = *PreludeEasyc::IDMEFTime_GetUSec;
*GetGmtOffset = *PreludeEasyc::IDMEFTime_GetGmtOffset;
*Clone = *PreludeEasyc::IDMEFTime_Clone;
*ToString = *PreludeEasyc::IDMEFTime_ToString;
*__ne__ = *PreludeEasyc::IDMEFTime___ne__;
*__ge__ = *PreludeEasyc::IDMEFTime___ge__;
*__le__ = *PreludeEasyc::IDMEFTime___le__;
*__eq__ = *PreludeEasyc::IDMEFTime___eq__;
*__gt__ = *PreludeEasyc::IDMEFTime___gt__;
*__lt__ = *PreludeEasyc::IDMEFTime___lt__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : PreludeEasy::IDMEF ##############

package PreludeEasy::IDMEF;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( PreludeEasy );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        PreludeEasyc::delete_IDMEF($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = PreludeEasyc::new_IDMEF(@_);
    bless $self, $pkg if defined($self);
}

*Set = *PreludeEasyc::IDMEF_Set;
*Clone = *PreludeEasyc::IDMEF_Clone;
*ToString = *PreludeEasyc::IDMEF_ToString;
*Write = *PreludeEasyc::IDMEF_Write;
*Read = *PreludeEasyc::IDMEF_Read;
*Get = *PreludeEasyc::IDMEF_Get;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package PreludeEasy;

1;
