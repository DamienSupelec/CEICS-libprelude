
/*****
*
* Copyright (C) 2001-2004 Yoann Vandoorselaere <yoann@prelude-ids.org>
* Copyright (C) 2003,2004 Nicolas Delon <nicolas@prelude-ids.org>
* All Rights Reserved
*
* This file is part of the Prelude program.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; see the file COPYING.  If not, write to
* the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
*
*****/

/* Auto-generated by the GenerateIDMEFTreeWrapC package */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>

#include "prelude-inttypes.h"
#include "prelude-list.h"
#include "prelude-msg.h"
#include "prelude-string.h"

#include "idmef-time.h"
#include "idmef-data.h"
#include "idmef-type.h"
#include "idmef-value.h"

#include "idmef-tree-wrap.h"

#define LISTED_OBJECT(name, type) prelude_list_t name

#define IS_LISTED prelude_list_t list

#define	UNION(type, var) type var; union

#define	UNION_MEMBER(value, type, name) type name

#define ENUM(...) typedef enum

#define PRE_DECLARE(type, class)

#define TYPE_ID(type, id) type

#define PRIMITIVE_TYPE(type)
#define PRIMITIVE_TYPE_STRUCT(type)

#define HIDE(type, name) type name

#define REFCOUNT int refcount

#define DYNAMIC_IDENT(x) uint64_t x

#define OPTIONAL_INT(type, name) type name; int name ## _is_set:1


/**
 * idmef_additional_data_type_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_additional_data_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_additional_data_type_t idmef_additional_data_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "string" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_STRING;

	if ( strcasecmp(name, "boolean" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_BOOLEAN;

	if ( strcasecmp(name, "byte" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_BYTE;

	if ( strcasecmp(name, "character" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_CHARACTER;

	if ( strcasecmp(name, "date-time" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_DATE_TIME;

	if ( strcasecmp(name, "integer" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_INTEGER;

	if ( strcasecmp(name, "ntpstamp" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_NTPSTAMP;

	if ( strcasecmp(name, "portlist" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_PORTLIST;

	if ( strcasecmp(name, "real" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_REAL;

	if ( strcasecmp(name, "xml" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_XML;


	return -1;
}	

/**
 * idmef_additional_data_type_to_string:
 * @val: an enumeration value for #idmef_additional_data_type_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_additional_data_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_additional_data_type_to_string(idmef_additional_data_type_t val)
{
	switch ( val ) {

		case IDMEF_ADDITIONAL_DATA_TYPE_STRING:
			return "string";

		case IDMEF_ADDITIONAL_DATA_TYPE_BOOLEAN:
			return "boolean";

		case IDMEF_ADDITIONAL_DATA_TYPE_BYTE:
			return "byte";

		case IDMEF_ADDITIONAL_DATA_TYPE_CHARACTER:
			return "character";

		case IDMEF_ADDITIONAL_DATA_TYPE_DATE_TIME:
			return "date-time";

		case IDMEF_ADDITIONAL_DATA_TYPE_INTEGER:
			return "integer";

		case IDMEF_ADDITIONAL_DATA_TYPE_NTPSTAMP:
			return "ntpstamp";

		case IDMEF_ADDITIONAL_DATA_TYPE_PORTLIST:
			return "portlist";

		case IDMEF_ADDITIONAL_DATA_TYPE_REAL:
			return "real";

		case IDMEF_ADDITIONAL_DATA_TYPE_XML:
			return "xml";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_additional_data { 
         IS_LISTED;
  REFCOUNT;
         idmef_additional_data_type_t type;
         prelude_string_t *meaning;
  idmef_data_t data;
 
};


/**
 * idmef_reference_origin_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_reference_origin_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_reference_origin_t idmef_reference_origin_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_REFERENCE_ORIGIN_UNKNOWN;

	if ( strcasecmp(name, "vendor-specific" ) == 0)
		return IDMEF_REFERENCE_ORIGIN_VENDOR_SPECIFIC;

	if ( strcasecmp(name, "user-specific" ) == 0)
		return IDMEF_REFERENCE_ORIGIN_USER_SPECIFIC;

	if ( strcasecmp(name, "bugtraqid" ) == 0)
		return IDMEF_REFERENCE_ORIGIN_BUGTRAQID;

	if ( strcasecmp(name, "cve" ) == 0)
		return IDMEF_REFERENCE_ORIGIN_CVE;

	if ( strcasecmp(name, "osvdb" ) == 0)
		return IDMEF_REFERENCE_ORIGIN_OSVDB;


	return -1;
}	

/**
 * idmef_reference_origin_to_string:
 * @val: an enumeration value for #idmef_reference_origin_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_reference_origin_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_reference_origin_to_string(idmef_reference_origin_t val)
{
	switch ( val ) {

		case IDMEF_REFERENCE_ORIGIN_UNKNOWN:
			return "unknown";

		case IDMEF_REFERENCE_ORIGIN_VENDOR_SPECIFIC:
			return "vendor-specific";

		case IDMEF_REFERENCE_ORIGIN_USER_SPECIFIC:
			return "user-specific";

		case IDMEF_REFERENCE_ORIGIN_BUGTRAQID:
			return "bugtraqid";

		case IDMEF_REFERENCE_ORIGIN_CVE:
			return "cve";

		case IDMEF_REFERENCE_ORIGIN_OSVDB:
			return "osvdb";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_reference { 
         IS_LISTED;
         REFCOUNT;
         idmef_reference_origin_t origin;
 
         prelude_string_t name;
         prelude_string_t url;
         prelude_string_t *meaning;
 
};



struct idmef_classification { 
         REFCOUNT;
 
         uint64_t ident;
         prelude_string_t text;
         LISTED_OBJECT(reference_list, idmef_reference_t);
 
 
};


/**
 * idmef_user_id_type_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_user_id_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_user_id_type_t idmef_user_id_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "original-user" ) == 0)
		return IDMEF_USER_ID_TYPE_ORIGINAL_USER;

	if ( strcasecmp(name, "current-user" ) == 0)
		return IDMEF_USER_ID_TYPE_CURRENT_USER;

	if ( strcasecmp(name, "target-user" ) == 0)
		return IDMEF_USER_ID_TYPE_TARGET_USER;

	if ( strcasecmp(name, "user-privs" ) == 0)
		return IDMEF_USER_ID_TYPE_USER_PRIVS;

	if ( strcasecmp(name, "current-group" ) == 0)
		return IDMEF_USER_ID_TYPE_CURRENT_GROUP;

	if ( strcasecmp(name, "group-privs" ) == 0)
		return IDMEF_USER_ID_TYPE_GROUP_PRIVS;

	if ( strcasecmp(name, "other-privs" ) == 0)
		return IDMEF_USER_ID_TYPE_OTHER_PRIVS;


	return -1;
}	

/**
 * idmef_user_id_type_to_string:
 * @val: an enumeration value for #idmef_user_id_type_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_user_id_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_user_id_type_to_string(idmef_user_id_type_t val)
{
	switch ( val ) {

		case IDMEF_USER_ID_TYPE_ORIGINAL_USER:
			return "original-user";

		case IDMEF_USER_ID_TYPE_CURRENT_USER:
			return "current-user";

		case IDMEF_USER_ID_TYPE_TARGET_USER:
			return "target-user";

		case IDMEF_USER_ID_TYPE_USER_PRIVS:
			return "user-privs";

		case IDMEF_USER_ID_TYPE_CURRENT_GROUP:
			return "current-group";

		case IDMEF_USER_ID_TYPE_GROUP_PRIVS:
			return "group-privs";

		case IDMEF_USER_ID_TYPE_OTHER_PRIVS:
			return "other-privs";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_user_id { 
         IS_LISTED;
  REFCOUNT;
         uint64_t ident;
         prelude_string_t *name;
         idmef_user_id_type_t type;
         OPTIONAL_INT(uint32_t, number);
 
};


/**
 * idmef_user_category_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_user_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_user_category_t idmef_user_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_USER_CATEGORY_UNKNOWN;

	if ( strcasecmp(name, "application" ) == 0)
		return IDMEF_USER_CATEGORY_APPLICATION;

	if ( strcasecmp(name, "os-device" ) == 0)
		return IDMEF_USER_CATEGORY_OS_DEVICE;


	return -1;
}	

/**
 * idmef_user_category_to_string:
 * @val: an enumeration value for #idmef_user_category_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_user_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_user_category_to_string(idmef_user_category_t val)
{
	switch ( val ) {

		case IDMEF_USER_CATEGORY_UNKNOWN:
			return "unknown";

		case IDMEF_USER_CATEGORY_APPLICATION:
			return "application";

		case IDMEF_USER_CATEGORY_OS_DEVICE:
			return "os-device";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_user { 
  REFCOUNT;
         uint64_t ident;
         idmef_user_category_t category;
         LISTED_OBJECT(user_id_list, idmef_user_id_t);
 
};


/**
 * idmef_address_category_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_address_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_address_category_t idmef_address_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_UNKNOWN;

	if ( strcasecmp(name, "atm" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_ATM;

	if ( strcasecmp(name, "e-mail" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_E_MAIL;

	if ( strcasecmp(name, "lotus-notes" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_LOTUS_NOTES;

	if ( strcasecmp(name, "mac" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_MAC;

	if ( strcasecmp(name, "sna" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_SNA;

	if ( strcasecmp(name, "vm" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_VM;

	if ( strcasecmp(name, "ipv4-addr" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_ADDR;

	if ( strcasecmp(name, "ipv4-addr-hex" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_ADDR_HEX;

	if ( strcasecmp(name, "ipv4-net" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_NET;

	if ( strcasecmp(name, "ipv4-net-mask" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_NET_MASK;

	if ( strcasecmp(name, "ipv6-addr" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_ADDR;

	if ( strcasecmp(name, "ipv6-addr-hex" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_ADDR_HEX;

	if ( strcasecmp(name, "ipv6-net" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_NET;

	if ( strcasecmp(name, "ipv6-net-mask" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_NET_MASK;


	return -1;
}	

/**
 * idmef_address_category_to_string:
 * @val: an enumeration value for #idmef_address_category_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_address_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_address_category_to_string(idmef_address_category_t val)
{
	switch ( val ) {

		case IDMEF_ADDRESS_CATEGORY_UNKNOWN:
			return "unknown";

		case IDMEF_ADDRESS_CATEGORY_ATM:
			return "atm";

		case IDMEF_ADDRESS_CATEGORY_E_MAIL:
			return "e-mail";

		case IDMEF_ADDRESS_CATEGORY_LOTUS_NOTES:
			return "lotus-notes";

		case IDMEF_ADDRESS_CATEGORY_MAC:
			return "mac";

		case IDMEF_ADDRESS_CATEGORY_SNA:
			return "sna";

		case IDMEF_ADDRESS_CATEGORY_VM:
			return "vm";

		case IDMEF_ADDRESS_CATEGORY_IPV4_ADDR:
			return "ipv4-addr";

		case IDMEF_ADDRESS_CATEGORY_IPV4_ADDR_HEX:
			return "ipv4-addr-hex";

		case IDMEF_ADDRESS_CATEGORY_IPV4_NET:
			return "ipv4-net";

		case IDMEF_ADDRESS_CATEGORY_IPV4_NET_MASK:
			return "ipv4-net-mask";

		case IDMEF_ADDRESS_CATEGORY_IPV6_ADDR:
			return "ipv6-addr";

		case IDMEF_ADDRESS_CATEGORY_IPV6_ADDR_HEX:
			return "ipv6-addr-hex";

		case IDMEF_ADDRESS_CATEGORY_IPV6_NET:
			return "ipv6-net";

		case IDMEF_ADDRESS_CATEGORY_IPV6_NET_MASK:
			return "ipv6-net-mask";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_address { 
         IS_LISTED;
         REFCOUNT;
         uint64_t ident;
         idmef_address_category_t category;
         prelude_string_t *vlan_name;
         OPTIONAL_INT(int32_t, vlan_num);
         prelude_string_t address;
         prelude_string_t *netmask;
 
};



struct idmef_process { 
  REFCOUNT;
         uint64_t ident;
         prelude_string_t name;
         OPTIONAL_INT(uint32_t, pid);
         prelude_string_t *path;
 
         LISTED_OBJECT(arg_list, prelude_string_t);
         LISTED_OBJECT(env_list, prelude_string_t);
 
};



struct idmef_web_service { 
  REFCOUNT;
         prelude_string_t url;
         prelude_string_t *cgi;
         prelude_string_t *http_method;
         LISTED_OBJECT(arg_list, prelude_string_t);
 
};



struct idmef_snmp_service { 
  REFCOUNT;
         prelude_string_t *oid;
         prelude_string_t *community;
         prelude_string_t *security_name;
         prelude_string_t *context_name;
         prelude_string_t *context_engine_id;
         prelude_string_t *command;
 
};


/**
 * idmef_service_type_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_service_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_service_type_t idmef_service_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "default" ) == 0)
		return IDMEF_SERVICE_TYPE_DEFAULT;

	if ( strcasecmp(name, "web" ) == 0)
		return IDMEF_SERVICE_TYPE_WEB;

	if ( strcasecmp(name, "snmp" ) == 0)
		return IDMEF_SERVICE_TYPE_SNMP;


	return -1;
}	

/**
 * idmef_service_type_to_string:
 * @val: an enumeration value for #idmef_service_type_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_service_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_service_type_to_string(idmef_service_type_t val)
{
	switch ( val ) {

		case IDMEF_SERVICE_TYPE_DEFAULT:
			return "default";

		case IDMEF_SERVICE_TYPE_WEB:
			return "web";

		case IDMEF_SERVICE_TYPE_SNMP:
			return "snmp";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_service { 
  REFCOUNT;
         uint64_t ident;
         OPTIONAL_INT(uint8_t, ip_version);
 
         prelude_string_t *name;
         OPTIONAL_INT(uint16_t, port);
 
         OPTIONAL_INT(uint8_t, iana_protocol_number);
         prelude_string_t *iana_protocol_name;
 
         prelude_string_t *portlist;
         prelude_string_t *protocol;
 
  UNION(idmef_service_type_t, type) {
   UNION_MEMBER(IDMEF_SERVICE_TYPE_WEB, idmef_web_service_t, *web_service);
   UNION_MEMBER(IDMEF_SERVICE_TYPE_SNMP, idmef_snmp_service_t, *snmp_service);
  } specific;
 
 
};


/**
 * idmef_node_category_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_node_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_node_category_t idmef_node_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_NODE_CATEGORY_UNKNOWN;

	if ( strcasecmp(name, "ads" ) == 0)
		return IDMEF_NODE_CATEGORY_ADS;

	if ( strcasecmp(name, "afs" ) == 0)
		return IDMEF_NODE_CATEGORY_AFS;

	if ( strcasecmp(name, "coda" ) == 0)
		return IDMEF_NODE_CATEGORY_CODA;

	if ( strcasecmp(name, "dfs" ) == 0)
		return IDMEF_NODE_CATEGORY_DFS;

	if ( strcasecmp(name, "dns" ) == 0)
		return IDMEF_NODE_CATEGORY_DNS;

	if ( strcasecmp(name, "hosts" ) == 0)
		return IDMEF_NODE_CATEGORY_HOSTS;

	if ( strcasecmp(name, "kerberos" ) == 0)
		return IDMEF_NODE_CATEGORY_KERBEROS;

	if ( strcasecmp(name, "nds" ) == 0)
		return IDMEF_NODE_CATEGORY_NDS;

	if ( strcasecmp(name, "nis" ) == 0)
		return IDMEF_NODE_CATEGORY_NIS;

	if ( strcasecmp(name, "nisplus" ) == 0)
		return IDMEF_NODE_CATEGORY_NISPLUS;

	if ( strcasecmp(name, "nt" ) == 0)
		return IDMEF_NODE_CATEGORY_NT;

	if ( strcasecmp(name, "wfw" ) == 0)
		return IDMEF_NODE_CATEGORY_WFW;


	return -1;
}	

/**
 * idmef_node_category_to_string:
 * @val: an enumeration value for #idmef_node_category_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_node_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_node_category_to_string(idmef_node_category_t val)
{
	switch ( val ) {

		case IDMEF_NODE_CATEGORY_UNKNOWN:
			return "unknown";

		case IDMEF_NODE_CATEGORY_ADS:
			return "ads";

		case IDMEF_NODE_CATEGORY_AFS:
			return "afs";

		case IDMEF_NODE_CATEGORY_CODA:
			return "coda";

		case IDMEF_NODE_CATEGORY_DFS:
			return "dfs";

		case IDMEF_NODE_CATEGORY_DNS:
			return "dns";

		case IDMEF_NODE_CATEGORY_HOSTS:
			return "hosts";

		case IDMEF_NODE_CATEGORY_KERBEROS:
			return "kerberos";

		case IDMEF_NODE_CATEGORY_NDS:
			return "nds";

		case IDMEF_NODE_CATEGORY_NIS:
			return "nis";

		case IDMEF_NODE_CATEGORY_NISPLUS:
			return "nisplus";

		case IDMEF_NODE_CATEGORY_NT:
			return "nt";

		case IDMEF_NODE_CATEGORY_WFW:
			return "wfw";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_node { 
  REFCOUNT;
         uint64_t ident;
         idmef_node_category_t category;
         prelude_string_t *location;
         prelude_string_t *name;
         LISTED_OBJECT(address_list, idmef_address_t);
 
};


/**
 * idmef_source_spoofed_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_source_spoofed_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_source_spoofed_t idmef_source_spoofed_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_SOURCE_SPOOFED_UNKNOWN;

	if ( strcasecmp(name, "yes" ) == 0)
		return IDMEF_SOURCE_SPOOFED_YES;

	if ( strcasecmp(name, "no" ) == 0)
		return IDMEF_SOURCE_SPOOFED_NO;


	return -1;
}	

/**
 * idmef_source_spoofed_to_string:
 * @val: an enumeration value for #idmef_source_spoofed_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_source_spoofed_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_source_spoofed_to_string(idmef_source_spoofed_t val)
{
	switch ( val ) {

		case IDMEF_SOURCE_SPOOFED_UNKNOWN:
			return "unknown";

		case IDMEF_SOURCE_SPOOFED_YES:
			return "yes";

		case IDMEF_SOURCE_SPOOFED_NO:
			return "no";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_source { 
         IS_LISTED;
  REFCOUNT;
 
         uint64_t ident;
         idmef_source_spoofed_t spoofed;
         prelude_string_t *interface;
 
         idmef_node_t *node;
         idmef_user_t *user;
         idmef_process_t *process;
         idmef_service_t *service;
 
 
};



struct idmef_file_access { 
         IS_LISTED;
  REFCOUNT;
 
         idmef_user_id_t user_id;
  LISTED_OBJECT(permission_list, prelude_string_t);
 
};



struct idmef_inode { 
  REFCOUNT;
         idmef_time_t *change_time;
         OPTIONAL_INT(uint32_t, number);
         OPTIONAL_INT(uint32_t, major_device);
         OPTIONAL_INT(uint32_t, minor_device);
         OPTIONAL_INT(uint32_t, c_major_device);
         OPTIONAL_INT(uint32_t, c_minor_device);
 
};


/**
 * idmef_checksum_algorithm_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_checksum_algorithm_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_checksum_algorithm_t idmef_checksum_algorithm_to_numeric(const char *name)
{

	if ( strcasecmp(name, "md4" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_MD4;

	if ( strcasecmp(name, "md5" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_MD5;

	if ( strcasecmp(name, "sha1" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_SHA1;

	if ( strcasecmp(name, "sha2-256" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_SHA2_256;

	if ( strcasecmp(name, "sha2-384" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_SHA2_384;

	if ( strcasecmp(name, "sha2-512" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_SHA2_512;

	if ( strcasecmp(name, "crc-32" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_CRC_32;

	if ( strcasecmp(name, "haval" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_HAVAL;

	if ( strcasecmp(name, "tiger" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_TIGER;

	if ( strcasecmp(name, "gost" ) == 0)
		return IDMEF_CHECKSUM_ALGORITHM_GOST;


	return -1;
}	

/**
 * idmef_checksum_algorithm_to_string:
 * @val: an enumeration value for #idmef_checksum_algorithm_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_checksum_algorithm_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_checksum_algorithm_to_string(idmef_checksum_algorithm_t val)
{
	switch ( val ) {

		case 0:
			return NULL;

		case IDMEF_CHECKSUM_ALGORITHM_MD4:
			return "md4";

		case IDMEF_CHECKSUM_ALGORITHM_MD5:
			return "md5";

		case IDMEF_CHECKSUM_ALGORITHM_SHA1:
			return "sha1";

		case IDMEF_CHECKSUM_ALGORITHM_SHA2_256:
			return "sha2-256";

		case IDMEF_CHECKSUM_ALGORITHM_SHA2_384:
			return "sha2-384";

		case IDMEF_CHECKSUM_ALGORITHM_SHA2_512:
			return "sha2-512";

		case IDMEF_CHECKSUM_ALGORITHM_CRC_32:
			return "crc-32";

		case IDMEF_CHECKSUM_ALGORITHM_HAVAL:
			return "haval";

		case IDMEF_CHECKSUM_ALGORITHM_TIGER:
			return "tiger";

		case IDMEF_CHECKSUM_ALGORITHM_GOST:
			return "gost";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_checksum { 
  IS_LISTED;
         REFCOUNT;
         prelude_string_t value;
         prelude_string_t *key;
         idmef_checksum_algorithm_t algorithm;
 
};


/**
 * idmef_file_category_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_file_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_file_category_t idmef_file_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "current" ) == 0)
		return IDMEF_FILE_CATEGORY_CURRENT;

	if ( strcasecmp(name, "original" ) == 0)
		return IDMEF_FILE_CATEGORY_ORIGINAL;


	return -1;
}	

/**
 * idmef_file_category_to_string:
 * @val: an enumeration value for #idmef_file_category_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_file_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_file_category_to_string(idmef_file_category_t val)
{
	switch ( val ) {

		case 0:
			return NULL;

		case IDMEF_FILE_CATEGORY_CURRENT:
			return "current";

		case IDMEF_FILE_CATEGORY_ORIGINAL:
			return "original";

		default:
			return NULL;
	}

	return NULL;
}

/**
 * idmef_file_fstype_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_file_fstype_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_file_fstype_t idmef_file_fstype_to_numeric(const char *name)
{

	if ( strcasecmp(name, "ufs" ) == 0)
		return IDMEF_FILE_FSTYPE_UFS;

	if ( strcasecmp(name, "efs" ) == 0)
		return IDMEF_FILE_FSTYPE_EFS;

	if ( strcasecmp(name, "nfs" ) == 0)
		return IDMEF_FILE_FSTYPE_NFS;

	if ( strcasecmp(name, "afs" ) == 0)
		return IDMEF_FILE_FSTYPE_AFS;

	if ( strcasecmp(name, "ntfs" ) == 0)
		return IDMEF_FILE_FSTYPE_NTFS;

	if ( strcasecmp(name, "fat16" ) == 0)
		return IDMEF_FILE_FSTYPE_FAT16;

	if ( strcasecmp(name, "fat32" ) == 0)
		return IDMEF_FILE_FSTYPE_FAT32;

	if ( strcasecmp(name, "pcfs" ) == 0)
		return IDMEF_FILE_FSTYPE_PCFS;

	if ( strcasecmp(name, "joliet" ) == 0)
		return IDMEF_FILE_FSTYPE_JOLIET;

	if ( strcasecmp(name, "iso9660" ) == 0)
		return IDMEF_FILE_FSTYPE_ISO9660;


	return -1;
}	

/**
 * idmef_file_fstype_to_string:
 * @val: an enumeration value for #idmef_file_fstype_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_file_fstype_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_file_fstype_to_string(idmef_file_fstype_t val)
{
	switch ( val ) {

		case 0:
			return NULL;

		case IDMEF_FILE_FSTYPE_UFS:
			return "ufs";

		case IDMEF_FILE_FSTYPE_EFS:
			return "efs";

		case IDMEF_FILE_FSTYPE_NFS:
			return "nfs";

		case IDMEF_FILE_FSTYPE_AFS:
			return "afs";

		case IDMEF_FILE_FSTYPE_NTFS:
			return "ntfs";

		case IDMEF_FILE_FSTYPE_FAT16:
			return "fat16";

		case IDMEF_FILE_FSTYPE_FAT32:
			return "fat32";

		case IDMEF_FILE_FSTYPE_PCFS:
			return "pcfs";

		case IDMEF_FILE_FSTYPE_JOLIET:
			return "joliet";

		case IDMEF_FILE_FSTYPE_ISO9660:
			return "iso9660";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_file { 
         IS_LISTED;
  REFCOUNT;
         uint64_t ident;
 
         prelude_string_t name;
         prelude_string_t path;
 
         idmef_time_t *create_time;
         idmef_time_t *modify_time;
         idmef_time_t *access_time;
 
 
         OPTIONAL_INT(uint64_t, data_size);
         OPTIONAL_INT(uint64_t, disk_size);
 
         LISTED_OBJECT(file_access_list, idmef_file_access_t);
         LISTED_OBJECT(linkage_list, idmef_linkage_t);
 
         idmef_inode_t *inode;
  LISTED_OBJECT(checksum_list, idmef_checksum_t);
 
         idmef_file_category_t category;
         OPTIONAL_INT(idmef_file_fstype_t, fstype);
 
 
};


/**
 * idmef_linkage_category_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_linkage_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_linkage_category_t idmef_linkage_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "hard-link" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_HARD_LINK;

	if ( strcasecmp(name, "mount-point" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_MOUNT_POINT;

	if ( strcasecmp(name, "reparse-point" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_REPARSE_POINT;

	if ( strcasecmp(name, "shortcut" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_SHORTCUT;

	if ( strcasecmp(name, "stream" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_STREAM;

	if ( strcasecmp(name, "symbolic-link" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_SYMBOLIC_LINK;


	return -1;
}	

/**
 * idmef_linkage_category_to_string:
 * @val: an enumeration value for #idmef_linkage_category_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_linkage_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_linkage_category_to_string(idmef_linkage_category_t val)
{
	switch ( val ) {

		case 0:
			return NULL;

		case IDMEF_LINKAGE_CATEGORY_HARD_LINK:
			return "hard-link";

		case IDMEF_LINKAGE_CATEGORY_MOUNT_POINT:
			return "mount-point";

		case IDMEF_LINKAGE_CATEGORY_REPARSE_POINT:
			return "reparse-point";

		case IDMEF_LINKAGE_CATEGORY_SHORTCUT:
			return "shortcut";

		case IDMEF_LINKAGE_CATEGORY_STREAM:
			return "stream";

		case IDMEF_LINKAGE_CATEGORY_SYMBOLIC_LINK:
			return "symbolic-link";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_linkage { 
         IS_LISTED;
  REFCOUNT;
 
         idmef_linkage_category_t category;
         prelude_string_t name;
         prelude_string_t path;
         idmef_file_t *file;
 
};


/**
 * idmef_target_decoy_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_target_decoy_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_target_decoy_t idmef_target_decoy_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_TARGET_DECOY_UNKNOWN;

	if ( strcasecmp(name, "yes" ) == 0)
		return IDMEF_TARGET_DECOY_YES;

	if ( strcasecmp(name, "no" ) == 0)
		return IDMEF_TARGET_DECOY_NO;


	return -1;
}	

/**
 * idmef_target_decoy_to_string:
 * @val: an enumeration value for #idmef_target_decoy_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_target_decoy_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_target_decoy_to_string(idmef_target_decoy_t val)
{
	switch ( val ) {

		case IDMEF_TARGET_DECOY_UNKNOWN:
			return "unknown";

		case IDMEF_TARGET_DECOY_YES:
			return "yes";

		case IDMEF_TARGET_DECOY_NO:
			return "no";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_target { 
         IS_LISTED;
  REFCOUNT;
 
         uint64_t ident;
         idmef_target_decoy_t decoy;
         prelude_string_t interface;
 
         idmef_node_t *node;
         idmef_user_t *user;
         idmef_process_t *process;
         idmef_service_t *service;
         LISTED_OBJECT(file_list, idmef_file_t);
 
};



struct idmef_analyzer { 
  REFCOUNT;
 
         uint64_t analyzerid;
 
         prelude_string_t *name;
         prelude_string_t *manufacturer;
         prelude_string_t *model;
         prelude_string_t *version;
         prelude_string_t *class;
         prelude_string_t *ostype;
         prelude_string_t *osversion;
 
         idmef_node_t *node;
         idmef_process_t *process;
         struct idmef_analyzer *analyzer;
 
 
};



struct idmef_alertident { 
         IS_LISTED;
  REFCOUNT;
 
         uint64_t alertident;
         OPTIONAL_INT(uint64_t, analyzerid);
 
};


/**
 * idmef_impact_severity_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_impact_severity_t idmef_impact_severity_to_numeric(const char *name)
{

	if ( strcasecmp(name, "low" ) == 0)
		return IDMEF_IMPACT_SEVERITY_LOW;

	if ( strcasecmp(name, "medium" ) == 0)
		return IDMEF_IMPACT_SEVERITY_MEDIUM;

	if ( strcasecmp(name, "high" ) == 0)
		return IDMEF_IMPACT_SEVERITY_HIGH;

	if ( strcasecmp(name, "info" ) == 0)
		return IDMEF_IMPACT_SEVERITY_INFO;


	return -1;
}	

/**
 * idmef_impact_severity_to_string:
 * @val: an enumeration value for #idmef_impact_severity_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_impact_severity_to_string(idmef_impact_severity_t val)
{
	switch ( val ) {

		case 0:
			return NULL;

		case IDMEF_IMPACT_SEVERITY_LOW:
			return "low";

		case IDMEF_IMPACT_SEVERITY_MEDIUM:
			return "medium";

		case IDMEF_IMPACT_SEVERITY_HIGH:
			return "high";

		case IDMEF_IMPACT_SEVERITY_INFO:
			return "info";

		default:
			return NULL;
	}

	return NULL;
}

/**
 * idmef_impact_completion_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_impact_completion_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_impact_completion_t idmef_impact_completion_to_numeric(const char *name)
{

	if ( strcasecmp(name, "failed" ) == 0)
		return IDMEF_IMPACT_COMPLETION_FAILED;

	if ( strcasecmp(name, "succeeded" ) == 0)
		return IDMEF_IMPACT_COMPLETION_SUCCEEDED;


	return -1;
}	

/**
 * idmef_impact_completion_to_string:
 * @val: an enumeration value for #idmef_impact_completion_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_impact_completion_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_impact_completion_to_string(idmef_impact_completion_t val)
{
	switch ( val ) {

		case 0:
			return NULL;

		case IDMEF_IMPACT_COMPLETION_FAILED:
			return "failed";

		case IDMEF_IMPACT_COMPLETION_SUCCEEDED:
			return "succeeded";

		default:
			return NULL;
	}

	return NULL;
}

/**
 * idmef_impact_type_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_impact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_impact_type_t idmef_impact_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "other" ) == 0)
		return IDMEF_IMPACT_TYPE_OTHER;

	if ( strcasecmp(name, "admin" ) == 0)
		return IDMEF_IMPACT_TYPE_ADMIN;

	if ( strcasecmp(name, "dos" ) == 0)
		return IDMEF_IMPACT_TYPE_DOS;

	if ( strcasecmp(name, "file" ) == 0)
		return IDMEF_IMPACT_TYPE_FILE;

	if ( strcasecmp(name, "recon" ) == 0)
		return IDMEF_IMPACT_TYPE_RECON;

	if ( strcasecmp(name, "user" ) == 0)
		return IDMEF_IMPACT_TYPE_USER;


	return -1;
}	

/**
 * idmef_impact_type_to_string:
 * @val: an enumeration value for #idmef_impact_type_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_impact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_impact_type_to_string(idmef_impact_type_t val)
{
	switch ( val ) {

		case IDMEF_IMPACT_TYPE_OTHER:
			return "other";

		case IDMEF_IMPACT_TYPE_ADMIN:
			return "admin";

		case IDMEF_IMPACT_TYPE_DOS:
			return "dos";

		case IDMEF_IMPACT_TYPE_FILE:
			return "file";

		case IDMEF_IMPACT_TYPE_RECON:
			return "recon";

		case IDMEF_IMPACT_TYPE_USER:
			return "user";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_impact { 
  REFCOUNT;
 
         OPTIONAL_INT(idmef_impact_severity_t, severity);
         OPTIONAL_INT(idmef_impact_completion_t, completion);
         idmef_impact_type_t type;
         prelude_string_t *description;
 
};


/**
 * idmef_action_category_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_action_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_action_category_t idmef_action_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "other" ) == 0)
		return IDMEF_ACTION_CATEGORY_OTHER;

	if ( strcasecmp(name, "block-installed" ) == 0)
		return IDMEF_ACTION_CATEGORY_BLOCK_INSTALLED;

	if ( strcasecmp(name, "notification-sent" ) == 0)
		return IDMEF_ACTION_CATEGORY_NOTIFICATION_SENT;

	if ( strcasecmp(name, "taken-offline" ) == 0)
		return IDMEF_ACTION_CATEGORY_TAKEN_OFFLINE;


	return -1;
}	

/**
 * idmef_action_category_to_string:
 * @val: an enumeration value for #idmef_action_category_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_action_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_action_category_to_string(idmef_action_category_t val)
{
	switch ( val ) {

		case IDMEF_ACTION_CATEGORY_OTHER:
			return "other";

		case IDMEF_ACTION_CATEGORY_BLOCK_INSTALLED:
			return "block-installed";

		case IDMEF_ACTION_CATEGORY_NOTIFICATION_SENT:
			return "notification-sent";

		case IDMEF_ACTION_CATEGORY_TAKEN_OFFLINE:
			return "taken-offline";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_action { 
         IS_LISTED;
  REFCOUNT;
 
         idmef_action_category_t category;
         prelude_string_t *description;
 
};


/**
 * idmef_confidence_rating_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_confidence_rating_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_confidence_rating_t idmef_confidence_rating_to_numeric(const char *name)
{

	if ( strcasecmp(name, "numeric" ) == 0)
		return IDMEF_CONFIDENCE_RATING_NUMERIC;

	if ( strcasecmp(name, "low" ) == 0)
		return IDMEF_CONFIDENCE_RATING_LOW;

	if ( strcasecmp(name, "medium" ) == 0)
		return IDMEF_CONFIDENCE_RATING_MEDIUM;

	if ( strcasecmp(name, "high" ) == 0)
		return IDMEF_CONFIDENCE_RATING_HIGH;


	return -1;
}	

/**
 * idmef_confidence_rating_to_string:
 * @val: an enumeration value for #idmef_confidence_rating_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_confidence_rating_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_confidence_rating_to_string(idmef_confidence_rating_t val)
{
	switch ( val ) {

		case IDMEF_CONFIDENCE_RATING_NUMERIC:
			return "numeric";

		case IDMEF_CONFIDENCE_RATING_LOW:
			return "low";

		case IDMEF_CONFIDENCE_RATING_MEDIUM:
			return "medium";

		case IDMEF_CONFIDENCE_RATING_HIGH:
			return "high";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_confidence { 
  REFCOUNT;
 
         idmef_confidence_rating_t rating;
         OPTIONAL_INT(float, confidence);
 
};



struct idmef_assessment { 
  REFCOUNT;
 
         idmef_impact_t *impact;
         LISTED_OBJECT(action_list, idmef_action_t);
         idmef_confidence_t *confidence;
 
};



struct idmef_tool_alert { 
  REFCOUNT;
 
         prelude_string_t name;
         prelude_string_t *command;
         LISTED_OBJECT(alertident_list, idmef_alertident_t);
 
};



struct idmef_correlation_alert { 
  REFCOUNT;
 
         prelude_string_t name;
         LISTED_OBJECT(alertident_list, idmef_alertident_t);
 
};



struct idmef_overflow_alert { 
  REFCOUNT;
 
         prelude_string_t program;
         OPTIONAL_INT(uint32_t, size);
         idmef_data_t *buffer;
 
};


/**
 * idmef_alert_type_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_alert_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_alert_type_t idmef_alert_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "default" ) == 0)
		return IDMEF_ALERT_TYPE_DEFAULT;

	if ( strcasecmp(name, "tool" ) == 0)
		return IDMEF_ALERT_TYPE_TOOL;

	if ( strcasecmp(name, "correlation" ) == 0)
		return IDMEF_ALERT_TYPE_CORRELATION;

	if ( strcasecmp(name, "overflow" ) == 0)
		return IDMEF_ALERT_TYPE_OVERFLOW;


	return -1;
}	

/**
 * idmef_alert_type_to_string:
 * @val: an enumeration value for #idmef_alert_type_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_alert_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_alert_type_to_string(idmef_alert_type_t val)
{
	switch ( val ) {

		case IDMEF_ALERT_TYPE_DEFAULT:
			return "default";

		case IDMEF_ALERT_TYPE_TOOL:
			return "tool";

		case IDMEF_ALERT_TYPE_CORRELATION:
			return "correlation";

		case IDMEF_ALERT_TYPE_OVERFLOW:
			return "overflow";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_alert { 
         uint64_t messageid;
 
         idmef_analyzer_t *analyzer;
         idmef_time_t create_time;
         idmef_classification_t *classification;
         idmef_time_t *detect_time;
         idmef_time_t *analyzer_time;
 
         LISTED_OBJECT(source_list, idmef_source_t);
         LISTED_OBJECT(target_list, idmef_target_t);
 
         idmef_assessment_t *assessment;
 
         LISTED_OBJECT(additional_data_list, idmef_additional_data_t);
 
         UNION(idmef_alert_type_t, type) {
                 UNION_MEMBER(IDMEF_ALERT_TYPE_TOOL, idmef_tool_alert_t, *tool_alert);
                 UNION_MEMBER(IDMEF_ALERT_TYPE_CORRELATION, idmef_correlation_alert_t, *correlation_alert);
                 UNION_MEMBER(IDMEF_ALERT_TYPE_OVERFLOW, idmef_overflow_alert_t, *overflow_alert);
         } detail;
 
 
};



struct idmef_heartbeat { 
         uint64_t messageid;
         idmef_analyzer_t *analyzer;
 
         idmef_time_t create_time;
         idmef_time_t *analyzer_time;
 
         LISTED_OBJECT(additional_data_list, idmef_additional_data_t);
 
};


/**
 * idmef_message_type_to_numeric:
 * @name: pointer to an IDMEF string representation of a #idmef_message_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
idmef_message_type_t idmef_message_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "alert" ) == 0)
		return IDMEF_MESSAGE_TYPE_ALERT;

	if ( strcasecmp(name, "heartbeat" ) == 0)
		return IDMEF_MESSAGE_TYPE_HEARTBEAT;


	return -1;
}	

/**
 * idmef_message_type_to_string:
 * @val: an enumeration value for #idmef_message_type_t.
 *
 * Return the IDMEF string equivalent of @val provided #idmef_message_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *idmef_message_type_to_string(idmef_message_type_t val)
{
	switch ( val ) {

		case 0:
			return NULL;

		case IDMEF_MESSAGE_TYPE_ALERT:
			return "alert";

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			return "heartbeat";

		default:
			return NULL;
	}

	return NULL;
}


struct idmef_message { 
         REFCOUNT;
 
         prelude_string_t version;
 
         UNION(idmef_message_type_t, type) {
   UNION_MEMBER(IDMEF_MESSAGE_TYPE_ALERT, idmef_alert_t, *alert);
   UNION_MEMBER(IDMEF_MESSAGE_TYPE_HEARTBEAT, idmef_heartbeat_t, *heartbeat);
         } message;
 
  HIDE(prelude_msg_t *, pmsg);
 
 
};


/**
 * idmef_additional_data_new:
 * 
 * Create a new #idmef_additional_data_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_additional_data_t *idmef_additional_data_new(void)
{
	idmef_additional_data_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_additional_data_ref:
 * @ptr: pointer to a #idmef_additional_data_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_additional_data_t *idmef_additional_data_ref(idmef_additional_data_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_additional_data_get_child(void *p, idmef_child_t child)
{
	idmef_additional_data_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_additional_data_get_type_value(ptr);

		case 1:
			return idmef_additional_data_get_meaning_value(ptr);

		case 2:
			return idmef_additional_data_get_data_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_additional_data_new_child(void *p, idmef_child_t child, int n)
{
	idmef_additional_data_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_additional_data_new_type(ptr);

		case 1:
			return idmef_additional_data_new_meaning(ptr);

		case 2:
			return idmef_additional_data_new_data(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_additional_data_destroy_internal(idmef_additional_data_t *ptr)
{

	if ( ptr->meaning ) {
		prelude_string_destroy(ptr->meaning);
		ptr->meaning = NULL;
	}

	idmef_data_destroy_internal(&ptr->data);


	/* free() should be done by the caller */
}

/**
 * idmef_additional_data_destroy:
 * @ptr: pointer to a #idmef_additional_data_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_additional_data_destroy(idmef_additional_data_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_additional_data_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_additional_data_get_type:
 * @ptr: pointer to a #idmef_additional_data_t object.
 *
 * Get type children of the #idmef_additional_data_t object.
 *
 * Returns: a pointer to a idmef_additional_data_type_t object, or NULL if the children object is not set.
 */
idmef_additional_data_type_t idmef_additional_data_get_type(idmef_additional_data_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_additional_data_get_type_value(idmef_additional_data_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ADDITIONAL_DATA_TYPE, ptr->type);

}

/**
 * idmef_additional_data_set_type:
 * @ptr: pointer to a #idmef_additional_data_t object.
 * @type: pointer to a #idmef_additional_data_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void idmef_additional_data_set_type(idmef_additional_data_t *ptr, idmef_additional_data_type_t type)
{
	ptr->type = type;
}

/**
 * idmef_additional_data_new_type:
 * @ptr: pointer to a #idmef_additional_data_t object.
 *
 * Create a new type object, children of #idmef_additional_data_t.
 * If @ptr already contain a #idmef_additional_data_type_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_additional_data_type_t *idmef_additional_data_new_type(idmef_additional_data_t *ptr)
{
	return &ptr->type;
}

/**
 * *idmef_additional_data_get_meaning:
 * @ptr: pointer to a #idmef_additional_data_t object.
 *
 * Get meaning children of the #idmef_additional_data_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_additional_data_get_meaning(idmef_additional_data_t *ptr)
{
	return ptr->meaning;
}

idmef_value_t *idmef_additional_data_get_meaning_value(idmef_additional_data_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->meaning )
		return NULL;


	value = idmef_value_new_string(ptr->meaning);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_additional_data_set_meaning:
 * @ptr: pointer to a #idmef_additional_data_t object.
 * @meaning: pointer to a #prelude_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void idmef_additional_data_set_meaning(idmef_additional_data_t *ptr, prelude_string_t *meaning)
{
	if ( ptr->meaning )
		prelude_string_destroy(ptr->meaning);

	ptr->meaning = meaning;
}

/**
 * idmef_additional_data_new_meaning:
 * @ptr: pointer to a #idmef_additional_data_t object.
 *
 * Create a new meaning object, children of #idmef_additional_data_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_additional_data_new_meaning(idmef_additional_data_t *ptr)
{
	if ( ptr->meaning )
		prelude_string_destroy(ptr->meaning);
		
	ptr->meaning = prelude_string_new();

	return ptr->meaning;
}

/**
 * *idmef_additional_data_get_data:
 * @ptr: pointer to a #idmef_additional_data_t object.
 *
 * Get data children of the #idmef_additional_data_t object.
 *
 * Returns: a pointer to a idmef_data_t object, or NULL if the children object is not set.
 */
idmef_data_t *idmef_additional_data_get_data(idmef_additional_data_t *ptr)
{
	return &ptr->data;
}

idmef_value_t *idmef_additional_data_get_data_value(idmef_additional_data_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_data(&ptr->data);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_additional_data_set_data:
 * @ptr: pointer to a #idmef_additional_data_t object.
 * @data: pointer to a #idmef_data_t object.
 *
 * Set @data object as a children of @ptr.
 * if @ptr already contain an @data object, then it is destroyed,
 * and updated to point to the provided @data object.
 */

void idmef_additional_data_set_data(idmef_additional_data_t *ptr, idmef_data_t *data)
{
	idmef_data_destroy_internal(&ptr->data);
	memcpy(&ptr->data, data, sizeof (ptr->data));
	free(data);
}

/**
 * idmef_additional_data_new_data:
 * @ptr: pointer to a #idmef_additional_data_t object.
 *
 * Create a new data object, children of #idmef_additional_data_t.
 * If @ptr already contain a #idmef_data_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_data_t *idmef_additional_data_new_data(idmef_additional_data_t *ptr)
{
	idmef_data_destroy_internal(&ptr->data);

	return &ptr->data;
}

/**
 * idmef_reference_new:
 * 
 * Create a new #idmef_reference_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_reference_t *idmef_reference_new(void)
{
	idmef_reference_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_reference_ref:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_reference_t *idmef_reference_ref(idmef_reference_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_reference_get_child(void *p, idmef_child_t child)
{
	idmef_reference_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_reference_get_origin_value(ptr);

		case 1:
			return idmef_reference_get_name_value(ptr);

		case 2:
			return idmef_reference_get_url_value(ptr);

		case 3:
			return idmef_reference_get_meaning_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_reference_new_child(void *p, idmef_child_t child, int n)
{
	idmef_reference_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_reference_new_origin(ptr);

		case 1:
			return idmef_reference_new_name(ptr);

		case 2:
			return idmef_reference_new_url(ptr);

		case 3:
			return idmef_reference_new_meaning(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_reference_destroy_internal(idmef_reference_t *ptr)
{

	prelude_string_destroy_internal(&ptr->name);

	prelude_string_destroy_internal(&ptr->url);

	if ( ptr->meaning ) {
		prelude_string_destroy(ptr->meaning);
		ptr->meaning = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_reference_destroy:
 * @ptr: pointer to a #idmef_reference_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_reference_destroy(idmef_reference_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_reference_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_reference_get_origin:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Get origin children of the #idmef_reference_t object.
 *
 * Returns: a pointer to a idmef_reference_origin_t object, or NULL if the children object is not set.
 */
idmef_reference_origin_t idmef_reference_get_origin(idmef_reference_t *ptr)
{
	return ptr->origin;
}

idmef_value_t *idmef_reference_get_origin_value(idmef_reference_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_REFERENCE_ORIGIN, ptr->origin);

}

/**
 * idmef_reference_set_origin:
 * @ptr: pointer to a #idmef_reference_t object.
 * @origin: pointer to a #idmef_reference_origin_t object.
 *
 * Set @origin object as a children of @ptr.
 * if @ptr already contain an @origin object, then it is destroyed,
 * and updated to point to the provided @origin object.
 */

void idmef_reference_set_origin(idmef_reference_t *ptr, idmef_reference_origin_t origin)
{
	ptr->origin = origin;
}

/**
 * idmef_reference_new_origin:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Create a new origin object, children of #idmef_reference_t.
 * If @ptr already contain a #idmef_reference_origin_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_reference_origin_t *idmef_reference_new_origin(idmef_reference_t *ptr)
{
	return &ptr->origin;
}

/**
 * *idmef_reference_get_name:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Get name children of the #idmef_reference_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_reference_get_name(idmef_reference_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_reference_get_name_value(idmef_reference_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_reference_set_name:
 * @ptr: pointer to a #idmef_reference_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_reference_set_name(idmef_reference_t *ptr, prelude_string_t *name)
{
	prelude_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

/**
 * idmef_reference_new_name:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Create a new name object, children of #idmef_reference_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_reference_new_name(idmef_reference_t *ptr)
{
	prelude_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

/**
 * *idmef_reference_get_url:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Get url children of the #idmef_reference_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_reference_get_url(idmef_reference_t *ptr)
{
	return &ptr->url;
}

idmef_value_t *idmef_reference_get_url_value(idmef_reference_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->url);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_reference_set_url:
 * @ptr: pointer to a #idmef_reference_t object.
 * @url: pointer to a #prelude_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void idmef_reference_set_url(idmef_reference_t *ptr, prelude_string_t *url)
{
	prelude_string_destroy_internal(&ptr->url);
	memcpy(&ptr->url, url, sizeof (ptr->url));
	free(url);
}

/**
 * idmef_reference_new_url:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Create a new url object, children of #idmef_reference_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_reference_new_url(idmef_reference_t *ptr)
{
	prelude_string_destroy_internal(&ptr->url);

	return &ptr->url;
}

/**
 * *idmef_reference_get_meaning:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Get meaning children of the #idmef_reference_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_reference_get_meaning(idmef_reference_t *ptr)
{
	return ptr->meaning;
}

idmef_value_t *idmef_reference_get_meaning_value(idmef_reference_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->meaning )
		return NULL;


	value = idmef_value_new_string(ptr->meaning);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_reference_set_meaning:
 * @ptr: pointer to a #idmef_reference_t object.
 * @meaning: pointer to a #prelude_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void idmef_reference_set_meaning(idmef_reference_t *ptr, prelude_string_t *meaning)
{
	if ( ptr->meaning )
		prelude_string_destroy(ptr->meaning);

	ptr->meaning = meaning;
}

/**
 * idmef_reference_new_meaning:
 * @ptr: pointer to a #idmef_reference_t object.
 *
 * Create a new meaning object, children of #idmef_reference_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_reference_new_meaning(idmef_reference_t *ptr)
{
	if ( ptr->meaning )
		prelude_string_destroy(ptr->meaning);
		
	ptr->meaning = prelude_string_new();

	return ptr->meaning;
}

/**
 * idmef_classification_new:
 * 
 * Create a new #idmef_classification_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_classification_t *idmef_classification_new(void)
{
	idmef_classification_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->reference_list);
    

	return ret;

}

/**
 * idmef_classification_ref:
 * @ptr: pointer to a #idmef_classification_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_classification_t *idmef_classification_ref(idmef_classification_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_classification_get_child(void *p, idmef_child_t child)
{
	idmef_classification_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_classification_get_ident_value(ptr);

		case 1:
			return idmef_classification_get_text_value(ptr);

		case 2:
			return &ptr->reference_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_classification_new_child(void *p, idmef_child_t child, int n)
{
	idmef_classification_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_classification_new_ident(ptr);

		case 1:
			return idmef_classification_new_text(ptr);

		case 2: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_classification_new_reference(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->reference_list) {
			    		entry = prelude_list_entry(tmp, idmef_reference_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_classification_new_reference(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_classification_destroy_internal(idmef_classification_t *ptr)
{

	prelude_string_destroy_internal(&ptr->text);

	{
		prelude_list_t *n, *tmp;
		idmef_reference_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->reference_list) {
			entry = prelude_list_entry(tmp, idmef_reference_t, list);
			prelude_list_del(&entry->list);
			idmef_reference_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_classification_destroy:
 * @ptr: pointer to a #idmef_classification_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_classification_destroy(idmef_classification_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_classification_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_classification_get_ident:
 * @ptr: pointer to a #idmef_classification_t object.
 *
 * Get ident children of the #idmef_classification_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_classification_get_ident(idmef_classification_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_classification_get_ident_value(idmef_classification_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_classification_set_ident:
 * @ptr: pointer to a #idmef_classification_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_classification_set_ident(idmef_classification_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_classification_new_ident:
 * @ptr: pointer to a #idmef_classification_t object.
 *
 * Create a new ident object, children of #idmef_classification_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_classification_new_ident(idmef_classification_t *ptr)
{
	return &ptr->ident;
}

/**
 * *idmef_classification_get_text:
 * @ptr: pointer to a #idmef_classification_t object.
 *
 * Get text children of the #idmef_classification_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_classification_get_text(idmef_classification_t *ptr)
{
	return &ptr->text;
}

idmef_value_t *idmef_classification_get_text_value(idmef_classification_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->text);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_classification_set_text:
 * @ptr: pointer to a #idmef_classification_t object.
 * @text: pointer to a #prelude_string_t object.
 *
 * Set @text object as a children of @ptr.
 * if @ptr already contain an @text object, then it is destroyed,
 * and updated to point to the provided @text object.
 */

void idmef_classification_set_text(idmef_classification_t *ptr, prelude_string_t *text)
{
	prelude_string_destroy_internal(&ptr->text);
	memcpy(&ptr->text, text, sizeof (ptr->text));
	free(text);
}

/**
 * idmef_classification_new_text:
 * @ptr: pointer to a #idmef_classification_t object.
 *
 * Create a new text object, children of #idmef_classification_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_classification_new_text(idmef_classification_t *ptr)
{
	prelude_string_destroy_internal(&ptr->text);

	return &ptr->text;
}

/**
 * idmef_classification_get_next_reference:
 * @ptr: pointer to a #idmef_classification_t object.
 * @object: pointer to a #idmef_reference_t object.
 *
 * Get the next #idmef_reference_t object listed in @ptr.
 * When iterating over the idmef_reference_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_reference_t object.
 * 
 * Returns: the next #idmef_reference_t in the list.
 */
idmef_reference_t *idmef_classification_get_next_reference(idmef_classification_t *ptr, idmef_reference_t *object)
{
    	return prelude_list_get_next(object, &ptr->reference_list, idmef_reference_t, list);
}

/**
 * idmef_classification_set_reference:
 * @ptr: pointer to a #idmef_classification_t object.
 * @object: pointer to a #idmef_reference_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_reference_t object.
 */
void idmef_classification_set_reference(idmef_classification_t *ptr, idmef_reference_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->reference_list);
}

/**
 * idmef_classification_new_HASH(0x8023e900):
 * @ptr: pointer to a #idmef_classification_t object.
 * 
 * Create a new HASH(0x8023e900) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_reference_t object.
 * 
 * Returns: a pointer to the created #idmef_reference_t object, or NULL if an error occured.
 */
idmef_reference_t *idmef_classification_new_reference(idmef_classification_t *ptr)
{
	idmef_reference_t *object;
	
	object = idmef_reference_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->reference_list);
	
	return object;
}

idmef_value_t *idmef_classification_get_reference_value(idmef_classification_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_reference_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->reference_list) {
		entry = prelude_list_entry(tmp, idmef_reference_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_REFERENCE);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_user_id_new:
 * 
 * Create a new #idmef_user_id_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_user_id_t *idmef_user_id_new(void)
{
	idmef_user_id_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_user_id_ref:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_user_id_t *idmef_user_id_ref(idmef_user_id_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_user_id_get_child(void *p, idmef_child_t child)
{
	idmef_user_id_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_user_id_get_ident_value(ptr);

		case 1:
			return idmef_user_id_get_name_value(ptr);

		case 2:
			return idmef_user_id_get_type_value(ptr);

		case 3:
			return idmef_user_id_get_number_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_user_id_new_child(void *p, idmef_child_t child, int n)
{
	idmef_user_id_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_user_id_new_ident(ptr);

		case 1:
			return idmef_user_id_new_name(ptr);

		case 2:
			return idmef_user_id_new_type(ptr);

		case 3:
			return idmef_user_id_new_number(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_user_id_destroy_internal(idmef_user_id_t *ptr)
{

	if ( ptr->name ) {
		prelude_string_destroy(ptr->name);
		ptr->name = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_user_id_destroy:
 * @ptr: pointer to a #idmef_user_id_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_user_id_destroy(idmef_user_id_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_user_id_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_user_id_get_ident:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Get ident children of the #idmef_user_id_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_user_id_get_ident(idmef_user_id_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_user_id_get_ident_value(idmef_user_id_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_user_id_set_ident:
 * @ptr: pointer to a #idmef_user_id_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_user_id_set_ident(idmef_user_id_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_user_id_new_ident:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Create a new ident object, children of #idmef_user_id_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_user_id_new_ident(idmef_user_id_t *ptr)
{
	return &ptr->ident;
}

/**
 * *idmef_user_id_get_name:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Get name children of the #idmef_user_id_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_user_id_get_name(idmef_user_id_t *ptr)
{
	return ptr->name;
}

idmef_value_t *idmef_user_id_get_name_value(idmef_user_id_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->name )
		return NULL;


	value = idmef_value_new_string(ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_user_id_set_name:
 * @ptr: pointer to a #idmef_user_id_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_user_id_set_name(idmef_user_id_t *ptr, prelude_string_t *name)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);

	ptr->name = name;
}

/**
 * idmef_user_id_new_name:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Create a new name object, children of #idmef_user_id_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_user_id_new_name(idmef_user_id_t *ptr)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);
		
	ptr->name = prelude_string_new();

	return ptr->name;
}

/**
 * idmef_user_id_get_type:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Get type children of the #idmef_user_id_t object.
 *
 * Returns: a pointer to a idmef_user_id_type_t object, or NULL if the children object is not set.
 */
idmef_user_id_type_t idmef_user_id_get_type(idmef_user_id_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_user_id_get_type_value(idmef_user_id_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_USER_ID_TYPE, ptr->type);

}

/**
 * idmef_user_id_set_type:
 * @ptr: pointer to a #idmef_user_id_t object.
 * @type: pointer to a #idmef_user_id_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void idmef_user_id_set_type(idmef_user_id_t *ptr, idmef_user_id_type_t type)
{
	ptr->type = type;
}

/**
 * idmef_user_id_new_type:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Create a new type object, children of #idmef_user_id_t.
 * If @ptr already contain a #idmef_user_id_type_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_user_id_type_t *idmef_user_id_new_type(idmef_user_id_t *ptr)
{
	return &ptr->type;
}

/**
 * *idmef_user_id_get_number:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Get number children of the #idmef_user_id_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_user_id_get_number(idmef_user_id_t *ptr)
{
	return ptr->number_is_set ? &ptr->number : NULL;
}

idmef_value_t *idmef_user_id_get_number_value(idmef_user_id_t *ptr)
{
	return ptr->number_is_set ? idmef_value_new_uint32(ptr->number) : NULL;

}

/**
 * idmef_user_id_set_number:
 * @ptr: pointer to a #idmef_user_id_t object.
 * @number: pointer to a #uint32_t object.
 *
 * Set @number object as a children of @ptr.
 * if @ptr already contain an @number object, then it is destroyed,
 * and updated to point to the provided @number object.
 */

void idmef_user_id_set_number(idmef_user_id_t *ptr, uint32_t number)
{
	ptr->number = number;
	ptr->number_is_set = 1;
}

/**
 * idmef_user_id_new_number:
 * @ptr: pointer to a #idmef_user_id_t object.
 *
 * Create a new number object, children of #idmef_user_id_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_user_id_new_number(idmef_user_id_t *ptr)
{
	ptr->number_is_set = 1;

	return &ptr->number;
}

/**
 * idmef_user_new:
 * 
 * Create a new #idmef_user_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_user_t *idmef_user_new(void)
{
	idmef_user_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->user_id_list);
    

	return ret;

}

/**
 * idmef_user_ref:
 * @ptr: pointer to a #idmef_user_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_user_t *idmef_user_ref(idmef_user_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_user_get_child(void *p, idmef_child_t child)
{
	idmef_user_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_user_get_ident_value(ptr);

		case 1:
			return idmef_user_get_category_value(ptr);

		case 2:
			return &ptr->user_id_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_user_new_child(void *p, idmef_child_t child, int n)
{
	idmef_user_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_user_new_ident(ptr);

		case 1:
			return idmef_user_new_category(ptr);

		case 2: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_user_new_user_id(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->user_id_list) {
			    		entry = prelude_list_entry(tmp, idmef_user_id_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_user_new_user_id(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_user_destroy_internal(idmef_user_t *ptr)
{

	{
		prelude_list_t *n, *tmp;
		idmef_user_id_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->user_id_list) {
			entry = prelude_list_entry(tmp, idmef_user_id_t, list);
			prelude_list_del(&entry->list);
			idmef_user_id_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_user_destroy:
 * @ptr: pointer to a #idmef_user_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_user_destroy(idmef_user_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_user_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_user_get_ident:
 * @ptr: pointer to a #idmef_user_t object.
 *
 * Get ident children of the #idmef_user_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_user_get_ident(idmef_user_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_user_get_ident_value(idmef_user_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_user_set_ident:
 * @ptr: pointer to a #idmef_user_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_user_set_ident(idmef_user_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_user_new_ident:
 * @ptr: pointer to a #idmef_user_t object.
 *
 * Create a new ident object, children of #idmef_user_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_user_new_ident(idmef_user_t *ptr)
{
	return &ptr->ident;
}

/**
 * idmef_user_get_category:
 * @ptr: pointer to a #idmef_user_t object.
 *
 * Get category children of the #idmef_user_t object.
 *
 * Returns: a pointer to a idmef_user_category_t object, or NULL if the children object is not set.
 */
idmef_user_category_t idmef_user_get_category(idmef_user_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_user_get_category_value(idmef_user_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_USER_CATEGORY, ptr->category);

}

/**
 * idmef_user_set_category:
 * @ptr: pointer to a #idmef_user_t object.
 * @category: pointer to a #idmef_user_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void idmef_user_set_category(idmef_user_t *ptr, idmef_user_category_t category)
{
	ptr->category = category;
}

/**
 * idmef_user_new_category:
 * @ptr: pointer to a #idmef_user_t object.
 *
 * Create a new category object, children of #idmef_user_t.
 * If @ptr already contain a #idmef_user_category_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_user_category_t *idmef_user_new_category(idmef_user_t *ptr)
{
	return &ptr->category;
}

/**
 * idmef_user_get_next_user_id:
 * @ptr: pointer to a #idmef_user_t object.
 * @object: pointer to a #idmef_user_id_t object.
 *
 * Get the next #idmef_user_id_t object listed in @ptr.
 * When iterating over the idmef_user_id_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_user_id_t object.
 * 
 * Returns: the next #idmef_user_id_t in the list.
 */
idmef_user_id_t *idmef_user_get_next_user_id(idmef_user_t *ptr, idmef_user_id_t *object)
{
    	return prelude_list_get_next(object, &ptr->user_id_list, idmef_user_id_t, list);
}

/**
 * idmef_user_set_user_id:
 * @ptr: pointer to a #idmef_user_t object.
 * @object: pointer to a #idmef_user_id_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_user_id_t object.
 */
void idmef_user_set_user_id(idmef_user_t *ptr, idmef_user_id_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->user_id_list);
}

/**
 * idmef_user_new_HASH(0x802414b4):
 * @ptr: pointer to a #idmef_user_t object.
 * 
 * Create a new HASH(0x802414b4) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_user_id_t object.
 * 
 * Returns: a pointer to the created #idmef_user_id_t object, or NULL if an error occured.
 */
idmef_user_id_t *idmef_user_new_user_id(idmef_user_t *ptr)
{
	idmef_user_id_t *object;
	
	object = idmef_user_id_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->user_id_list);
	
	return object;
}

idmef_value_t *idmef_user_get_user_id_value(idmef_user_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_user_id_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->user_id_list) {
		entry = prelude_list_entry(tmp, idmef_user_id_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_USER_ID);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_address_new:
 * 
 * Create a new #idmef_address_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_address_t *idmef_address_new(void)
{
	idmef_address_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_address_ref:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_address_t *idmef_address_ref(idmef_address_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_address_get_child(void *p, idmef_child_t child)
{
	idmef_address_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_address_get_ident_value(ptr);

		case 1:
			return idmef_address_get_category_value(ptr);

		case 2:
			return idmef_address_get_vlan_name_value(ptr);

		case 3:
			return idmef_address_get_vlan_num_value(ptr);

		case 4:
			return idmef_address_get_address_value(ptr);

		case 5:
			return idmef_address_get_netmask_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_address_new_child(void *p, idmef_child_t child, int n)
{
	idmef_address_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_address_new_ident(ptr);

		case 1:
			return idmef_address_new_category(ptr);

		case 2:
			return idmef_address_new_vlan_name(ptr);

		case 3:
			return idmef_address_new_vlan_num(ptr);

		case 4:
			return idmef_address_new_address(ptr);

		case 5:
			return idmef_address_new_netmask(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_address_destroy_internal(idmef_address_t *ptr)
{

	if ( ptr->vlan_name ) {
		prelude_string_destroy(ptr->vlan_name);
		ptr->vlan_name = NULL;
	}

	prelude_string_destroy_internal(&ptr->address);

	if ( ptr->netmask ) {
		prelude_string_destroy(ptr->netmask);
		ptr->netmask = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_address_destroy:
 * @ptr: pointer to a #idmef_address_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_address_destroy(idmef_address_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_address_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_address_get_ident:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Get ident children of the #idmef_address_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_address_get_ident(idmef_address_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_address_get_ident_value(idmef_address_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_address_set_ident:
 * @ptr: pointer to a #idmef_address_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_address_set_ident(idmef_address_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_address_new_ident:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Create a new ident object, children of #idmef_address_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_address_new_ident(idmef_address_t *ptr)
{
	return &ptr->ident;
}

/**
 * idmef_address_get_category:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Get category children of the #idmef_address_t object.
 *
 * Returns: a pointer to a idmef_address_category_t object, or NULL if the children object is not set.
 */
idmef_address_category_t idmef_address_get_category(idmef_address_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_address_get_category_value(idmef_address_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ADDRESS_CATEGORY, ptr->category);

}

/**
 * idmef_address_set_category:
 * @ptr: pointer to a #idmef_address_t object.
 * @category: pointer to a #idmef_address_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void idmef_address_set_category(idmef_address_t *ptr, idmef_address_category_t category)
{
	ptr->category = category;
}

/**
 * idmef_address_new_category:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Create a new category object, children of #idmef_address_t.
 * If @ptr already contain a #idmef_address_category_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_address_category_t *idmef_address_new_category(idmef_address_t *ptr)
{
	return &ptr->category;
}

/**
 * *idmef_address_get_vlan_name:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Get vlan_name children of the #idmef_address_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_address_get_vlan_name(idmef_address_t *ptr)
{
	return ptr->vlan_name;
}

idmef_value_t *idmef_address_get_vlan_name_value(idmef_address_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->vlan_name )
		return NULL;


	value = idmef_value_new_string(ptr->vlan_name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_address_set_vlan_name:
 * @ptr: pointer to a #idmef_address_t object.
 * @vlan_name: pointer to a #prelude_string_t object.
 *
 * Set @vlan_name object as a children of @ptr.
 * if @ptr already contain an @vlan_name object, then it is destroyed,
 * and updated to point to the provided @vlan_name object.
 */

void idmef_address_set_vlan_name(idmef_address_t *ptr, prelude_string_t *vlan_name)
{
	if ( ptr->vlan_name )
		prelude_string_destroy(ptr->vlan_name);

	ptr->vlan_name = vlan_name;
}

/**
 * idmef_address_new_vlan_name:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Create a new vlan_name object, children of #idmef_address_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_address_new_vlan_name(idmef_address_t *ptr)
{
	if ( ptr->vlan_name )
		prelude_string_destroy(ptr->vlan_name);
		
	ptr->vlan_name = prelude_string_new();

	return ptr->vlan_name;
}

/**
 * *idmef_address_get_vlan_num:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Get vlan_num children of the #idmef_address_t object.
 *
 * Returns: a pointer to a int32_t object, or NULL if the children object is not set.
 */
int32_t *idmef_address_get_vlan_num(idmef_address_t *ptr)
{
	return ptr->vlan_num_is_set ? &ptr->vlan_num : NULL;
}

idmef_value_t *idmef_address_get_vlan_num_value(idmef_address_t *ptr)
{
	return ptr->vlan_num_is_set ? idmef_value_new_int32(ptr->vlan_num) : NULL;

}

/**
 * idmef_address_set_vlan_num:
 * @ptr: pointer to a #idmef_address_t object.
 * @vlan_num: pointer to a #int32_t object.
 *
 * Set @vlan_num object as a children of @ptr.
 * if @ptr already contain an @vlan_num object, then it is destroyed,
 * and updated to point to the provided @vlan_num object.
 */

void idmef_address_set_vlan_num(idmef_address_t *ptr, int32_t vlan_num)
{
	ptr->vlan_num = vlan_num;
	ptr->vlan_num_is_set = 1;
}

/**
 * idmef_address_new_vlan_num:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Create a new vlan_num object, children of #idmef_address_t.
 * If @ptr already contain a #int32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
int32_t *idmef_address_new_vlan_num(idmef_address_t *ptr)
{
	ptr->vlan_num_is_set = 1;

	return &ptr->vlan_num;
}

/**
 * *idmef_address_get_address:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Get address children of the #idmef_address_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_address_get_address(idmef_address_t *ptr)
{
	return &ptr->address;
}

idmef_value_t *idmef_address_get_address_value(idmef_address_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->address);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_address_set_address:
 * @ptr: pointer to a #idmef_address_t object.
 * @address: pointer to a #prelude_string_t object.
 *
 * Set @address object as a children of @ptr.
 * if @ptr already contain an @address object, then it is destroyed,
 * and updated to point to the provided @address object.
 */

void idmef_address_set_address(idmef_address_t *ptr, prelude_string_t *address)
{
	prelude_string_destroy_internal(&ptr->address);
	memcpy(&ptr->address, address, sizeof (ptr->address));
	free(address);
}

/**
 * idmef_address_new_address:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Create a new address object, children of #idmef_address_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_address_new_address(idmef_address_t *ptr)
{
	prelude_string_destroy_internal(&ptr->address);

	return &ptr->address;
}

/**
 * *idmef_address_get_netmask:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Get netmask children of the #idmef_address_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_address_get_netmask(idmef_address_t *ptr)
{
	return ptr->netmask;
}

idmef_value_t *idmef_address_get_netmask_value(idmef_address_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->netmask )
		return NULL;


	value = idmef_value_new_string(ptr->netmask);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_address_set_netmask:
 * @ptr: pointer to a #idmef_address_t object.
 * @netmask: pointer to a #prelude_string_t object.
 *
 * Set @netmask object as a children of @ptr.
 * if @ptr already contain an @netmask object, then it is destroyed,
 * and updated to point to the provided @netmask object.
 */

void idmef_address_set_netmask(idmef_address_t *ptr, prelude_string_t *netmask)
{
	if ( ptr->netmask )
		prelude_string_destroy(ptr->netmask);

	ptr->netmask = netmask;
}

/**
 * idmef_address_new_netmask:
 * @ptr: pointer to a #idmef_address_t object.
 *
 * Create a new netmask object, children of #idmef_address_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_address_new_netmask(idmef_address_t *ptr)
{
	if ( ptr->netmask )
		prelude_string_destroy(ptr->netmask);
		
	ptr->netmask = prelude_string_new();

	return ptr->netmask;
}

/**
 * idmef_process_new:
 * 
 * Create a new #idmef_process_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_process_t *idmef_process_new(void)
{
	idmef_process_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->arg_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->env_list);
    

	return ret;

}

/**
 * idmef_process_ref:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_process_t *idmef_process_ref(idmef_process_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_process_get_child(void *p, idmef_child_t child)
{
	idmef_process_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_process_get_ident_value(ptr);

		case 1:
			return idmef_process_get_name_value(ptr);

		case 2:
			return idmef_process_get_pid_value(ptr);

		case 3:
			return idmef_process_get_path_value(ptr);

		case 4:
			return &ptr->arg_list;

		case 5:
			return &ptr->env_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_process_new_child(void *p, idmef_child_t child, int n)
{
	idmef_process_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_process_new_ident(ptr);

		case 1:
			return idmef_process_new_name(ptr);

		case 2:
			return idmef_process_new_pid(ptr);

		case 3:
			return idmef_process_new_path(ptr);

		case 4: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_process_new_arg(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->arg_list) {
			    		entry = prelude_list_entry(tmp, prelude_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_process_new_arg(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 5: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_process_new_env(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->env_list) {
			    		entry = prelude_list_entry(tmp, prelude_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_process_new_env(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_process_destroy_internal(idmef_process_t *ptr)
{

	prelude_string_destroy_internal(&ptr->name);

	if ( ptr->path ) {
		prelude_string_destroy(ptr->path);
		ptr->path = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		prelude_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->arg_list) {
			entry = prelude_list_entry(tmp, prelude_string_t, list);
			prelude_list_del(&entry->list);
			prelude_string_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		prelude_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->env_list) {
			entry = prelude_list_entry(tmp, prelude_string_t, list);
			prelude_list_del(&entry->list);
			prelude_string_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_process_destroy:
 * @ptr: pointer to a #idmef_process_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_process_destroy(idmef_process_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_process_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_process_get_ident:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Get ident children of the #idmef_process_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_process_get_ident(idmef_process_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_process_get_ident_value(idmef_process_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_process_set_ident:
 * @ptr: pointer to a #idmef_process_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_process_set_ident(idmef_process_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_process_new_ident:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Create a new ident object, children of #idmef_process_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_process_new_ident(idmef_process_t *ptr)
{
	return &ptr->ident;
}

/**
 * *idmef_process_get_name:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Get name children of the #idmef_process_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_process_get_name(idmef_process_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_process_get_name_value(idmef_process_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_process_set_name:
 * @ptr: pointer to a #idmef_process_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_process_set_name(idmef_process_t *ptr, prelude_string_t *name)
{
	prelude_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

/**
 * idmef_process_new_name:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Create a new name object, children of #idmef_process_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_process_new_name(idmef_process_t *ptr)
{
	prelude_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

/**
 * *idmef_process_get_pid:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Get pid children of the #idmef_process_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_process_get_pid(idmef_process_t *ptr)
{
	return ptr->pid_is_set ? &ptr->pid : NULL;
}

idmef_value_t *idmef_process_get_pid_value(idmef_process_t *ptr)
{
	return ptr->pid_is_set ? idmef_value_new_uint32(ptr->pid) : NULL;

}

/**
 * idmef_process_set_pid:
 * @ptr: pointer to a #idmef_process_t object.
 * @pid: pointer to a #uint32_t object.
 *
 * Set @pid object as a children of @ptr.
 * if @ptr already contain an @pid object, then it is destroyed,
 * and updated to point to the provided @pid object.
 */

void idmef_process_set_pid(idmef_process_t *ptr, uint32_t pid)
{
	ptr->pid = pid;
	ptr->pid_is_set = 1;
}

/**
 * idmef_process_new_pid:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Create a new pid object, children of #idmef_process_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_process_new_pid(idmef_process_t *ptr)
{
	ptr->pid_is_set = 1;

	return &ptr->pid;
}

/**
 * *idmef_process_get_path:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Get path children of the #idmef_process_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_process_get_path(idmef_process_t *ptr)
{
	return ptr->path;
}

idmef_value_t *idmef_process_get_path_value(idmef_process_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->path )
		return NULL;


	value = idmef_value_new_string(ptr->path);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_process_set_path:
 * @ptr: pointer to a #idmef_process_t object.
 * @path: pointer to a #prelude_string_t object.
 *
 * Set @path object as a children of @ptr.
 * if @ptr already contain an @path object, then it is destroyed,
 * and updated to point to the provided @path object.
 */

void idmef_process_set_path(idmef_process_t *ptr, prelude_string_t *path)
{
	if ( ptr->path )
		prelude_string_destroy(ptr->path);

	ptr->path = path;
}

/**
 * idmef_process_new_path:
 * @ptr: pointer to a #idmef_process_t object.
 *
 * Create a new path object, children of #idmef_process_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_process_new_path(idmef_process_t *ptr)
{
	if ( ptr->path )
		prelude_string_destroy(ptr->path);
		
	ptr->path = prelude_string_new();

	return ptr->path;
}

/**
 * idmef_process_get_next_arg:
 * @ptr: pointer to a #idmef_process_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Get the next #prelude_string_t object listed in @ptr.
 * When iterating over the prelude_string_t object listed in @ptr,
 * @object should be set to the latest returned #prelude_string_t object.
 * 
 * Returns: the next #prelude_string_t in the list.
 */
prelude_string_t *idmef_process_get_next_arg(idmef_process_t *ptr, prelude_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->arg_list, prelude_string_t, list);
}

/**
 * idmef_process_set_arg:
 * @ptr: pointer to a #idmef_process_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Add @object to the tail of @ptr list of #prelude_string_t object.
 */
void idmef_process_set_arg(idmef_process_t *ptr, prelude_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->arg_list);
}

/**
 * idmef_process_new_HASH(0x80244fb0):
 * @ptr: pointer to a #idmef_process_t object.
 * 
 * Create a new HASH(0x80244fb0) children of @ptr,
 * and add it to the tail of @ptr list of #prelude_string_t object.
 * 
 * Returns: a pointer to the created #prelude_string_t object, or NULL if an error occured.
 */
prelude_string_t *idmef_process_new_arg(idmef_process_t *ptr)
{
	prelude_string_t *object;
	
	object = prelude_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->arg_list);
	
	return object;
}

idmef_value_t *idmef_process_get_arg_value(idmef_process_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	prelude_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->arg_list) {
		entry = prelude_list_entry(tmp, prelude_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_process_get_next_env:
 * @ptr: pointer to a #idmef_process_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Get the next #prelude_string_t object listed in @ptr.
 * When iterating over the prelude_string_t object listed in @ptr,
 * @object should be set to the latest returned #prelude_string_t object.
 * 
 * Returns: the next #prelude_string_t in the list.
 */
prelude_string_t *idmef_process_get_next_env(idmef_process_t *ptr, prelude_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->env_list, prelude_string_t, list);
}

/**
 * idmef_process_set_env:
 * @ptr: pointer to a #idmef_process_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Add @object to the tail of @ptr list of #prelude_string_t object.
 */
void idmef_process_set_env(idmef_process_t *ptr, prelude_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->env_list);
}

/**
 * idmef_process_new_HASH(0x80246a60):
 * @ptr: pointer to a #idmef_process_t object.
 * 
 * Create a new HASH(0x80246a60) children of @ptr,
 * and add it to the tail of @ptr list of #prelude_string_t object.
 * 
 * Returns: a pointer to the created #prelude_string_t object, or NULL if an error occured.
 */
prelude_string_t *idmef_process_new_env(idmef_process_t *ptr)
{
	prelude_string_t *object;
	
	object = prelude_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->env_list);
	
	return object;
}

idmef_value_t *idmef_process_get_env_value(idmef_process_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	prelude_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->env_list) {
		entry = prelude_list_entry(tmp, prelude_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_web_service_new:
 * 
 * Create a new #idmef_web_service_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_web_service_t *idmef_web_service_new(void)
{
	idmef_web_service_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->arg_list);
    

	return ret;

}

/**
 * idmef_web_service_ref:
 * @ptr: pointer to a #idmef_web_service_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_web_service_t *idmef_web_service_ref(idmef_web_service_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_web_service_get_child(void *p, idmef_child_t child)
{
	idmef_web_service_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_web_service_get_url_value(ptr);

		case 1:
			return idmef_web_service_get_cgi_value(ptr);

		case 2:
			return idmef_web_service_get_http_method_value(ptr);

		case 3:
			return &ptr->arg_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_web_service_new_child(void *p, idmef_child_t child, int n)
{
	idmef_web_service_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_web_service_new_url(ptr);

		case 1:
			return idmef_web_service_new_cgi(ptr);

		case 2:
			return idmef_web_service_new_http_method(ptr);

		case 3: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_web_service_new_arg(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->arg_list) {
			    		entry = prelude_list_entry(tmp, prelude_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_web_service_new_arg(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_web_service_destroy_internal(idmef_web_service_t *ptr)
{

	prelude_string_destroy_internal(&ptr->url);

	if ( ptr->cgi ) {
		prelude_string_destroy(ptr->cgi);
		ptr->cgi = NULL;
	}

	if ( ptr->http_method ) {
		prelude_string_destroy(ptr->http_method);
		ptr->http_method = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		prelude_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->arg_list) {
			entry = prelude_list_entry(tmp, prelude_string_t, list);
			prelude_list_del(&entry->list);
			prelude_string_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_web_service_destroy:
 * @ptr: pointer to a #idmef_web_service_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_web_service_destroy(idmef_web_service_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_web_service_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_web_service_get_url:
 * @ptr: pointer to a #idmef_web_service_t object.
 *
 * Get url children of the #idmef_web_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_web_service_get_url(idmef_web_service_t *ptr)
{
	return &ptr->url;
}

idmef_value_t *idmef_web_service_get_url_value(idmef_web_service_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->url);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_web_service_set_url:
 * @ptr: pointer to a #idmef_web_service_t object.
 * @url: pointer to a #prelude_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void idmef_web_service_set_url(idmef_web_service_t *ptr, prelude_string_t *url)
{
	prelude_string_destroy_internal(&ptr->url);
	memcpy(&ptr->url, url, sizeof (ptr->url));
	free(url);
}

/**
 * idmef_web_service_new_url:
 * @ptr: pointer to a #idmef_web_service_t object.
 *
 * Create a new url object, children of #idmef_web_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_web_service_new_url(idmef_web_service_t *ptr)
{
	prelude_string_destroy_internal(&ptr->url);

	return &ptr->url;
}

/**
 * *idmef_web_service_get_cgi:
 * @ptr: pointer to a #idmef_web_service_t object.
 *
 * Get cgi children of the #idmef_web_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_web_service_get_cgi(idmef_web_service_t *ptr)
{
	return ptr->cgi;
}

idmef_value_t *idmef_web_service_get_cgi_value(idmef_web_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->cgi )
		return NULL;


	value = idmef_value_new_string(ptr->cgi);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_web_service_set_cgi:
 * @ptr: pointer to a #idmef_web_service_t object.
 * @cgi: pointer to a #prelude_string_t object.
 *
 * Set @cgi object as a children of @ptr.
 * if @ptr already contain an @cgi object, then it is destroyed,
 * and updated to point to the provided @cgi object.
 */

void idmef_web_service_set_cgi(idmef_web_service_t *ptr, prelude_string_t *cgi)
{
	if ( ptr->cgi )
		prelude_string_destroy(ptr->cgi);

	ptr->cgi = cgi;
}

/**
 * idmef_web_service_new_cgi:
 * @ptr: pointer to a #idmef_web_service_t object.
 *
 * Create a new cgi object, children of #idmef_web_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_web_service_new_cgi(idmef_web_service_t *ptr)
{
	if ( ptr->cgi )
		prelude_string_destroy(ptr->cgi);
		
	ptr->cgi = prelude_string_new();

	return ptr->cgi;
}

/**
 * *idmef_web_service_get_http_method:
 * @ptr: pointer to a #idmef_web_service_t object.
 *
 * Get http_method children of the #idmef_web_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_web_service_get_http_method(idmef_web_service_t *ptr)
{
	return ptr->http_method;
}

idmef_value_t *idmef_web_service_get_http_method_value(idmef_web_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->http_method )
		return NULL;


	value = idmef_value_new_string(ptr->http_method);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_web_service_set_http_method:
 * @ptr: pointer to a #idmef_web_service_t object.
 * @http_method: pointer to a #prelude_string_t object.
 *
 * Set @http_method object as a children of @ptr.
 * if @ptr already contain an @http_method object, then it is destroyed,
 * and updated to point to the provided @http_method object.
 */

void idmef_web_service_set_http_method(idmef_web_service_t *ptr, prelude_string_t *http_method)
{
	if ( ptr->http_method )
		prelude_string_destroy(ptr->http_method);

	ptr->http_method = http_method;
}

/**
 * idmef_web_service_new_http_method:
 * @ptr: pointer to a #idmef_web_service_t object.
 *
 * Create a new http_method object, children of #idmef_web_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_web_service_new_http_method(idmef_web_service_t *ptr)
{
	if ( ptr->http_method )
		prelude_string_destroy(ptr->http_method);
		
	ptr->http_method = prelude_string_new();

	return ptr->http_method;
}

/**
 * idmef_web_service_get_next_arg:
 * @ptr: pointer to a #idmef_web_service_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Get the next #prelude_string_t object listed in @ptr.
 * When iterating over the prelude_string_t object listed in @ptr,
 * @object should be set to the latest returned #prelude_string_t object.
 * 
 * Returns: the next #prelude_string_t in the list.
 */
prelude_string_t *idmef_web_service_get_next_arg(idmef_web_service_t *ptr, prelude_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->arg_list, prelude_string_t, list);
}

/**
 * idmef_web_service_set_arg:
 * @ptr: pointer to a #idmef_web_service_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Add @object to the tail of @ptr list of #prelude_string_t object.
 */
void idmef_web_service_set_arg(idmef_web_service_t *ptr, prelude_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->arg_list);
}

/**
 * idmef_web_service_new_HASH(0x80246d30):
 * @ptr: pointer to a #idmef_web_service_t object.
 * 
 * Create a new HASH(0x80246d30) children of @ptr,
 * and add it to the tail of @ptr list of #prelude_string_t object.
 * 
 * Returns: a pointer to the created #prelude_string_t object, or NULL if an error occured.
 */
prelude_string_t *idmef_web_service_new_arg(idmef_web_service_t *ptr)
{
	prelude_string_t *object;
	
	object = prelude_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->arg_list);
	
	return object;
}

idmef_value_t *idmef_web_service_get_arg_value(idmef_web_service_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	prelude_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->arg_list) {
		entry = prelude_list_entry(tmp, prelude_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_snmp_service_new:
 * 
 * Create a new #idmef_snmp_service_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_snmp_service_t *idmef_snmp_service_new(void)
{
	idmef_snmp_service_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_snmp_service_ref:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_snmp_service_t *idmef_snmp_service_ref(idmef_snmp_service_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_snmp_service_get_child(void *p, idmef_child_t child)
{
	idmef_snmp_service_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_snmp_service_get_oid_value(ptr);

		case 1:
			return idmef_snmp_service_get_community_value(ptr);

		case 2:
			return idmef_snmp_service_get_security_name_value(ptr);

		case 3:
			return idmef_snmp_service_get_context_name_value(ptr);

		case 4:
			return idmef_snmp_service_get_context_engine_id_value(ptr);

		case 5:
			return idmef_snmp_service_get_command_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_snmp_service_new_child(void *p, idmef_child_t child, int n)
{
	idmef_snmp_service_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_snmp_service_new_oid(ptr);

		case 1:
			return idmef_snmp_service_new_community(ptr);

		case 2:
			return idmef_snmp_service_new_security_name(ptr);

		case 3:
			return idmef_snmp_service_new_context_name(ptr);

		case 4:
			return idmef_snmp_service_new_context_engine_id(ptr);

		case 5:
			return idmef_snmp_service_new_command(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_snmp_service_destroy_internal(idmef_snmp_service_t *ptr)
{

	if ( ptr->oid ) {
		prelude_string_destroy(ptr->oid);
		ptr->oid = NULL;
	}

	if ( ptr->community ) {
		prelude_string_destroy(ptr->community);
		ptr->community = NULL;
	}

	if ( ptr->security_name ) {
		prelude_string_destroy(ptr->security_name);
		ptr->security_name = NULL;
	}

	if ( ptr->context_name ) {
		prelude_string_destroy(ptr->context_name);
		ptr->context_name = NULL;
	}

	if ( ptr->context_engine_id ) {
		prelude_string_destroy(ptr->context_engine_id);
		ptr->context_engine_id = NULL;
	}

	if ( ptr->command ) {
		prelude_string_destroy(ptr->command);
		ptr->command = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_snmp_service_destroy:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_snmp_service_destroy(idmef_snmp_service_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_snmp_service_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_snmp_service_get_oid:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Get oid children of the #idmef_snmp_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_snmp_service_get_oid(idmef_snmp_service_t *ptr)
{
	return ptr->oid;
}

idmef_value_t *idmef_snmp_service_get_oid_value(idmef_snmp_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->oid )
		return NULL;


	value = idmef_value_new_string(ptr->oid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_snmp_service_set_oid:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 * @oid: pointer to a #prelude_string_t object.
 *
 * Set @oid object as a children of @ptr.
 * if @ptr already contain an @oid object, then it is destroyed,
 * and updated to point to the provided @oid object.
 */

void idmef_snmp_service_set_oid(idmef_snmp_service_t *ptr, prelude_string_t *oid)
{
	if ( ptr->oid )
		prelude_string_destroy(ptr->oid);

	ptr->oid = oid;
}

/**
 * idmef_snmp_service_new_oid:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Create a new oid object, children of #idmef_snmp_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_snmp_service_new_oid(idmef_snmp_service_t *ptr)
{
	if ( ptr->oid )
		prelude_string_destroy(ptr->oid);
		
	ptr->oid = prelude_string_new();

	return ptr->oid;
}

/**
 * *idmef_snmp_service_get_community:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Get community children of the #idmef_snmp_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_snmp_service_get_community(idmef_snmp_service_t *ptr)
{
	return ptr->community;
}

idmef_value_t *idmef_snmp_service_get_community_value(idmef_snmp_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->community )
		return NULL;


	value = idmef_value_new_string(ptr->community);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_snmp_service_set_community:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 * @community: pointer to a #prelude_string_t object.
 *
 * Set @community object as a children of @ptr.
 * if @ptr already contain an @community object, then it is destroyed,
 * and updated to point to the provided @community object.
 */

void idmef_snmp_service_set_community(idmef_snmp_service_t *ptr, prelude_string_t *community)
{
	if ( ptr->community )
		prelude_string_destroy(ptr->community);

	ptr->community = community;
}

/**
 * idmef_snmp_service_new_community:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Create a new community object, children of #idmef_snmp_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_snmp_service_new_community(idmef_snmp_service_t *ptr)
{
	if ( ptr->community )
		prelude_string_destroy(ptr->community);
		
	ptr->community = prelude_string_new();

	return ptr->community;
}

/**
 * *idmef_snmp_service_get_security_name:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Get security_name children of the #idmef_snmp_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_snmp_service_get_security_name(idmef_snmp_service_t *ptr)
{
	return ptr->security_name;
}

idmef_value_t *idmef_snmp_service_get_security_name_value(idmef_snmp_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->security_name )
		return NULL;


	value = idmef_value_new_string(ptr->security_name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_snmp_service_set_security_name:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 * @security_name: pointer to a #prelude_string_t object.
 *
 * Set @security_name object as a children of @ptr.
 * if @ptr already contain an @security_name object, then it is destroyed,
 * and updated to point to the provided @security_name object.
 */

void idmef_snmp_service_set_security_name(idmef_snmp_service_t *ptr, prelude_string_t *security_name)
{
	if ( ptr->security_name )
		prelude_string_destroy(ptr->security_name);

	ptr->security_name = security_name;
}

/**
 * idmef_snmp_service_new_security_name:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Create a new security_name object, children of #idmef_snmp_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_snmp_service_new_security_name(idmef_snmp_service_t *ptr)
{
	if ( ptr->security_name )
		prelude_string_destroy(ptr->security_name);
		
	ptr->security_name = prelude_string_new();

	return ptr->security_name;
}

/**
 * *idmef_snmp_service_get_context_name:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Get context_name children of the #idmef_snmp_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_snmp_service_get_context_name(idmef_snmp_service_t *ptr)
{
	return ptr->context_name;
}

idmef_value_t *idmef_snmp_service_get_context_name_value(idmef_snmp_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->context_name )
		return NULL;


	value = idmef_value_new_string(ptr->context_name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_snmp_service_set_context_name:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 * @context_name: pointer to a #prelude_string_t object.
 *
 * Set @context_name object as a children of @ptr.
 * if @ptr already contain an @context_name object, then it is destroyed,
 * and updated to point to the provided @context_name object.
 */

void idmef_snmp_service_set_context_name(idmef_snmp_service_t *ptr, prelude_string_t *context_name)
{
	if ( ptr->context_name )
		prelude_string_destroy(ptr->context_name);

	ptr->context_name = context_name;
}

/**
 * idmef_snmp_service_new_context_name:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Create a new context_name object, children of #idmef_snmp_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_snmp_service_new_context_name(idmef_snmp_service_t *ptr)
{
	if ( ptr->context_name )
		prelude_string_destroy(ptr->context_name);
		
	ptr->context_name = prelude_string_new();

	return ptr->context_name;
}

/**
 * *idmef_snmp_service_get_context_engine_id:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Get context_engine_id children of the #idmef_snmp_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_snmp_service_get_context_engine_id(idmef_snmp_service_t *ptr)
{
	return ptr->context_engine_id;
}

idmef_value_t *idmef_snmp_service_get_context_engine_id_value(idmef_snmp_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->context_engine_id )
		return NULL;


	value = idmef_value_new_string(ptr->context_engine_id);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_snmp_service_set_context_engine_id:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 * @context_engine_id: pointer to a #prelude_string_t object.
 *
 * Set @context_engine_id object as a children of @ptr.
 * if @ptr already contain an @context_engine_id object, then it is destroyed,
 * and updated to point to the provided @context_engine_id object.
 */

void idmef_snmp_service_set_context_engine_id(idmef_snmp_service_t *ptr, prelude_string_t *context_engine_id)
{
	if ( ptr->context_engine_id )
		prelude_string_destroy(ptr->context_engine_id);

	ptr->context_engine_id = context_engine_id;
}

/**
 * idmef_snmp_service_new_context_engine_id:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Create a new context_engine_id object, children of #idmef_snmp_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_snmp_service_new_context_engine_id(idmef_snmp_service_t *ptr)
{
	if ( ptr->context_engine_id )
		prelude_string_destroy(ptr->context_engine_id);
		
	ptr->context_engine_id = prelude_string_new();

	return ptr->context_engine_id;
}

/**
 * *idmef_snmp_service_get_command:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Get command children of the #idmef_snmp_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_snmp_service_get_command(idmef_snmp_service_t *ptr)
{
	return ptr->command;
}

idmef_value_t *idmef_snmp_service_get_command_value(idmef_snmp_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->command )
		return NULL;


	value = idmef_value_new_string(ptr->command);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_snmp_service_set_command:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 * @command: pointer to a #prelude_string_t object.
 *
 * Set @command object as a children of @ptr.
 * if @ptr already contain an @command object, then it is destroyed,
 * and updated to point to the provided @command object.
 */

void idmef_snmp_service_set_command(idmef_snmp_service_t *ptr, prelude_string_t *command)
{
	if ( ptr->command )
		prelude_string_destroy(ptr->command);

	ptr->command = command;
}

/**
 * idmef_snmp_service_new_command:
 * @ptr: pointer to a #idmef_snmp_service_t object.
 *
 * Create a new command object, children of #idmef_snmp_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_snmp_service_new_command(idmef_snmp_service_t *ptr)
{
	if ( ptr->command )
		prelude_string_destroy(ptr->command);
		
	ptr->command = prelude_string_new();

	return ptr->command;
}

/**
 * idmef_service_new:
 * 
 * Create a new #idmef_service_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_service_t *idmef_service_new(void)
{
	idmef_service_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_service_ref:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_service_t *idmef_service_ref(idmef_service_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_service_get_child(void *p, idmef_child_t child)
{
	idmef_service_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_service_get_ident_value(ptr);

		case 1:
			return idmef_service_get_ip_version_value(ptr);

		case 2:
			return idmef_service_get_name_value(ptr);

		case 3:
			return idmef_service_get_port_value(ptr);

		case 4:
			return idmef_service_get_iana_protocol_number_value(ptr);

		case 5:
			return idmef_service_get_iana_protocol_name_value(ptr);

		case 6:
			return idmef_service_get_portlist_value(ptr);

		case 7:
			return idmef_service_get_protocol_value(ptr);

		case 8:
			return idmef_service_get_type_value(ptr);

		case 9: 
			if ( ptr->type == IDMEF_SERVICE_TYPE_WEB ) 
				return ptr->specific.web_service;
			return NULL;   	   

		case 10: 
			if ( ptr->type == IDMEF_SERVICE_TYPE_SNMP ) 
				return ptr->specific.snmp_service;
			return NULL;   	   

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_service_new_child(void *p, idmef_child_t child, int n)
{
	idmef_service_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_service_new_ident(ptr);

		case 1:
			return idmef_service_new_ip_version(ptr);

		case 2:
			return idmef_service_new_name(ptr);

		case 3:
			return idmef_service_new_port(ptr);

		case 4:
			return idmef_service_new_iana_protocol_number(ptr);

		case 5:
			return idmef_service_new_iana_protocol_name(ptr);

		case 6:
			return idmef_service_new_portlist(ptr);

		case 7:
			return idmef_service_new_protocol(ptr);

		case 9:
			return idmef_service_new_web_service(ptr);

		case 10:
			return idmef_service_new_snmp_service(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_service_destroy_internal(idmef_service_t *ptr)
{

	if ( ptr->name ) {
		prelude_string_destroy(ptr->name);
		ptr->name = NULL;
	}

	if ( ptr->iana_protocol_name ) {
		prelude_string_destroy(ptr->iana_protocol_name);
		ptr->iana_protocol_name = NULL;
	}

	if ( ptr->portlist ) {
		prelude_string_destroy(ptr->portlist);
		ptr->portlist = NULL;
	}

	if ( ptr->protocol ) {
		prelude_string_destroy(ptr->protocol);
		ptr->protocol = NULL;
	}

	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_web_service_destroy(ptr->specific.web_service);
			ptr->specific.web_service = NULL;
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmp_service_destroy(ptr->specific.snmp_service);
			ptr->specific.snmp_service = NULL;
			break;

		default:
			break;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_service_destroy:
 * @ptr: pointer to a #idmef_service_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_service_destroy(idmef_service_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_service_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_service_get_ident:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get ident children of the #idmef_service_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_service_get_ident(idmef_service_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_service_get_ident_value(idmef_service_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_service_set_ident:
 * @ptr: pointer to a #idmef_service_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_service_set_ident(idmef_service_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_service_new_ident:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new ident object, children of #idmef_service_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_service_new_ident(idmef_service_t *ptr)
{
	return &ptr->ident;
}

/**
 * *idmef_service_get_ip_version:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get ip_version children of the #idmef_service_t object.
 *
 * Returns: a pointer to a uint8_t object, or NULL if the children object is not set.
 */
uint8_t *idmef_service_get_ip_version(idmef_service_t *ptr)
{
	return ptr->ip_version_is_set ? &ptr->ip_version : NULL;
}

idmef_value_t *idmef_service_get_ip_version_value(idmef_service_t *ptr)
{
	return ptr->ip_version_is_set ? idmef_value_new_uint8(ptr->ip_version) : NULL;

}

/**
 * idmef_service_set_ip_version:
 * @ptr: pointer to a #idmef_service_t object.
 * @ip_version: pointer to a #uint8_t object.
 *
 * Set @ip_version object as a children of @ptr.
 * if @ptr already contain an @ip_version object, then it is destroyed,
 * and updated to point to the provided @ip_version object.
 */

void idmef_service_set_ip_version(idmef_service_t *ptr, uint8_t ip_version)
{
	ptr->ip_version = ip_version;
	ptr->ip_version_is_set = 1;
}

/**
 * idmef_service_new_ip_version:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new ip_version object, children of #idmef_service_t.
 * If @ptr already contain a #uint8_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint8_t *idmef_service_new_ip_version(idmef_service_t *ptr)
{
	ptr->ip_version_is_set = 1;

	return &ptr->ip_version;
}

/**
 * *idmef_service_get_name:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get name children of the #idmef_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_service_get_name(idmef_service_t *ptr)
{
	return ptr->name;
}

idmef_value_t *idmef_service_get_name_value(idmef_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->name )
		return NULL;


	value = idmef_value_new_string(ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_service_set_name:
 * @ptr: pointer to a #idmef_service_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_service_set_name(idmef_service_t *ptr, prelude_string_t *name)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);

	ptr->name = name;
}

/**
 * idmef_service_new_name:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new name object, children of #idmef_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_service_new_name(idmef_service_t *ptr)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);
		
	ptr->name = prelude_string_new();

	return ptr->name;
}

/**
 * *idmef_service_get_port:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get port children of the #idmef_service_t object.
 *
 * Returns: a pointer to a uint16_t object, or NULL if the children object is not set.
 */
uint16_t *idmef_service_get_port(idmef_service_t *ptr)
{
	return ptr->port_is_set ? &ptr->port : NULL;
}

idmef_value_t *idmef_service_get_port_value(idmef_service_t *ptr)
{
	return ptr->port_is_set ? idmef_value_new_uint16(ptr->port) : NULL;

}

/**
 * idmef_service_set_port:
 * @ptr: pointer to a #idmef_service_t object.
 * @port: pointer to a #uint16_t object.
 *
 * Set @port object as a children of @ptr.
 * if @ptr already contain an @port object, then it is destroyed,
 * and updated to point to the provided @port object.
 */

void idmef_service_set_port(idmef_service_t *ptr, uint16_t port)
{
	ptr->port = port;
	ptr->port_is_set = 1;
}

/**
 * idmef_service_new_port:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new port object, children of #idmef_service_t.
 * If @ptr already contain a #uint16_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint16_t *idmef_service_new_port(idmef_service_t *ptr)
{
	ptr->port_is_set = 1;

	return &ptr->port;
}

/**
 * *idmef_service_get_iana_protocol_number:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get iana_protocol_number children of the #idmef_service_t object.
 *
 * Returns: a pointer to a uint8_t object, or NULL if the children object is not set.
 */
uint8_t *idmef_service_get_iana_protocol_number(idmef_service_t *ptr)
{
	return ptr->iana_protocol_number_is_set ? &ptr->iana_protocol_number : NULL;
}

idmef_value_t *idmef_service_get_iana_protocol_number_value(idmef_service_t *ptr)
{
	return ptr->iana_protocol_number_is_set ? idmef_value_new_uint8(ptr->iana_protocol_number) : NULL;

}

/**
 * idmef_service_set_iana_protocol_number:
 * @ptr: pointer to a #idmef_service_t object.
 * @iana_protocol_number: pointer to a #uint8_t object.
 *
 * Set @iana_protocol_number object as a children of @ptr.
 * if @ptr already contain an @iana_protocol_number object, then it is destroyed,
 * and updated to point to the provided @iana_protocol_number object.
 */

void idmef_service_set_iana_protocol_number(idmef_service_t *ptr, uint8_t iana_protocol_number)
{
	ptr->iana_protocol_number = iana_protocol_number;
	ptr->iana_protocol_number_is_set = 1;
}

/**
 * idmef_service_new_iana_protocol_number:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new iana_protocol_number object, children of #idmef_service_t.
 * If @ptr already contain a #uint8_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint8_t *idmef_service_new_iana_protocol_number(idmef_service_t *ptr)
{
	ptr->iana_protocol_number_is_set = 1;

	return &ptr->iana_protocol_number;
}

/**
 * *idmef_service_get_iana_protocol_name:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get iana_protocol_name children of the #idmef_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_service_get_iana_protocol_name(idmef_service_t *ptr)
{
	return ptr->iana_protocol_name;
}

idmef_value_t *idmef_service_get_iana_protocol_name_value(idmef_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->iana_protocol_name )
		return NULL;


	value = idmef_value_new_string(ptr->iana_protocol_name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_service_set_iana_protocol_name:
 * @ptr: pointer to a #idmef_service_t object.
 * @iana_protocol_name: pointer to a #prelude_string_t object.
 *
 * Set @iana_protocol_name object as a children of @ptr.
 * if @ptr already contain an @iana_protocol_name object, then it is destroyed,
 * and updated to point to the provided @iana_protocol_name object.
 */

void idmef_service_set_iana_protocol_name(idmef_service_t *ptr, prelude_string_t *iana_protocol_name)
{
	if ( ptr->iana_protocol_name )
		prelude_string_destroy(ptr->iana_protocol_name);

	ptr->iana_protocol_name = iana_protocol_name;
}

/**
 * idmef_service_new_iana_protocol_name:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new iana_protocol_name object, children of #idmef_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_service_new_iana_protocol_name(idmef_service_t *ptr)
{
	if ( ptr->iana_protocol_name )
		prelude_string_destroy(ptr->iana_protocol_name);
		
	ptr->iana_protocol_name = prelude_string_new();

	return ptr->iana_protocol_name;
}

/**
 * *idmef_service_get_portlist:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get portlist children of the #idmef_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_service_get_portlist(idmef_service_t *ptr)
{
	return ptr->portlist;
}

idmef_value_t *idmef_service_get_portlist_value(idmef_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->portlist )
		return NULL;


	value = idmef_value_new_string(ptr->portlist);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_service_set_portlist:
 * @ptr: pointer to a #idmef_service_t object.
 * @portlist: pointer to a #prelude_string_t object.
 *
 * Set @portlist object as a children of @ptr.
 * if @ptr already contain an @portlist object, then it is destroyed,
 * and updated to point to the provided @portlist object.
 */

void idmef_service_set_portlist(idmef_service_t *ptr, prelude_string_t *portlist)
{
	if ( ptr->portlist )
		prelude_string_destroy(ptr->portlist);

	ptr->portlist = portlist;
}

/**
 * idmef_service_new_portlist:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new portlist object, children of #idmef_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_service_new_portlist(idmef_service_t *ptr)
{
	if ( ptr->portlist )
		prelude_string_destroy(ptr->portlist);
		
	ptr->portlist = prelude_string_new();

	return ptr->portlist;
}

/**
 * *idmef_service_get_protocol:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Get protocol children of the #idmef_service_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_service_get_protocol(idmef_service_t *ptr)
{
	return ptr->protocol;
}

idmef_value_t *idmef_service_get_protocol_value(idmef_service_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->protocol )
		return NULL;


	value = idmef_value_new_string(ptr->protocol);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_service_set_protocol:
 * @ptr: pointer to a #idmef_service_t object.
 * @protocol: pointer to a #prelude_string_t object.
 *
 * Set @protocol object as a children of @ptr.
 * if @ptr already contain an @protocol object, then it is destroyed,
 * and updated to point to the provided @protocol object.
 */

void idmef_service_set_protocol(idmef_service_t *ptr, prelude_string_t *protocol)
{
	if ( ptr->protocol )
		prelude_string_destroy(ptr->protocol);

	ptr->protocol = protocol;
}

/**
 * idmef_service_new_protocol:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new protocol object, children of #idmef_service_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_service_new_protocol(idmef_service_t *ptr)
{
	if ( ptr->protocol )
		prelude_string_destroy(ptr->protocol);
		
	ptr->protocol = prelude_string_new();

	return ptr->protocol;
}

/** 
 * idmef_service_get_type:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Access the type children of @ptr.
 *
 * Returns: a pointer to the #idmef_service_type_t children, or NULL if it is not set.
 */
idmef_service_type_t idmef_service_get_type(idmef_service_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_service_get_type_value(idmef_service_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_SERVICE_TYPE, ptr->type);
}

/** 
 * idmef_service_get_web_service:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Access the web_service children of @ptr.
 *
 * Returns: a pointer to the #idmef_web_service_t children, or NULL if it is not set.
 */
idmef_web_service_t *idmef_service_get_web_service(idmef_service_t *ptr)
{
	return (ptr->type == IDMEF_SERVICE_TYPE_WEB) ? ptr->specific.web_service : NULL;
}

/**
 * idmef_service_set_web_service:
 * @ptr: pointer to a #idmef_service_t object.
 * @web_service: pointer to a #idmef_web_service_t object.
 *
 * Set @web_service object as a children of @ptr.
 * if @ptr already contain a @web_service object, then it is destroyed,
 * and updated to point to the provided @web_service object.
 */
void idmef_service_set_web_service(idmef_service_t *ptr, idmef_web_service_t *web_service)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_web_service_destroy(ptr->specific.web_service);
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmp_service_destroy(ptr->specific.snmp_service);
			break;

		default:
			break;
	}

	ptr->specific.web_service = web_service;
	ptr->type = IDMEF_SERVICE_TYPE_WEB;
}

idmef_value_t *idmef_service_get_web_service_value(idmef_service_t *ptr)
{
	return ((ptr->type == IDMEF_SERVICE_TYPE_WEB) ?
		idmef_value_new_object(ptr->specific.web_service, IDMEF_OBJECT_TYPE_WEB_SERVICE) :
		NULL);
}

/**
 * idmef_service_new_web_service:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new web_service object, children of #idmef_service_t.
 * If @ptr already contain a #idmef_web_service_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_web_service_t *idmef_service_new_web_service(idmef_service_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			return ptr->specific.web_service;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmp_service_destroy(ptr->specific.snmp_service);
			break;

		default:
			break;
	}

	ptr->specific.web_service = idmef_web_service_new();
	ptr->type = IDMEF_SERVICE_TYPE_WEB;

	return ptr->specific.web_service;
}

/** 
 * idmef_service_get_snmp_service:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Access the snmp_service children of @ptr.
 *
 * Returns: a pointer to the #idmef_snmp_service_t children, or NULL if it is not set.
 */
idmef_snmp_service_t *idmef_service_get_snmp_service(idmef_service_t *ptr)
{
	return (ptr->type == IDMEF_SERVICE_TYPE_SNMP) ? ptr->specific.snmp_service : NULL;
}

/**
 * idmef_service_set_snmp_service:
 * @ptr: pointer to a #idmef_service_t object.
 * @snmp_service: pointer to a #idmef_snmp_service_t object.
 *
 * Set @snmp_service object as a children of @ptr.
 * if @ptr already contain a @snmp_service object, then it is destroyed,
 * and updated to point to the provided @snmp_service object.
 */
void idmef_service_set_snmp_service(idmef_service_t *ptr, idmef_snmp_service_t *snmp_service)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_web_service_destroy(ptr->specific.web_service);
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmp_service_destroy(ptr->specific.snmp_service);
			break;

		default:
			break;
	}

	ptr->specific.snmp_service = snmp_service;
	ptr->type = IDMEF_SERVICE_TYPE_SNMP;
}

idmef_value_t *idmef_service_get_snmp_service_value(idmef_service_t *ptr)
{
	return ((ptr->type == IDMEF_SERVICE_TYPE_SNMP) ?
		idmef_value_new_object(ptr->specific.snmp_service, IDMEF_OBJECT_TYPE_SNMP_SERVICE) :
		NULL);
}

/**
 * idmef_service_new_snmp_service:
 * @ptr: pointer to a #idmef_service_t object.
 *
 * Create a new snmp_service object, children of #idmef_service_t.
 * If @ptr already contain a #idmef_snmp_service_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_snmp_service_t *idmef_service_new_snmp_service(idmef_service_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_web_service_destroy(ptr->specific.web_service);
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			return ptr->specific.snmp_service;

		default:
			break;
	}

	ptr->specific.snmp_service = idmef_snmp_service_new();
	ptr->type = IDMEF_SERVICE_TYPE_SNMP;

	return ptr->specific.snmp_service;
}

/**
 * idmef_node_new:
 * 
 * Create a new #idmef_node_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_node_t *idmef_node_new(void)
{
	idmef_node_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->address_list);
    

	return ret;

}

/**
 * idmef_node_ref:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_node_t *idmef_node_ref(idmef_node_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_node_get_child(void *p, idmef_child_t child)
{
	idmef_node_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_node_get_ident_value(ptr);

		case 1:
			return idmef_node_get_category_value(ptr);

		case 2:
			return idmef_node_get_location_value(ptr);

		case 3:
			return idmef_node_get_name_value(ptr);

		case 4:
			return &ptr->address_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_node_new_child(void *p, idmef_child_t child, int n)
{
	idmef_node_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_node_new_ident(ptr);

		case 1:
			return idmef_node_new_category(ptr);

		case 2:
			return idmef_node_new_location(ptr);

		case 3:
			return idmef_node_new_name(ptr);

		case 4: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_node_new_address(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->address_list) {
			    		entry = prelude_list_entry(tmp, idmef_address_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_node_new_address(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_node_destroy_internal(idmef_node_t *ptr)
{

	if ( ptr->location ) {
		prelude_string_destroy(ptr->location);
		ptr->location = NULL;
	}

	if ( ptr->name ) {
		prelude_string_destroy(ptr->name);
		ptr->name = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_address_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->address_list) {
			entry = prelude_list_entry(tmp, idmef_address_t, list);
			prelude_list_del(&entry->list);
			idmef_address_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_node_destroy:
 * @ptr: pointer to a #idmef_node_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_node_destroy(idmef_node_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_node_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_node_get_ident:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Get ident children of the #idmef_node_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_node_get_ident(idmef_node_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_node_get_ident_value(idmef_node_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_node_set_ident:
 * @ptr: pointer to a #idmef_node_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_node_set_ident(idmef_node_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_node_new_ident:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Create a new ident object, children of #idmef_node_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_node_new_ident(idmef_node_t *ptr)
{
	return &ptr->ident;
}

/**
 * idmef_node_get_category:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Get category children of the #idmef_node_t object.
 *
 * Returns: a pointer to a idmef_node_category_t object, or NULL if the children object is not set.
 */
idmef_node_category_t idmef_node_get_category(idmef_node_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_node_get_category_value(idmef_node_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_NODE_CATEGORY, ptr->category);

}

/**
 * idmef_node_set_category:
 * @ptr: pointer to a #idmef_node_t object.
 * @category: pointer to a #idmef_node_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void idmef_node_set_category(idmef_node_t *ptr, idmef_node_category_t category)
{
	ptr->category = category;
}

/**
 * idmef_node_new_category:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Create a new category object, children of #idmef_node_t.
 * If @ptr already contain a #idmef_node_category_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_node_category_t *idmef_node_new_category(idmef_node_t *ptr)
{
	return &ptr->category;
}

/**
 * *idmef_node_get_location:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Get location children of the #idmef_node_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_node_get_location(idmef_node_t *ptr)
{
	return ptr->location;
}

idmef_value_t *idmef_node_get_location_value(idmef_node_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->location )
		return NULL;


	value = idmef_value_new_string(ptr->location);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_node_set_location:
 * @ptr: pointer to a #idmef_node_t object.
 * @location: pointer to a #prelude_string_t object.
 *
 * Set @location object as a children of @ptr.
 * if @ptr already contain an @location object, then it is destroyed,
 * and updated to point to the provided @location object.
 */

void idmef_node_set_location(idmef_node_t *ptr, prelude_string_t *location)
{
	if ( ptr->location )
		prelude_string_destroy(ptr->location);

	ptr->location = location;
}

/**
 * idmef_node_new_location:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Create a new location object, children of #idmef_node_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_node_new_location(idmef_node_t *ptr)
{
	if ( ptr->location )
		prelude_string_destroy(ptr->location);
		
	ptr->location = prelude_string_new();

	return ptr->location;
}

/**
 * *idmef_node_get_name:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Get name children of the #idmef_node_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_node_get_name(idmef_node_t *ptr)
{
	return ptr->name;
}

idmef_value_t *idmef_node_get_name_value(idmef_node_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->name )
		return NULL;


	value = idmef_value_new_string(ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_node_set_name:
 * @ptr: pointer to a #idmef_node_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_node_set_name(idmef_node_t *ptr, prelude_string_t *name)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);

	ptr->name = name;
}

/**
 * idmef_node_new_name:
 * @ptr: pointer to a #idmef_node_t object.
 *
 * Create a new name object, children of #idmef_node_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_node_new_name(idmef_node_t *ptr)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);
		
	ptr->name = prelude_string_new();

	return ptr->name;
}

/**
 * idmef_node_get_next_address:
 * @ptr: pointer to a #idmef_node_t object.
 * @object: pointer to a #idmef_address_t object.
 *
 * Get the next #idmef_address_t object listed in @ptr.
 * When iterating over the idmef_address_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_address_t object.
 * 
 * Returns: the next #idmef_address_t in the list.
 */
idmef_address_t *idmef_node_get_next_address(idmef_node_t *ptr, idmef_address_t *object)
{
    	return prelude_list_get_next(object, &ptr->address_list, idmef_address_t, list);
}

/**
 * idmef_node_set_address:
 * @ptr: pointer to a #idmef_node_t object.
 * @object: pointer to a #idmef_address_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_address_t object.
 */
void idmef_node_set_address(idmef_node_t *ptr, idmef_address_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->address_list);
}

/**
 * idmef_node_new_HASH(0x8024ce84):
 * @ptr: pointer to a #idmef_node_t object.
 * 
 * Create a new HASH(0x8024ce84) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_address_t object.
 * 
 * Returns: a pointer to the created #idmef_address_t object, or NULL if an error occured.
 */
idmef_address_t *idmef_node_new_address(idmef_node_t *ptr)
{
	idmef_address_t *object;
	
	object = idmef_address_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->address_list);
	
	return object;
}

idmef_value_t *idmef_node_get_address_value(idmef_node_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_address_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->address_list) {
		entry = prelude_list_entry(tmp, idmef_address_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ADDRESS);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_source_new:
 * 
 * Create a new #idmef_source_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_source_t *idmef_source_new(void)
{
	idmef_source_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_source_ref:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_source_t *idmef_source_ref(idmef_source_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_source_get_child(void *p, idmef_child_t child)
{
	idmef_source_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_source_get_ident_value(ptr);

		case 1:
			return idmef_source_get_spoofed_value(ptr);

		case 2:
			return idmef_source_get_interface_value(ptr);

		case 3:
			return ptr->node;

		case 4:
			return ptr->user;

		case 5:
			return ptr->process;

		case 6:
			return ptr->service;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_source_new_child(void *p, idmef_child_t child, int n)
{
	idmef_source_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_source_new_ident(ptr);

		case 1:
			return idmef_source_new_spoofed(ptr);

		case 2:
			return idmef_source_new_interface(ptr);

		case 3:
			return idmef_source_new_node(ptr);

		case 4:
			return idmef_source_new_user(ptr);

		case 5:
			return idmef_source_new_process(ptr);

		case 6:
			return idmef_source_new_service(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_source_destroy_internal(idmef_source_t *ptr)
{

	if ( ptr->interface ) {
		prelude_string_destroy(ptr->interface);
		ptr->interface = NULL;
	}

	if ( ptr->node ) {
		idmef_node_destroy(ptr->node);
		ptr->node = NULL;
	}

	if ( ptr->user ) {
		idmef_user_destroy(ptr->user);
		ptr->user = NULL;
	}

	if ( ptr->process ) {
		idmef_process_destroy(ptr->process);
		ptr->process = NULL;
	}

	if ( ptr->service ) {
		idmef_service_destroy(ptr->service);
		ptr->service = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_source_destroy:
 * @ptr: pointer to a #idmef_source_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_source_destroy(idmef_source_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_source_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_source_get_ident:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Get ident children of the #idmef_source_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_source_get_ident(idmef_source_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_source_get_ident_value(idmef_source_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_source_set_ident:
 * @ptr: pointer to a #idmef_source_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_source_set_ident(idmef_source_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_source_new_ident:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Create a new ident object, children of #idmef_source_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_source_new_ident(idmef_source_t *ptr)
{
	return &ptr->ident;
}

/**
 * idmef_source_get_spoofed:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Get spoofed children of the #idmef_source_t object.
 *
 * Returns: a pointer to a idmef_source_spoofed_t object, or NULL if the children object is not set.
 */
idmef_source_spoofed_t idmef_source_get_spoofed(idmef_source_t *ptr)
{
	return ptr->spoofed;
}

idmef_value_t *idmef_source_get_spoofed_value(idmef_source_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_SOURCE_SPOOFED, ptr->spoofed);

}

/**
 * idmef_source_set_spoofed:
 * @ptr: pointer to a #idmef_source_t object.
 * @spoofed: pointer to a #idmef_source_spoofed_t object.
 *
 * Set @spoofed object as a children of @ptr.
 * if @ptr already contain an @spoofed object, then it is destroyed,
 * and updated to point to the provided @spoofed object.
 */

void idmef_source_set_spoofed(idmef_source_t *ptr, idmef_source_spoofed_t spoofed)
{
	ptr->spoofed = spoofed;
}

/**
 * idmef_source_new_spoofed:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Create a new spoofed object, children of #idmef_source_t.
 * If @ptr already contain a #idmef_source_spoofed_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_source_spoofed_t *idmef_source_new_spoofed(idmef_source_t *ptr)
{
	return &ptr->spoofed;
}

/**
 * *idmef_source_get_interface:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Get interface children of the #idmef_source_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_source_get_interface(idmef_source_t *ptr)
{
	return ptr->interface;
}

idmef_value_t *idmef_source_get_interface_value(idmef_source_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->interface )
		return NULL;


	value = idmef_value_new_string(ptr->interface);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_source_set_interface:
 * @ptr: pointer to a #idmef_source_t object.
 * @interface: pointer to a #prelude_string_t object.
 *
 * Set @interface object as a children of @ptr.
 * if @ptr already contain an @interface object, then it is destroyed,
 * and updated to point to the provided @interface object.
 */

void idmef_source_set_interface(idmef_source_t *ptr, prelude_string_t *interface)
{
	if ( ptr->interface )
		prelude_string_destroy(ptr->interface);

	ptr->interface = interface;
}

/**
 * idmef_source_new_interface:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Create a new interface object, children of #idmef_source_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_source_new_interface(idmef_source_t *ptr)
{
	if ( ptr->interface )
		prelude_string_destroy(ptr->interface);
		
	ptr->interface = prelude_string_new();

	return ptr->interface;
}

/**
 * *idmef_source_get_node:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Get node children of the #idmef_source_t object.
 *
 * Returns: a pointer to a idmef_node_t object, or NULL if the children object is not set.
 */
idmef_node_t *idmef_source_get_node(idmef_source_t *ptr)
{
	return ptr->node;
}

idmef_value_t *idmef_source_get_node_value(idmef_source_t *ptr)
{
	if ( ! ptr->node )
		return NULL;

	return idmef_value_new_object(ptr->node, IDMEF_OBJECT_TYPE_NODE);
}

/**
 * idmef_source_set_node:
 * @ptr: pointer to a #idmef_source_t object.
 * @node: pointer to a #idmef_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void idmef_source_set_node(idmef_source_t *ptr, idmef_node_t *node)
{
	if ( ptr->node )
		idmef_node_destroy(ptr->node);

	ptr->node = node;
}

/**
 * idmef_source_new_node:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Create a new node object, children of #idmef_source_t.
 * If @ptr already contain a #idmef_node_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_node_t *idmef_source_new_node(idmef_source_t *ptr)
{
	if ( ! ptr->node )
		ptr->node = idmef_node_new();

	return ptr->node;
}

/**
 * *idmef_source_get_user:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Get user children of the #idmef_source_t object.
 *
 * Returns: a pointer to a idmef_user_t object, or NULL if the children object is not set.
 */
idmef_user_t *idmef_source_get_user(idmef_source_t *ptr)
{
	return ptr->user;
}

idmef_value_t *idmef_source_get_user_value(idmef_source_t *ptr)
{
	if ( ! ptr->user )
		return NULL;

	return idmef_value_new_object(ptr->user, IDMEF_OBJECT_TYPE_USER);
}

/**
 * idmef_source_set_user:
 * @ptr: pointer to a #idmef_source_t object.
 * @user: pointer to a #idmef_user_t object.
 *
 * Set @user object as a children of @ptr.
 * if @ptr already contain an @user object, then it is destroyed,
 * and updated to point to the provided @user object.
 */

void idmef_source_set_user(idmef_source_t *ptr, idmef_user_t *user)
{
	if ( ptr->user )
		idmef_user_destroy(ptr->user);

	ptr->user = user;
}

/**
 * idmef_source_new_user:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Create a new user object, children of #idmef_source_t.
 * If @ptr already contain a #idmef_user_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_user_t *idmef_source_new_user(idmef_source_t *ptr)
{
	if ( ! ptr->user )
		ptr->user = idmef_user_new();

	return ptr->user;
}

/**
 * *idmef_source_get_process:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Get process children of the #idmef_source_t object.
 *
 * Returns: a pointer to a idmef_process_t object, or NULL if the children object is not set.
 */
idmef_process_t *idmef_source_get_process(idmef_source_t *ptr)
{
	return ptr->process;
}

idmef_value_t *idmef_source_get_process_value(idmef_source_t *ptr)
{
	if ( ! ptr->process )
		return NULL;

	return idmef_value_new_object(ptr->process, IDMEF_OBJECT_TYPE_PROCESS);
}

/**
 * idmef_source_set_process:
 * @ptr: pointer to a #idmef_source_t object.
 * @process: pointer to a #idmef_process_t object.
 *
 * Set @process object as a children of @ptr.
 * if @ptr already contain an @process object, then it is destroyed,
 * and updated to point to the provided @process object.
 */

void idmef_source_set_process(idmef_source_t *ptr, idmef_process_t *process)
{
	if ( ptr->process )
		idmef_process_destroy(ptr->process);

	ptr->process = process;
}

/**
 * idmef_source_new_process:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Create a new process object, children of #idmef_source_t.
 * If @ptr already contain a #idmef_process_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_process_t *idmef_source_new_process(idmef_source_t *ptr)
{
	if ( ! ptr->process )
		ptr->process = idmef_process_new();

	return ptr->process;
}

/**
 * *idmef_source_get_service:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Get service children of the #idmef_source_t object.
 *
 * Returns: a pointer to a idmef_service_t object, or NULL if the children object is not set.
 */
idmef_service_t *idmef_source_get_service(idmef_source_t *ptr)
{
	return ptr->service;
}

idmef_value_t *idmef_source_get_service_value(idmef_source_t *ptr)
{
	if ( ! ptr->service )
		return NULL;

	return idmef_value_new_object(ptr->service, IDMEF_OBJECT_TYPE_SERVICE);
}

/**
 * idmef_source_set_service:
 * @ptr: pointer to a #idmef_source_t object.
 * @service: pointer to a #idmef_service_t object.
 *
 * Set @service object as a children of @ptr.
 * if @ptr already contain an @service object, then it is destroyed,
 * and updated to point to the provided @service object.
 */

void idmef_source_set_service(idmef_source_t *ptr, idmef_service_t *service)
{
	if ( ptr->service )
		idmef_service_destroy(ptr->service);

	ptr->service = service;
}

/**
 * idmef_source_new_service:
 * @ptr: pointer to a #idmef_source_t object.
 *
 * Create a new service object, children of #idmef_source_t.
 * If @ptr already contain a #idmef_service_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_service_t *idmef_source_new_service(idmef_source_t *ptr)
{
	if ( ! ptr->service )
		ptr->service = idmef_service_new();

	return ptr->service;
}

/**
 * idmef_file_access_new:
 * 
 * Create a new #idmef_file_access_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_file_access_t *idmef_file_access_new(void)
{
	idmef_file_access_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->permission_list);
    

	return ret;

}

/**
 * idmef_file_access_ref:
 * @ptr: pointer to a #idmef_file_access_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_file_access_t *idmef_file_access_ref(idmef_file_access_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_file_access_get_child(void *p, idmef_child_t child)
{
	idmef_file_access_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return &ptr->user_id;

		case 1:
			return &ptr->permission_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_file_access_new_child(void *p, idmef_child_t child, int n)
{
	idmef_file_access_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_file_access_new_user_id(ptr);

		case 1: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_file_access_new_permission(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->permission_list) {
			    		entry = prelude_list_entry(tmp, prelude_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_file_access_new_permission(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_file_access_destroy_internal(idmef_file_access_t *ptr)
{

	idmef_user_id_destroy_internal(&ptr->user_id);

	{
		prelude_list_t *n, *tmp;
		prelude_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->permission_list) {
			entry = prelude_list_entry(tmp, prelude_string_t, list);
			prelude_list_del(&entry->list);
			prelude_string_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_file_access_destroy:
 * @ptr: pointer to a #idmef_file_access_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_file_access_destroy(idmef_file_access_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_file_access_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_file_access_get_user_id:
 * @ptr: pointer to a #idmef_file_access_t object.
 *
 * Get user_id children of the #idmef_file_access_t object.
 *
 * Returns: a pointer to a idmef_user_id_t object, or NULL if the children object is not set.
 */
idmef_user_id_t *idmef_file_access_get_user_id(idmef_file_access_t *ptr)
{
	return &ptr->user_id;
}

idmef_value_t *idmef_file_access_get_user_id_value(idmef_file_access_t *ptr)
{
	return idmef_value_new_object(&ptr->user_id, IDMEF_OBJECT_TYPE_USER_ID);
}

/**
 * idmef_file_access_set_user_id:
 * @ptr: pointer to a #idmef_file_access_t object.
 * @user_id: pointer to a #idmef_user_id_t object.
 *
 * Set @user_id object as a children of @ptr.
 * if @ptr already contain an @user_id object, then it is destroyed,
 * and updated to point to the provided @user_id object.
 */

void idmef_file_access_set_user_id(idmef_file_access_t *ptr, idmef_user_id_t *user_id)
{
	idmef_user_id_destroy_internal(&ptr->user_id);
	memcpy(&ptr->user_id, user_id, sizeof (ptr->user_id));
	free(user_id);
}

/**
 * idmef_file_access_new_user_id:
 * @ptr: pointer to a #idmef_file_access_t object.
 *
 * Create a new user_id object, children of #idmef_file_access_t.
 * If @ptr already contain a #idmef_user_id_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_user_id_t *idmef_file_access_new_user_id(idmef_file_access_t *ptr)
{
	return &ptr->user_id;
}

/**
 * idmef_file_access_get_next_permission:
 * @ptr: pointer to a #idmef_file_access_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Get the next #prelude_string_t object listed in @ptr.
 * When iterating over the prelude_string_t object listed in @ptr,
 * @object should be set to the latest returned #prelude_string_t object.
 * 
 * Returns: the next #prelude_string_t in the list.
 */
prelude_string_t *idmef_file_access_get_next_permission(idmef_file_access_t *ptr, prelude_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->permission_list, prelude_string_t, list);
}

/**
 * idmef_file_access_set_permission:
 * @ptr: pointer to a #idmef_file_access_t object.
 * @object: pointer to a #prelude_string_t object.
 *
 * Add @object to the tail of @ptr list of #prelude_string_t object.
 */
void idmef_file_access_set_permission(idmef_file_access_t *ptr, prelude_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->permission_list);
}

/**
 * idmef_file_access_new_HASH(0x8024ef40):
 * @ptr: pointer to a #idmef_file_access_t object.
 * 
 * Create a new HASH(0x8024ef40) children of @ptr,
 * and add it to the tail of @ptr list of #prelude_string_t object.
 * 
 * Returns: a pointer to the created #prelude_string_t object, or NULL if an error occured.
 */
prelude_string_t *idmef_file_access_new_permission(idmef_file_access_t *ptr)
{
	prelude_string_t *object;
	
	object = prelude_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->permission_list);
	
	return object;
}

idmef_value_t *idmef_file_access_get_permission_value(idmef_file_access_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	prelude_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->permission_list) {
		entry = prelude_list_entry(tmp, prelude_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_inode_new:
 * 
 * Create a new #idmef_inode_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_inode_t *idmef_inode_new(void)
{
	idmef_inode_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_inode_ref:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_inode_t *idmef_inode_ref(idmef_inode_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_inode_get_child(void *p, idmef_child_t child)
{
	idmef_inode_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_inode_get_change_time_value(ptr);

		case 1:
			return idmef_inode_get_number_value(ptr);

		case 2:
			return idmef_inode_get_major_device_value(ptr);

		case 3:
			return idmef_inode_get_minor_device_value(ptr);

		case 4:
			return idmef_inode_get_c_major_device_value(ptr);

		case 5:
			return idmef_inode_get_c_minor_device_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_inode_new_child(void *p, idmef_child_t child, int n)
{
	idmef_inode_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_inode_new_change_time(ptr);

		case 1:
			return idmef_inode_new_number(ptr);

		case 2:
			return idmef_inode_new_major_device(ptr);

		case 3:
			return idmef_inode_new_minor_device(ptr);

		case 4:
			return idmef_inode_new_c_major_device(ptr);

		case 5:
			return idmef_inode_new_c_minor_device(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_inode_destroy_internal(idmef_inode_t *ptr)
{

	if ( ptr->change_time ) {
		idmef_time_destroy(ptr->change_time);
		ptr->change_time = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_inode_destroy:
 * @ptr: pointer to a #idmef_inode_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_inode_destroy(idmef_inode_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_inode_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_inode_get_change_time:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Get change_time children of the #idmef_inode_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_inode_get_change_time(idmef_inode_t *ptr)
{
	return ptr->change_time;
}

idmef_value_t *idmef_inode_get_change_time_value(idmef_inode_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->change_time )
		return NULL;


	value = idmef_value_new_time(ptr->change_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_inode_set_change_time:
 * @ptr: pointer to a #idmef_inode_t object.
 * @change_time: pointer to a #idmef_time_t object.
 *
 * Set @change_time object as a children of @ptr.
 * if @ptr already contain an @change_time object, then it is destroyed,
 * and updated to point to the provided @change_time object.
 */

void idmef_inode_set_change_time(idmef_inode_t *ptr, idmef_time_t *change_time)
{
	if ( ptr->change_time )
		idmef_time_destroy(ptr->change_time);

	ptr->change_time = change_time;
}

/**
 * idmef_inode_new_change_time:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Create a new change_time object, children of #idmef_inode_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_inode_new_change_time(idmef_inode_t *ptr)
{
	if ( ptr->change_time )
		idmef_time_destroy(ptr->change_time);
		
	ptr->change_time = idmef_time_new();

	return ptr->change_time;
}

/**
 * *idmef_inode_get_number:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Get number children of the #idmef_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_inode_get_number(idmef_inode_t *ptr)
{
	return ptr->number_is_set ? &ptr->number : NULL;
}

idmef_value_t *idmef_inode_get_number_value(idmef_inode_t *ptr)
{
	return ptr->number_is_set ? idmef_value_new_uint32(ptr->number) : NULL;

}

/**
 * idmef_inode_set_number:
 * @ptr: pointer to a #idmef_inode_t object.
 * @number: pointer to a #uint32_t object.
 *
 * Set @number object as a children of @ptr.
 * if @ptr already contain an @number object, then it is destroyed,
 * and updated to point to the provided @number object.
 */

void idmef_inode_set_number(idmef_inode_t *ptr, uint32_t number)
{
	ptr->number = number;
	ptr->number_is_set = 1;
}

/**
 * idmef_inode_new_number:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Create a new number object, children of #idmef_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_inode_new_number(idmef_inode_t *ptr)
{
	ptr->number_is_set = 1;

	return &ptr->number;
}

/**
 * *idmef_inode_get_major_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Get major_device children of the #idmef_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_inode_get_major_device(idmef_inode_t *ptr)
{
	return ptr->major_device_is_set ? &ptr->major_device : NULL;
}

idmef_value_t *idmef_inode_get_major_device_value(idmef_inode_t *ptr)
{
	return ptr->major_device_is_set ? idmef_value_new_uint32(ptr->major_device) : NULL;

}

/**
 * idmef_inode_set_major_device:
 * @ptr: pointer to a #idmef_inode_t object.
 * @major_device: pointer to a #uint32_t object.
 *
 * Set @major_device object as a children of @ptr.
 * if @ptr already contain an @major_device object, then it is destroyed,
 * and updated to point to the provided @major_device object.
 */

void idmef_inode_set_major_device(idmef_inode_t *ptr, uint32_t major_device)
{
	ptr->major_device = major_device;
	ptr->major_device_is_set = 1;
}

/**
 * idmef_inode_new_major_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Create a new major_device object, children of #idmef_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_inode_new_major_device(idmef_inode_t *ptr)
{
	ptr->major_device_is_set = 1;

	return &ptr->major_device;
}

/**
 * *idmef_inode_get_minor_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Get minor_device children of the #idmef_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_inode_get_minor_device(idmef_inode_t *ptr)
{
	return ptr->minor_device_is_set ? &ptr->minor_device : NULL;
}

idmef_value_t *idmef_inode_get_minor_device_value(idmef_inode_t *ptr)
{
	return ptr->minor_device_is_set ? idmef_value_new_uint32(ptr->minor_device) : NULL;

}

/**
 * idmef_inode_set_minor_device:
 * @ptr: pointer to a #idmef_inode_t object.
 * @minor_device: pointer to a #uint32_t object.
 *
 * Set @minor_device object as a children of @ptr.
 * if @ptr already contain an @minor_device object, then it is destroyed,
 * and updated to point to the provided @minor_device object.
 */

void idmef_inode_set_minor_device(idmef_inode_t *ptr, uint32_t minor_device)
{
	ptr->minor_device = minor_device;
	ptr->minor_device_is_set = 1;
}

/**
 * idmef_inode_new_minor_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Create a new minor_device object, children of #idmef_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_inode_new_minor_device(idmef_inode_t *ptr)
{
	ptr->minor_device_is_set = 1;

	return &ptr->minor_device;
}

/**
 * *idmef_inode_get_c_major_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Get c_major_device children of the #idmef_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_inode_get_c_major_device(idmef_inode_t *ptr)
{
	return ptr->c_major_device_is_set ? &ptr->c_major_device : NULL;
}

idmef_value_t *idmef_inode_get_c_major_device_value(idmef_inode_t *ptr)
{
	return ptr->c_major_device_is_set ? idmef_value_new_uint32(ptr->c_major_device) : NULL;

}

/**
 * idmef_inode_set_c_major_device:
 * @ptr: pointer to a #idmef_inode_t object.
 * @c_major_device: pointer to a #uint32_t object.
 *
 * Set @c_major_device object as a children of @ptr.
 * if @ptr already contain an @c_major_device object, then it is destroyed,
 * and updated to point to the provided @c_major_device object.
 */

void idmef_inode_set_c_major_device(idmef_inode_t *ptr, uint32_t c_major_device)
{
	ptr->c_major_device = c_major_device;
	ptr->c_major_device_is_set = 1;
}

/**
 * idmef_inode_new_c_major_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Create a new c_major_device object, children of #idmef_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_inode_new_c_major_device(idmef_inode_t *ptr)
{
	ptr->c_major_device_is_set = 1;

	return &ptr->c_major_device;
}

/**
 * *idmef_inode_get_c_minor_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Get c_minor_device children of the #idmef_inode_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_inode_get_c_minor_device(idmef_inode_t *ptr)
{
	return ptr->c_minor_device_is_set ? &ptr->c_minor_device : NULL;
}

idmef_value_t *idmef_inode_get_c_minor_device_value(idmef_inode_t *ptr)
{
	return ptr->c_minor_device_is_set ? idmef_value_new_uint32(ptr->c_minor_device) : NULL;

}

/**
 * idmef_inode_set_c_minor_device:
 * @ptr: pointer to a #idmef_inode_t object.
 * @c_minor_device: pointer to a #uint32_t object.
 *
 * Set @c_minor_device object as a children of @ptr.
 * if @ptr already contain an @c_minor_device object, then it is destroyed,
 * and updated to point to the provided @c_minor_device object.
 */

void idmef_inode_set_c_minor_device(idmef_inode_t *ptr, uint32_t c_minor_device)
{
	ptr->c_minor_device = c_minor_device;
	ptr->c_minor_device_is_set = 1;
}

/**
 * idmef_inode_new_c_minor_device:
 * @ptr: pointer to a #idmef_inode_t object.
 *
 * Create a new c_minor_device object, children of #idmef_inode_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_inode_new_c_minor_device(idmef_inode_t *ptr)
{
	ptr->c_minor_device_is_set = 1;

	return &ptr->c_minor_device;
}

/**
 * idmef_checksum_new:
 * 
 * Create a new #idmef_checksum_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_checksum_t *idmef_checksum_new(void)
{
	idmef_checksum_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_checksum_ref:
 * @ptr: pointer to a #idmef_checksum_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_checksum_t *idmef_checksum_ref(idmef_checksum_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_checksum_get_child(void *p, idmef_child_t child)
{
	idmef_checksum_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_checksum_get_value_value(ptr);

		case 1:
			return idmef_checksum_get_key_value(ptr);

		case 2:
			return idmef_checksum_get_algorithm_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_checksum_new_child(void *p, idmef_child_t child, int n)
{
	idmef_checksum_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_checksum_new_value(ptr);

		case 1:
			return idmef_checksum_new_key(ptr);

		case 2:
			return idmef_checksum_new_algorithm(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_checksum_destroy_internal(idmef_checksum_t *ptr)
{

	prelude_string_destroy_internal(&ptr->value);

	if ( ptr->key ) {
		prelude_string_destroy(ptr->key);
		ptr->key = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_checksum_destroy:
 * @ptr: pointer to a #idmef_checksum_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_checksum_destroy(idmef_checksum_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_checksum_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_checksum_get_value:
 * @ptr: pointer to a #idmef_checksum_t object.
 *
 * Get value children of the #idmef_checksum_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_checksum_get_value(idmef_checksum_t *ptr)
{
	return &ptr->value;
}

idmef_value_t *idmef_checksum_get_value_value(idmef_checksum_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->value);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_checksum_set_value:
 * @ptr: pointer to a #idmef_checksum_t object.
 * @value: pointer to a #prelude_string_t object.
 *
 * Set @value object as a children of @ptr.
 * if @ptr already contain an @value object, then it is destroyed,
 * and updated to point to the provided @value object.
 */

void idmef_checksum_set_value(idmef_checksum_t *ptr, prelude_string_t *value)
{
	prelude_string_destroy_internal(&ptr->value);
	memcpy(&ptr->value, value, sizeof (ptr->value));
	free(value);
}

/**
 * idmef_checksum_new_value:
 * @ptr: pointer to a #idmef_checksum_t object.
 *
 * Create a new value object, children of #idmef_checksum_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_checksum_new_value(idmef_checksum_t *ptr)
{
	prelude_string_destroy_internal(&ptr->value);

	return &ptr->value;
}

/**
 * *idmef_checksum_get_key:
 * @ptr: pointer to a #idmef_checksum_t object.
 *
 * Get key children of the #idmef_checksum_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_checksum_get_key(idmef_checksum_t *ptr)
{
	return ptr->key;
}

idmef_value_t *idmef_checksum_get_key_value(idmef_checksum_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->key )
		return NULL;


	value = idmef_value_new_string(ptr->key);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_checksum_set_key:
 * @ptr: pointer to a #idmef_checksum_t object.
 * @key: pointer to a #prelude_string_t object.
 *
 * Set @key object as a children of @ptr.
 * if @ptr already contain an @key object, then it is destroyed,
 * and updated to point to the provided @key object.
 */

void idmef_checksum_set_key(idmef_checksum_t *ptr, prelude_string_t *key)
{
	if ( ptr->key )
		prelude_string_destroy(ptr->key);

	ptr->key = key;
}

/**
 * idmef_checksum_new_key:
 * @ptr: pointer to a #idmef_checksum_t object.
 *
 * Create a new key object, children of #idmef_checksum_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_checksum_new_key(idmef_checksum_t *ptr)
{
	if ( ptr->key )
		prelude_string_destroy(ptr->key);
		
	ptr->key = prelude_string_new();

	return ptr->key;
}

/**
 * idmef_checksum_get_algorithm:
 * @ptr: pointer to a #idmef_checksum_t object.
 *
 * Get algorithm children of the #idmef_checksum_t object.
 *
 * Returns: a pointer to a idmef_checksum_algorithm_t object, or NULL if the children object is not set.
 */
idmef_checksum_algorithm_t idmef_checksum_get_algorithm(idmef_checksum_t *ptr)
{
	return ptr->algorithm;
}

idmef_value_t *idmef_checksum_get_algorithm_value(idmef_checksum_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_CHECKSUM_ALGORITHM, ptr->algorithm);

}

/**
 * idmef_checksum_set_algorithm:
 * @ptr: pointer to a #idmef_checksum_t object.
 * @algorithm: pointer to a #idmef_checksum_algorithm_t object.
 *
 * Set @algorithm object as a children of @ptr.
 * if @ptr already contain an @algorithm object, then it is destroyed,
 * and updated to point to the provided @algorithm object.
 */

void idmef_checksum_set_algorithm(idmef_checksum_t *ptr, idmef_checksum_algorithm_t algorithm)
{
	ptr->algorithm = algorithm;
}

/**
 * idmef_checksum_new_algorithm:
 * @ptr: pointer to a #idmef_checksum_t object.
 *
 * Create a new algorithm object, children of #idmef_checksum_t.
 * If @ptr already contain a #idmef_checksum_algorithm_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_checksum_algorithm_t *idmef_checksum_new_algorithm(idmef_checksum_t *ptr)
{
	return &ptr->algorithm;
}

/**
 * idmef_file_new:
 * 
 * Create a new #idmef_file_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_file_t *idmef_file_new(void)
{
	idmef_file_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->file_access_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->linkage_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->checksum_list);
    

	return ret;

}

/**
 * idmef_file_ref:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_file_t *idmef_file_ref(idmef_file_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_file_get_child(void *p, idmef_child_t child)
{
	idmef_file_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_file_get_ident_value(ptr);

		case 1:
			return idmef_file_get_name_value(ptr);

		case 2:
			return idmef_file_get_path_value(ptr);

		case 3:
			return idmef_file_get_create_time_value(ptr);

		case 4:
			return idmef_file_get_modify_time_value(ptr);

		case 5:
			return idmef_file_get_access_time_value(ptr);

		case 6:
			return idmef_file_get_data_size_value(ptr);

		case 7:
			return idmef_file_get_disk_size_value(ptr);

		case 8:
			return &ptr->file_access_list;

		case 9:
			return &ptr->linkage_list;

		case 10:
			return ptr->inode;

		case 11:
			return &ptr->checksum_list;

		case 12:
			return idmef_file_get_category_value(ptr);

		case 13:
			return idmef_file_get_fstype_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_file_new_child(void *p, idmef_child_t child, int n)
{
	idmef_file_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_file_new_ident(ptr);

		case 1:
			return idmef_file_new_name(ptr);

		case 2:
			return idmef_file_new_path(ptr);

		case 3:
			return idmef_file_new_create_time(ptr);

		case 4:
			return idmef_file_new_modify_time(ptr);

		case 5:
			return idmef_file_new_access_time(ptr);

		case 6:
			return idmef_file_new_data_size(ptr);

		case 7:
			return idmef_file_new_disk_size(ptr);

		case 8: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_file_new_file_access(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->file_access_list) {
			    		entry = prelude_list_entry(tmp, idmef_file_access_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_file_new_file_access(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 9: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_file_new_linkage(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->linkage_list) {
			    		entry = prelude_list_entry(tmp, idmef_linkage_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_file_new_linkage(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 10:
			return idmef_file_new_inode(ptr);

		case 11: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_file_new_checksum(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->checksum_list) {
			    		entry = prelude_list_entry(tmp, idmef_checksum_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_file_new_checksum(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 12:
			return idmef_file_new_category(ptr);

		case 13:
			return idmef_file_new_fstype(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_file_destroy_internal(idmef_file_t *ptr)
{

	prelude_string_destroy_internal(&ptr->name);

	prelude_string_destroy_internal(&ptr->path);

	if ( ptr->create_time ) {
		idmef_time_destroy(ptr->create_time);
		ptr->create_time = NULL;
	}

	if ( ptr->modify_time ) {
		idmef_time_destroy(ptr->modify_time);
		ptr->modify_time = NULL;
	}

	if ( ptr->access_time ) {
		idmef_time_destroy(ptr->access_time);
		ptr->access_time = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_file_access_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->file_access_list) {
			entry = prelude_list_entry(tmp, idmef_file_access_t, list);
			prelude_list_del(&entry->list);
			idmef_file_access_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		idmef_linkage_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->linkage_list) {
			entry = prelude_list_entry(tmp, idmef_linkage_t, list);
			prelude_list_del(&entry->list);
			idmef_linkage_destroy(entry);
		}
	}

	if ( ptr->inode ) {
		idmef_inode_destroy(ptr->inode);
		ptr->inode = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_checksum_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->checksum_list) {
			entry = prelude_list_entry(tmp, idmef_checksum_t, list);
			prelude_list_del(&entry->list);
			idmef_checksum_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_file_destroy:
 * @ptr: pointer to a #idmef_file_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_file_destroy(idmef_file_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_file_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_file_get_ident:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get ident children of the #idmef_file_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_file_get_ident(idmef_file_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_file_get_ident_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_file_set_ident:
 * @ptr: pointer to a #idmef_file_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_file_set_ident(idmef_file_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_file_new_ident:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new ident object, children of #idmef_file_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_file_new_ident(idmef_file_t *ptr)
{
	return &ptr->ident;
}

/**
 * *idmef_file_get_name:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get name children of the #idmef_file_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_file_get_name(idmef_file_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_file_get_name_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_file_set_name:
 * @ptr: pointer to a #idmef_file_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_file_set_name(idmef_file_t *ptr, prelude_string_t *name)
{
	prelude_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

/**
 * idmef_file_new_name:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new name object, children of #idmef_file_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_file_new_name(idmef_file_t *ptr)
{
	prelude_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

/**
 * *idmef_file_get_path:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get path children of the #idmef_file_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_file_get_path(idmef_file_t *ptr)
{
	return &ptr->path;
}

idmef_value_t *idmef_file_get_path_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->path);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_file_set_path:
 * @ptr: pointer to a #idmef_file_t object.
 * @path: pointer to a #prelude_string_t object.
 *
 * Set @path object as a children of @ptr.
 * if @ptr already contain an @path object, then it is destroyed,
 * and updated to point to the provided @path object.
 */

void idmef_file_set_path(idmef_file_t *ptr, prelude_string_t *path)
{
	prelude_string_destroy_internal(&ptr->path);
	memcpy(&ptr->path, path, sizeof (ptr->path));
	free(path);
}

/**
 * idmef_file_new_path:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new path object, children of #idmef_file_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_file_new_path(idmef_file_t *ptr)
{
	prelude_string_destroy_internal(&ptr->path);

	return &ptr->path;
}

/**
 * *idmef_file_get_create_time:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get create_time children of the #idmef_file_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_file_get_create_time(idmef_file_t *ptr)
{
	return ptr->create_time;
}

idmef_value_t *idmef_file_get_create_time_value(idmef_file_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->create_time )
		return NULL;


	value = idmef_value_new_time(ptr->create_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_file_set_create_time:
 * @ptr: pointer to a #idmef_file_t object.
 * @create_time: pointer to a #idmef_time_t object.
 *
 * Set @create_time object as a children of @ptr.
 * if @ptr already contain an @create_time object, then it is destroyed,
 * and updated to point to the provided @create_time object.
 */

void idmef_file_set_create_time(idmef_file_t *ptr, idmef_time_t *create_time)
{
	if ( ptr->create_time )
		idmef_time_destroy(ptr->create_time);

	ptr->create_time = create_time;
}

/**
 * idmef_file_new_create_time:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new create_time object, children of #idmef_file_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_file_new_create_time(idmef_file_t *ptr)
{
	if ( ptr->create_time )
		idmef_time_destroy(ptr->create_time);
		
	ptr->create_time = idmef_time_new();

	return ptr->create_time;
}

/**
 * *idmef_file_get_modify_time:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get modify_time children of the #idmef_file_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_file_get_modify_time(idmef_file_t *ptr)
{
	return ptr->modify_time;
}

idmef_value_t *idmef_file_get_modify_time_value(idmef_file_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->modify_time )
		return NULL;


	value = idmef_value_new_time(ptr->modify_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_file_set_modify_time:
 * @ptr: pointer to a #idmef_file_t object.
 * @modify_time: pointer to a #idmef_time_t object.
 *
 * Set @modify_time object as a children of @ptr.
 * if @ptr already contain an @modify_time object, then it is destroyed,
 * and updated to point to the provided @modify_time object.
 */

void idmef_file_set_modify_time(idmef_file_t *ptr, idmef_time_t *modify_time)
{
	if ( ptr->modify_time )
		idmef_time_destroy(ptr->modify_time);

	ptr->modify_time = modify_time;
}

/**
 * idmef_file_new_modify_time:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new modify_time object, children of #idmef_file_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_file_new_modify_time(idmef_file_t *ptr)
{
	if ( ptr->modify_time )
		idmef_time_destroy(ptr->modify_time);
		
	ptr->modify_time = idmef_time_new();

	return ptr->modify_time;
}

/**
 * *idmef_file_get_access_time:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get access_time children of the #idmef_file_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_file_get_access_time(idmef_file_t *ptr)
{
	return ptr->access_time;
}

idmef_value_t *idmef_file_get_access_time_value(idmef_file_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->access_time )
		return NULL;


	value = idmef_value_new_time(ptr->access_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_file_set_access_time:
 * @ptr: pointer to a #idmef_file_t object.
 * @access_time: pointer to a #idmef_time_t object.
 *
 * Set @access_time object as a children of @ptr.
 * if @ptr already contain an @access_time object, then it is destroyed,
 * and updated to point to the provided @access_time object.
 */

void idmef_file_set_access_time(idmef_file_t *ptr, idmef_time_t *access_time)
{
	if ( ptr->access_time )
		idmef_time_destroy(ptr->access_time);

	ptr->access_time = access_time;
}

/**
 * idmef_file_new_access_time:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new access_time object, children of #idmef_file_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_file_new_access_time(idmef_file_t *ptr)
{
	if ( ptr->access_time )
		idmef_time_destroy(ptr->access_time);
		
	ptr->access_time = idmef_time_new();

	return ptr->access_time;
}

/**
 * *idmef_file_get_data_size:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get data_size children of the #idmef_file_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t *idmef_file_get_data_size(idmef_file_t *ptr)
{
	return ptr->data_size_is_set ? &ptr->data_size : NULL;
}

idmef_value_t *idmef_file_get_data_size_value(idmef_file_t *ptr)
{
	return ptr->data_size_is_set ? idmef_value_new_uint64(ptr->data_size) : NULL;

}

/**
 * idmef_file_set_data_size:
 * @ptr: pointer to a #idmef_file_t object.
 * @data_size: pointer to a #uint64_t object.
 *
 * Set @data_size object as a children of @ptr.
 * if @ptr already contain an @data_size object, then it is destroyed,
 * and updated to point to the provided @data_size object.
 */

void idmef_file_set_data_size(idmef_file_t *ptr, uint64_t data_size)
{
	ptr->data_size = data_size;
	ptr->data_size_is_set = 1;
}

/**
 * idmef_file_new_data_size:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new data_size object, children of #idmef_file_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_file_new_data_size(idmef_file_t *ptr)
{
	ptr->data_size_is_set = 1;

	return &ptr->data_size;
}

/**
 * *idmef_file_get_disk_size:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get disk_size children of the #idmef_file_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t *idmef_file_get_disk_size(idmef_file_t *ptr)
{
	return ptr->disk_size_is_set ? &ptr->disk_size : NULL;
}

idmef_value_t *idmef_file_get_disk_size_value(idmef_file_t *ptr)
{
	return ptr->disk_size_is_set ? idmef_value_new_uint64(ptr->disk_size) : NULL;

}

/**
 * idmef_file_set_disk_size:
 * @ptr: pointer to a #idmef_file_t object.
 * @disk_size: pointer to a #uint64_t object.
 *
 * Set @disk_size object as a children of @ptr.
 * if @ptr already contain an @disk_size object, then it is destroyed,
 * and updated to point to the provided @disk_size object.
 */

void idmef_file_set_disk_size(idmef_file_t *ptr, uint64_t disk_size)
{
	ptr->disk_size = disk_size;
	ptr->disk_size_is_set = 1;
}

/**
 * idmef_file_new_disk_size:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new disk_size object, children of #idmef_file_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_file_new_disk_size(idmef_file_t *ptr)
{
	ptr->disk_size_is_set = 1;

	return &ptr->disk_size;
}

/**
 * idmef_file_get_next_file_access:
 * @ptr: pointer to a #idmef_file_t object.
 * @object: pointer to a #idmef_file_access_t object.
 *
 * Get the next #idmef_file_access_t object listed in @ptr.
 * When iterating over the idmef_file_access_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_file_access_t object.
 * 
 * Returns: the next #idmef_file_access_t in the list.
 */
idmef_file_access_t *idmef_file_get_next_file_access(idmef_file_t *ptr, idmef_file_access_t *object)
{
    	return prelude_list_get_next(object, &ptr->file_access_list, idmef_file_access_t, list);
}

/**
 * idmef_file_set_file_access:
 * @ptr: pointer to a #idmef_file_t object.
 * @object: pointer to a #idmef_file_access_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_file_access_t object.
 */
void idmef_file_set_file_access(idmef_file_t *ptr, idmef_file_access_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->file_access_list);
}

/**
 * idmef_file_new_HASH(0x80254c6c):
 * @ptr: pointer to a #idmef_file_t object.
 * 
 * Create a new HASH(0x80254c6c) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_file_access_t object.
 * 
 * Returns: a pointer to the created #idmef_file_access_t object, or NULL if an error occured.
 */
idmef_file_access_t *idmef_file_new_file_access(idmef_file_t *ptr)
{
	idmef_file_access_t *object;
	
	object = idmef_file_access_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->file_access_list);
	
	return object;
}

idmef_value_t *idmef_file_get_file_access_value(idmef_file_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_file_access_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->file_access_list) {
		entry = prelude_list_entry(tmp, idmef_file_access_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_FILE_ACCESS);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_file_get_next_linkage:
 * @ptr: pointer to a #idmef_file_t object.
 * @object: pointer to a #idmef_linkage_t object.
 *
 * Get the next #idmef_linkage_t object listed in @ptr.
 * When iterating over the idmef_linkage_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_linkage_t object.
 * 
 * Returns: the next #idmef_linkage_t in the list.
 */
idmef_linkage_t *idmef_file_get_next_linkage(idmef_file_t *ptr, idmef_linkage_t *object)
{
    	return prelude_list_get_next(object, &ptr->linkage_list, idmef_linkage_t, list);
}

/**
 * idmef_file_set_linkage:
 * @ptr: pointer to a #idmef_file_t object.
 * @object: pointer to a #idmef_linkage_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_linkage_t object.
 */
void idmef_file_set_linkage(idmef_file_t *ptr, idmef_linkage_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->linkage_list);
}

/**
 * idmef_file_new_HASH(0x80255f9c):
 * @ptr: pointer to a #idmef_file_t object.
 * 
 * Create a new HASH(0x80255f9c) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_linkage_t object.
 * 
 * Returns: a pointer to the created #idmef_linkage_t object, or NULL if an error occured.
 */
idmef_linkage_t *idmef_file_new_linkage(idmef_file_t *ptr)
{
	idmef_linkage_t *object;
	
	object = idmef_linkage_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->linkage_list);
	
	return object;
}

idmef_value_t *idmef_file_get_linkage_value(idmef_file_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_linkage_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->linkage_list) {
		entry = prelude_list_entry(tmp, idmef_linkage_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_LINKAGE);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * *idmef_file_get_inode:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get inode children of the #idmef_file_t object.
 *
 * Returns: a pointer to a idmef_inode_t object, or NULL if the children object is not set.
 */
idmef_inode_t *idmef_file_get_inode(idmef_file_t *ptr)
{
	return ptr->inode;
}

idmef_value_t *idmef_file_get_inode_value(idmef_file_t *ptr)
{
	if ( ! ptr->inode )
		return NULL;

	return idmef_value_new_object(ptr->inode, IDMEF_OBJECT_TYPE_INODE);
}

/**
 * idmef_file_set_inode:
 * @ptr: pointer to a #idmef_file_t object.
 * @inode: pointer to a #idmef_inode_t object.
 *
 * Set @inode object as a children of @ptr.
 * if @ptr already contain an @inode object, then it is destroyed,
 * and updated to point to the provided @inode object.
 */

void idmef_file_set_inode(idmef_file_t *ptr, idmef_inode_t *inode)
{
	if ( ptr->inode )
		idmef_inode_destroy(ptr->inode);

	ptr->inode = inode;
}

/**
 * idmef_file_new_inode:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new inode object, children of #idmef_file_t.
 * If @ptr already contain a #idmef_inode_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_inode_t *idmef_file_new_inode(idmef_file_t *ptr)
{
	if ( ! ptr->inode )
		ptr->inode = idmef_inode_new();

	return ptr->inode;
}

/**
 * idmef_file_get_next_checksum:
 * @ptr: pointer to a #idmef_file_t object.
 * @object: pointer to a #idmef_checksum_t object.
 *
 * Get the next #idmef_checksum_t object listed in @ptr.
 * When iterating over the idmef_checksum_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_checksum_t object.
 * 
 * Returns: the next #idmef_checksum_t in the list.
 */
idmef_checksum_t *idmef_file_get_next_checksum(idmef_file_t *ptr, idmef_checksum_t *object)
{
    	return prelude_list_get_next(object, &ptr->checksum_list, idmef_checksum_t, list);
}

/**
 * idmef_file_set_checksum:
 * @ptr: pointer to a #idmef_file_t object.
 * @object: pointer to a #idmef_checksum_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_checksum_t object.
 */
void idmef_file_set_checksum(idmef_file_t *ptr, idmef_checksum_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->checksum_list);
}

/**
 * idmef_file_new_HASH(0x8025608c):
 * @ptr: pointer to a #idmef_file_t object.
 * 
 * Create a new HASH(0x8025608c) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_checksum_t object.
 * 
 * Returns: a pointer to the created #idmef_checksum_t object, or NULL if an error occured.
 */
idmef_checksum_t *idmef_file_new_checksum(idmef_file_t *ptr)
{
	idmef_checksum_t *object;
	
	object = idmef_checksum_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->checksum_list);
	
	return object;
}

idmef_value_t *idmef_file_get_checksum_value(idmef_file_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_checksum_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->checksum_list) {
		entry = prelude_list_entry(tmp, idmef_checksum_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_CHECKSUM);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_file_get_category:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get category children of the #idmef_file_t object.
 *
 * Returns: a pointer to a idmef_file_category_t object, or NULL if the children object is not set.
 */
idmef_file_category_t idmef_file_get_category(idmef_file_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_file_get_category_value(idmef_file_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_FILE_CATEGORY, ptr->category);

}

/**
 * idmef_file_set_category:
 * @ptr: pointer to a #idmef_file_t object.
 * @category: pointer to a #idmef_file_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void idmef_file_set_category(idmef_file_t *ptr, idmef_file_category_t category)
{
	ptr->category = category;
}

/**
 * idmef_file_new_category:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new category object, children of #idmef_file_t.
 * If @ptr already contain a #idmef_file_category_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_file_category_t *idmef_file_new_category(idmef_file_t *ptr)
{
	return &ptr->category;
}

/**
 * *idmef_file_get_fstype:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Get fstype children of the #idmef_file_t object.
 *
 * Returns: a pointer to a idmef_file_fstype_t object, or NULL if the children object is not set.
 */
idmef_file_fstype_t *idmef_file_get_fstype(idmef_file_t *ptr)
{
	return ptr->fstype_is_set ? &ptr->fstype : NULL;
}

idmef_value_t *idmef_file_get_fstype_value(idmef_file_t *ptr)
{
	return ptr->fstype_is_set ? idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_FILE_FSTYPE, ptr->fstype) : NULL;
}

/**
 * idmef_file_set_fstype:
 * @ptr: pointer to a #idmef_file_t object.
 * @fstype: pointer to a #idmef_file_fstype_t object.
 *
 * Set @fstype object as a children of @ptr.
 * if @ptr already contain an @fstype object, then it is destroyed,
 * and updated to point to the provided @fstype object.
 */

void idmef_file_set_fstype(idmef_file_t *ptr, idmef_file_fstype_t fstype)
{
	ptr->fstype = fstype;
	ptr->fstype_is_set = 1;
}

/**
 * idmef_file_new_fstype:
 * @ptr: pointer to a #idmef_file_t object.
 *
 * Create a new fstype object, children of #idmef_file_t.
 * If @ptr already contain a #idmef_file_fstype_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_file_fstype_t *idmef_file_new_fstype(idmef_file_t *ptr)
{
	ptr->fstype_is_set = 1;

	return &ptr->fstype;
}

/**
 * idmef_linkage_new:
 * 
 * Create a new #idmef_linkage_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_linkage_t *idmef_linkage_new(void)
{
	idmef_linkage_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_linkage_ref:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_linkage_t *idmef_linkage_ref(idmef_linkage_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_linkage_get_child(void *p, idmef_child_t child)
{
	idmef_linkage_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_linkage_get_category_value(ptr);

		case 1:
			return idmef_linkage_get_name_value(ptr);

		case 2:
			return idmef_linkage_get_path_value(ptr);

		case 3:
			return ptr->file;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_linkage_new_child(void *p, idmef_child_t child, int n)
{
	idmef_linkage_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_linkage_new_category(ptr);

		case 1:
			return idmef_linkage_new_name(ptr);

		case 2:
			return idmef_linkage_new_path(ptr);

		case 3:
			return idmef_linkage_new_file(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_linkage_destroy_internal(idmef_linkage_t *ptr)
{

	prelude_string_destroy_internal(&ptr->name);

	prelude_string_destroy_internal(&ptr->path);

	if ( ptr->file ) {
		idmef_file_destroy(ptr->file);
		ptr->file = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_linkage_destroy:
 * @ptr: pointer to a #idmef_linkage_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_linkage_destroy(idmef_linkage_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_linkage_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_linkage_get_category:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Get category children of the #idmef_linkage_t object.
 *
 * Returns: a pointer to a idmef_linkage_category_t object, or NULL if the children object is not set.
 */
idmef_linkage_category_t idmef_linkage_get_category(idmef_linkage_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_linkage_get_category_value(idmef_linkage_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_LINKAGE_CATEGORY, ptr->category);

}

/**
 * idmef_linkage_set_category:
 * @ptr: pointer to a #idmef_linkage_t object.
 * @category: pointer to a #idmef_linkage_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void idmef_linkage_set_category(idmef_linkage_t *ptr, idmef_linkage_category_t category)
{
	ptr->category = category;
}

/**
 * idmef_linkage_new_category:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Create a new category object, children of #idmef_linkage_t.
 * If @ptr already contain a #idmef_linkage_category_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_linkage_category_t *idmef_linkage_new_category(idmef_linkage_t *ptr)
{
	return &ptr->category;
}

/**
 * *idmef_linkage_get_name:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Get name children of the #idmef_linkage_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_linkage_get_name(idmef_linkage_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_linkage_get_name_value(idmef_linkage_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_linkage_set_name:
 * @ptr: pointer to a #idmef_linkage_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_linkage_set_name(idmef_linkage_t *ptr, prelude_string_t *name)
{
	prelude_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

/**
 * idmef_linkage_new_name:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Create a new name object, children of #idmef_linkage_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_linkage_new_name(idmef_linkage_t *ptr)
{
	prelude_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

/**
 * *idmef_linkage_get_path:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Get path children of the #idmef_linkage_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_linkage_get_path(idmef_linkage_t *ptr)
{
	return &ptr->path;
}

idmef_value_t *idmef_linkage_get_path_value(idmef_linkage_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->path);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_linkage_set_path:
 * @ptr: pointer to a #idmef_linkage_t object.
 * @path: pointer to a #prelude_string_t object.
 *
 * Set @path object as a children of @ptr.
 * if @ptr already contain an @path object, then it is destroyed,
 * and updated to point to the provided @path object.
 */

void idmef_linkage_set_path(idmef_linkage_t *ptr, prelude_string_t *path)
{
	prelude_string_destroy_internal(&ptr->path);
	memcpy(&ptr->path, path, sizeof (ptr->path));
	free(path);
}

/**
 * idmef_linkage_new_path:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Create a new path object, children of #idmef_linkage_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_linkage_new_path(idmef_linkage_t *ptr)
{
	prelude_string_destroy_internal(&ptr->path);

	return &ptr->path;
}

/**
 * *idmef_linkage_get_file:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Get file children of the #idmef_linkage_t object.
 *
 * Returns: a pointer to a idmef_file_t object, or NULL if the children object is not set.
 */
idmef_file_t *idmef_linkage_get_file(idmef_linkage_t *ptr)
{
	return ptr->file;
}

idmef_value_t *idmef_linkage_get_file_value(idmef_linkage_t *ptr)
{
	if ( ! ptr->file )
		return NULL;

	return idmef_value_new_object(ptr->file, IDMEF_OBJECT_TYPE_FILE);
}

/**
 * idmef_linkage_set_file:
 * @ptr: pointer to a #idmef_linkage_t object.
 * @file: pointer to a #idmef_file_t object.
 *
 * Set @file object as a children of @ptr.
 * if @ptr already contain an @file object, then it is destroyed,
 * and updated to point to the provided @file object.
 */

void idmef_linkage_set_file(idmef_linkage_t *ptr, idmef_file_t *file)
{
	if ( ptr->file )
		idmef_file_destroy(ptr->file);

	ptr->file = file;
}

/**
 * idmef_linkage_new_file:
 * @ptr: pointer to a #idmef_linkage_t object.
 *
 * Create a new file object, children of #idmef_linkage_t.
 * If @ptr already contain a #idmef_file_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_file_t *idmef_linkage_new_file(idmef_linkage_t *ptr)
{
	if ( ! ptr->file )
		ptr->file = idmef_file_new();

	return ptr->file;
}

/**
 * idmef_target_new:
 * 
 * Create a new #idmef_target_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_target_t *idmef_target_new(void)
{
	idmef_target_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->file_list);
    

	return ret;

}

/**
 * idmef_target_ref:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_target_t *idmef_target_ref(idmef_target_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_target_get_child(void *p, idmef_child_t child)
{
	idmef_target_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_target_get_ident_value(ptr);

		case 1:
			return idmef_target_get_decoy_value(ptr);

		case 2:
			return idmef_target_get_interface_value(ptr);

		case 3:
			return ptr->node;

		case 4:
			return ptr->user;

		case 5:
			return ptr->process;

		case 6:
			return ptr->service;

		case 7:
			return &ptr->file_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_target_new_child(void *p, idmef_child_t child, int n)
{
	idmef_target_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_target_new_ident(ptr);

		case 1:
			return idmef_target_new_decoy(ptr);

		case 2:
			return idmef_target_new_interface(ptr);

		case 3:
			return idmef_target_new_node(ptr);

		case 4:
			return idmef_target_new_user(ptr);

		case 5:
			return idmef_target_new_process(ptr);

		case 6:
			return idmef_target_new_service(ptr);

		case 7: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_target_new_file(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->file_list) {
			    		entry = prelude_list_entry(tmp, idmef_file_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_target_new_file(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_target_destroy_internal(idmef_target_t *ptr)
{

	prelude_string_destroy_internal(&ptr->interface);

	if ( ptr->node ) {
		idmef_node_destroy(ptr->node);
		ptr->node = NULL;
	}

	if ( ptr->user ) {
		idmef_user_destroy(ptr->user);
		ptr->user = NULL;
	}

	if ( ptr->process ) {
		idmef_process_destroy(ptr->process);
		ptr->process = NULL;
	}

	if ( ptr->service ) {
		idmef_service_destroy(ptr->service);
		ptr->service = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_file_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->file_list) {
			entry = prelude_list_entry(tmp, idmef_file_t, list);
			prelude_list_del(&entry->list);
			idmef_file_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_target_destroy:
 * @ptr: pointer to a #idmef_target_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_target_destroy(idmef_target_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_target_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_target_get_ident:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Get ident children of the #idmef_target_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_target_get_ident(idmef_target_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_target_get_ident_value(idmef_target_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_target_set_ident:
 * @ptr: pointer to a #idmef_target_t object.
 * @ident: pointer to a #uint64_t object.
 *
 * Set @ident object as a children of @ptr.
 * if @ptr already contain an @ident object, then it is destroyed,
 * and updated to point to the provided @ident object.
 */

void idmef_target_set_ident(idmef_target_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

/**
 * idmef_target_new_ident:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Create a new ident object, children of #idmef_target_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_target_new_ident(idmef_target_t *ptr)
{
	return &ptr->ident;
}

/**
 * idmef_target_get_decoy:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Get decoy children of the #idmef_target_t object.
 *
 * Returns: a pointer to a idmef_target_decoy_t object, or NULL if the children object is not set.
 */
idmef_target_decoy_t idmef_target_get_decoy(idmef_target_t *ptr)
{
	return ptr->decoy;
}

idmef_value_t *idmef_target_get_decoy_value(idmef_target_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_TARGET_DECOY, ptr->decoy);

}

/**
 * idmef_target_set_decoy:
 * @ptr: pointer to a #idmef_target_t object.
 * @decoy: pointer to a #idmef_target_decoy_t object.
 *
 * Set @decoy object as a children of @ptr.
 * if @ptr already contain an @decoy object, then it is destroyed,
 * and updated to point to the provided @decoy object.
 */

void idmef_target_set_decoy(idmef_target_t *ptr, idmef_target_decoy_t decoy)
{
	ptr->decoy = decoy;
}

/**
 * idmef_target_new_decoy:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Create a new decoy object, children of #idmef_target_t.
 * If @ptr already contain a #idmef_target_decoy_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_target_decoy_t *idmef_target_new_decoy(idmef_target_t *ptr)
{
	return &ptr->decoy;
}

/**
 * *idmef_target_get_interface:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Get interface children of the #idmef_target_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_target_get_interface(idmef_target_t *ptr)
{
	return &ptr->interface;
}

idmef_value_t *idmef_target_get_interface_value(idmef_target_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->interface);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_target_set_interface:
 * @ptr: pointer to a #idmef_target_t object.
 * @interface: pointer to a #prelude_string_t object.
 *
 * Set @interface object as a children of @ptr.
 * if @ptr already contain an @interface object, then it is destroyed,
 * and updated to point to the provided @interface object.
 */

void idmef_target_set_interface(idmef_target_t *ptr, prelude_string_t *interface)
{
	prelude_string_destroy_internal(&ptr->interface);
	memcpy(&ptr->interface, interface, sizeof (ptr->interface));
	free(interface);
}

/**
 * idmef_target_new_interface:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Create a new interface object, children of #idmef_target_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_target_new_interface(idmef_target_t *ptr)
{
	prelude_string_destroy_internal(&ptr->interface);

	return &ptr->interface;
}

/**
 * *idmef_target_get_node:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Get node children of the #idmef_target_t object.
 *
 * Returns: a pointer to a idmef_node_t object, or NULL if the children object is not set.
 */
idmef_node_t *idmef_target_get_node(idmef_target_t *ptr)
{
	return ptr->node;
}

idmef_value_t *idmef_target_get_node_value(idmef_target_t *ptr)
{
	if ( ! ptr->node )
		return NULL;

	return idmef_value_new_object(ptr->node, IDMEF_OBJECT_TYPE_NODE);
}

/**
 * idmef_target_set_node:
 * @ptr: pointer to a #idmef_target_t object.
 * @node: pointer to a #idmef_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void idmef_target_set_node(idmef_target_t *ptr, idmef_node_t *node)
{
	if ( ptr->node )
		idmef_node_destroy(ptr->node);

	ptr->node = node;
}

/**
 * idmef_target_new_node:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Create a new node object, children of #idmef_target_t.
 * If @ptr already contain a #idmef_node_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_node_t *idmef_target_new_node(idmef_target_t *ptr)
{
	if ( ! ptr->node )
		ptr->node = idmef_node_new();

	return ptr->node;
}

/**
 * *idmef_target_get_user:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Get user children of the #idmef_target_t object.
 *
 * Returns: a pointer to a idmef_user_t object, or NULL if the children object is not set.
 */
idmef_user_t *idmef_target_get_user(idmef_target_t *ptr)
{
	return ptr->user;
}

idmef_value_t *idmef_target_get_user_value(idmef_target_t *ptr)
{
	if ( ! ptr->user )
		return NULL;

	return idmef_value_new_object(ptr->user, IDMEF_OBJECT_TYPE_USER);
}

/**
 * idmef_target_set_user:
 * @ptr: pointer to a #idmef_target_t object.
 * @user: pointer to a #idmef_user_t object.
 *
 * Set @user object as a children of @ptr.
 * if @ptr already contain an @user object, then it is destroyed,
 * and updated to point to the provided @user object.
 */

void idmef_target_set_user(idmef_target_t *ptr, idmef_user_t *user)
{
	if ( ptr->user )
		idmef_user_destroy(ptr->user);

	ptr->user = user;
}

/**
 * idmef_target_new_user:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Create a new user object, children of #idmef_target_t.
 * If @ptr already contain a #idmef_user_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_user_t *idmef_target_new_user(idmef_target_t *ptr)
{
	if ( ! ptr->user )
		ptr->user = idmef_user_new();

	return ptr->user;
}

/**
 * *idmef_target_get_process:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Get process children of the #idmef_target_t object.
 *
 * Returns: a pointer to a idmef_process_t object, or NULL if the children object is not set.
 */
idmef_process_t *idmef_target_get_process(idmef_target_t *ptr)
{
	return ptr->process;
}

idmef_value_t *idmef_target_get_process_value(idmef_target_t *ptr)
{
	if ( ! ptr->process )
		return NULL;

	return idmef_value_new_object(ptr->process, IDMEF_OBJECT_TYPE_PROCESS);
}

/**
 * idmef_target_set_process:
 * @ptr: pointer to a #idmef_target_t object.
 * @process: pointer to a #idmef_process_t object.
 *
 * Set @process object as a children of @ptr.
 * if @ptr already contain an @process object, then it is destroyed,
 * and updated to point to the provided @process object.
 */

void idmef_target_set_process(idmef_target_t *ptr, idmef_process_t *process)
{
	if ( ptr->process )
		idmef_process_destroy(ptr->process);

	ptr->process = process;
}

/**
 * idmef_target_new_process:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Create a new process object, children of #idmef_target_t.
 * If @ptr already contain a #idmef_process_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_process_t *idmef_target_new_process(idmef_target_t *ptr)
{
	if ( ! ptr->process )
		ptr->process = idmef_process_new();

	return ptr->process;
}

/**
 * *idmef_target_get_service:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Get service children of the #idmef_target_t object.
 *
 * Returns: a pointer to a idmef_service_t object, or NULL if the children object is not set.
 */
idmef_service_t *idmef_target_get_service(idmef_target_t *ptr)
{
	return ptr->service;
}

idmef_value_t *idmef_target_get_service_value(idmef_target_t *ptr)
{
	if ( ! ptr->service )
		return NULL;

	return idmef_value_new_object(ptr->service, IDMEF_OBJECT_TYPE_SERVICE);
}

/**
 * idmef_target_set_service:
 * @ptr: pointer to a #idmef_target_t object.
 * @service: pointer to a #idmef_service_t object.
 *
 * Set @service object as a children of @ptr.
 * if @ptr already contain an @service object, then it is destroyed,
 * and updated to point to the provided @service object.
 */

void idmef_target_set_service(idmef_target_t *ptr, idmef_service_t *service)
{
	if ( ptr->service )
		idmef_service_destroy(ptr->service);

	ptr->service = service;
}

/**
 * idmef_target_new_service:
 * @ptr: pointer to a #idmef_target_t object.
 *
 * Create a new service object, children of #idmef_target_t.
 * If @ptr already contain a #idmef_service_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_service_t *idmef_target_new_service(idmef_target_t *ptr)
{
	if ( ! ptr->service )
		ptr->service = idmef_service_new();

	return ptr->service;
}

/**
 * idmef_target_get_next_file:
 * @ptr: pointer to a #idmef_target_t object.
 * @object: pointer to a #idmef_file_t object.
 *
 * Get the next #idmef_file_t object listed in @ptr.
 * When iterating over the idmef_file_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_file_t object.
 * 
 * Returns: the next #idmef_file_t in the list.
 */
idmef_file_t *idmef_target_get_next_file(idmef_target_t *ptr, idmef_file_t *object)
{
    	return prelude_list_get_next(object, &ptr->file_list, idmef_file_t, list);
}

/**
 * idmef_target_set_file:
 * @ptr: pointer to a #idmef_target_t object.
 * @object: pointer to a #idmef_file_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_file_t object.
 */
void idmef_target_set_file(idmef_target_t *ptr, idmef_file_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->file_list);
}

/**
 * idmef_target_new_HASH(0x80259630):
 * @ptr: pointer to a #idmef_target_t object.
 * 
 * Create a new HASH(0x80259630) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_file_t object.
 * 
 * Returns: a pointer to the created #idmef_file_t object, or NULL if an error occured.
 */
idmef_file_t *idmef_target_new_file(idmef_target_t *ptr)
{
	idmef_file_t *object;
	
	object = idmef_file_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->file_list);
	
	return object;
}

idmef_value_t *idmef_target_get_file_value(idmef_target_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_file_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->file_list) {
		entry = prelude_list_entry(tmp, idmef_file_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_FILE);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_analyzer_new:
 * 
 * Create a new #idmef_analyzer_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_analyzer_t *idmef_analyzer_new(void)
{
	idmef_analyzer_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_analyzer_ref:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_analyzer_t *idmef_analyzer_ref(idmef_analyzer_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_analyzer_get_child(void *p, idmef_child_t child)
{
	idmef_analyzer_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_analyzer_get_analyzerid_value(ptr);

		case 1:
			return idmef_analyzer_get_name_value(ptr);

		case 2:
			return idmef_analyzer_get_manufacturer_value(ptr);

		case 3:
			return idmef_analyzer_get_model_value(ptr);

		case 4:
			return idmef_analyzer_get_version_value(ptr);

		case 5:
			return idmef_analyzer_get_class_value(ptr);

		case 6:
			return idmef_analyzer_get_ostype_value(ptr);

		case 7:
			return idmef_analyzer_get_osversion_value(ptr);

		case 8:
			return ptr->node;

		case 9:
			return ptr->process;

		case 10:
			return ptr->analyzer;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_analyzer_new_child(void *p, idmef_child_t child, int n)
{
	idmef_analyzer_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_analyzer_new_analyzerid(ptr);

		case 1:
			return idmef_analyzer_new_name(ptr);

		case 2:
			return idmef_analyzer_new_manufacturer(ptr);

		case 3:
			return idmef_analyzer_new_model(ptr);

		case 4:
			return idmef_analyzer_new_version(ptr);

		case 5:
			return idmef_analyzer_new_class(ptr);

		case 6:
			return idmef_analyzer_new_ostype(ptr);

		case 7:
			return idmef_analyzer_new_osversion(ptr);

		case 8:
			return idmef_analyzer_new_node(ptr);

		case 9:
			return idmef_analyzer_new_process(ptr);

		case 10:
			return idmef_analyzer_new_analyzer(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_analyzer_destroy_internal(idmef_analyzer_t *ptr)
{

	if ( ptr->name ) {
		prelude_string_destroy(ptr->name);
		ptr->name = NULL;
	}

	if ( ptr->manufacturer ) {
		prelude_string_destroy(ptr->manufacturer);
		ptr->manufacturer = NULL;
	}

	if ( ptr->model ) {
		prelude_string_destroy(ptr->model);
		ptr->model = NULL;
	}

	if ( ptr->version ) {
		prelude_string_destroy(ptr->version);
		ptr->version = NULL;
	}

	if ( ptr->class ) {
		prelude_string_destroy(ptr->class);
		ptr->class = NULL;
	}

	if ( ptr->ostype ) {
		prelude_string_destroy(ptr->ostype);
		ptr->ostype = NULL;
	}

	if ( ptr->osversion ) {
		prelude_string_destroy(ptr->osversion);
		ptr->osversion = NULL;
	}

	if ( ptr->node ) {
		idmef_node_destroy(ptr->node);
		ptr->node = NULL;
	}

	if ( ptr->process ) {
		idmef_process_destroy(ptr->process);
		ptr->process = NULL;
	}

	if ( ptr->analyzer ) {
		idmef_analyzer_destroy(ptr->analyzer);
		ptr->analyzer = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_analyzer_destroy:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_analyzer_destroy(idmef_analyzer_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_analyzer_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_analyzer_get_analyzerid:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get analyzerid children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_analyzer_get_analyzerid(idmef_analyzer_t *ptr)
{
	return ptr->analyzerid;
}

idmef_value_t *idmef_analyzer_get_analyzerid_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->analyzerid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_analyzerid:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @analyzerid: pointer to a #uint64_t object.
 *
 * Set @analyzerid object as a children of @ptr.
 * if @ptr already contain an @analyzerid object, then it is destroyed,
 * and updated to point to the provided @analyzerid object.
 */

void idmef_analyzer_set_analyzerid(idmef_analyzer_t *ptr, uint64_t analyzerid)
{
	ptr->analyzerid = analyzerid;
}

/**
 * idmef_analyzer_new_analyzerid:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new analyzerid object, children of #idmef_analyzer_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_analyzer_new_analyzerid(idmef_analyzer_t *ptr)
{
	return &ptr->analyzerid;
}

/**
 * *idmef_analyzer_get_name:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get name children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_analyzer_get_name(idmef_analyzer_t *ptr)
{
	return ptr->name;
}

idmef_value_t *idmef_analyzer_get_name_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->name )
		return NULL;


	value = idmef_value_new_string(ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_name:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_analyzer_set_name(idmef_analyzer_t *ptr, prelude_string_t *name)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);

	ptr->name = name;
}

/**
 * idmef_analyzer_new_name:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new name object, children of #idmef_analyzer_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_analyzer_new_name(idmef_analyzer_t *ptr)
{
	if ( ptr->name )
		prelude_string_destroy(ptr->name);
		
	ptr->name = prelude_string_new();

	return ptr->name;
}

/**
 * *idmef_analyzer_get_manufacturer:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get manufacturer children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_analyzer_get_manufacturer(idmef_analyzer_t *ptr)
{
	return ptr->manufacturer;
}

idmef_value_t *idmef_analyzer_get_manufacturer_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->manufacturer )
		return NULL;


	value = idmef_value_new_string(ptr->manufacturer);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_manufacturer:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @manufacturer: pointer to a #prelude_string_t object.
 *
 * Set @manufacturer object as a children of @ptr.
 * if @ptr already contain an @manufacturer object, then it is destroyed,
 * and updated to point to the provided @manufacturer object.
 */

void idmef_analyzer_set_manufacturer(idmef_analyzer_t *ptr, prelude_string_t *manufacturer)
{
	if ( ptr->manufacturer )
		prelude_string_destroy(ptr->manufacturer);

	ptr->manufacturer = manufacturer;
}

/**
 * idmef_analyzer_new_manufacturer:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new manufacturer object, children of #idmef_analyzer_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_analyzer_new_manufacturer(idmef_analyzer_t *ptr)
{
	if ( ptr->manufacturer )
		prelude_string_destroy(ptr->manufacturer);
		
	ptr->manufacturer = prelude_string_new();

	return ptr->manufacturer;
}

/**
 * *idmef_analyzer_get_model:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get model children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_analyzer_get_model(idmef_analyzer_t *ptr)
{
	return ptr->model;
}

idmef_value_t *idmef_analyzer_get_model_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->model )
		return NULL;


	value = idmef_value_new_string(ptr->model);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_model:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @model: pointer to a #prelude_string_t object.
 *
 * Set @model object as a children of @ptr.
 * if @ptr already contain an @model object, then it is destroyed,
 * and updated to point to the provided @model object.
 */

void idmef_analyzer_set_model(idmef_analyzer_t *ptr, prelude_string_t *model)
{
	if ( ptr->model )
		prelude_string_destroy(ptr->model);

	ptr->model = model;
}

/**
 * idmef_analyzer_new_model:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new model object, children of #idmef_analyzer_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_analyzer_new_model(idmef_analyzer_t *ptr)
{
	if ( ptr->model )
		prelude_string_destroy(ptr->model);
		
	ptr->model = prelude_string_new();

	return ptr->model;
}

/**
 * *idmef_analyzer_get_version:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get version children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_analyzer_get_version(idmef_analyzer_t *ptr)
{
	return ptr->version;
}

idmef_value_t *idmef_analyzer_get_version_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->version )
		return NULL;


	value = idmef_value_new_string(ptr->version);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_version:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @version: pointer to a #prelude_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void idmef_analyzer_set_version(idmef_analyzer_t *ptr, prelude_string_t *version)
{
	if ( ptr->version )
		prelude_string_destroy(ptr->version);

	ptr->version = version;
}

/**
 * idmef_analyzer_new_version:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new version object, children of #idmef_analyzer_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_analyzer_new_version(idmef_analyzer_t *ptr)
{
	if ( ptr->version )
		prelude_string_destroy(ptr->version);
		
	ptr->version = prelude_string_new();

	return ptr->version;
}

/**
 * *idmef_analyzer_get_class:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get class children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_analyzer_get_class(idmef_analyzer_t *ptr)
{
	return ptr->class;
}

idmef_value_t *idmef_analyzer_get_class_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->class )
		return NULL;


	value = idmef_value_new_string(ptr->class);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_class:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @class: pointer to a #prelude_string_t object.
 *
 * Set @class object as a children of @ptr.
 * if @ptr already contain an @class object, then it is destroyed,
 * and updated to point to the provided @class object.
 */

void idmef_analyzer_set_class(idmef_analyzer_t *ptr, prelude_string_t *class)
{
	if ( ptr->class )
		prelude_string_destroy(ptr->class);

	ptr->class = class;
}

/**
 * idmef_analyzer_new_class:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new class object, children of #idmef_analyzer_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_analyzer_new_class(idmef_analyzer_t *ptr)
{
	if ( ptr->class )
		prelude_string_destroy(ptr->class);
		
	ptr->class = prelude_string_new();

	return ptr->class;
}

/**
 * *idmef_analyzer_get_ostype:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get ostype children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_analyzer_get_ostype(idmef_analyzer_t *ptr)
{
	return ptr->ostype;
}

idmef_value_t *idmef_analyzer_get_ostype_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->ostype )
		return NULL;


	value = idmef_value_new_string(ptr->ostype);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_ostype:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @ostype: pointer to a #prelude_string_t object.
 *
 * Set @ostype object as a children of @ptr.
 * if @ptr already contain an @ostype object, then it is destroyed,
 * and updated to point to the provided @ostype object.
 */

void idmef_analyzer_set_ostype(idmef_analyzer_t *ptr, prelude_string_t *ostype)
{
	if ( ptr->ostype )
		prelude_string_destroy(ptr->ostype);

	ptr->ostype = ostype;
}

/**
 * idmef_analyzer_new_ostype:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new ostype object, children of #idmef_analyzer_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_analyzer_new_ostype(idmef_analyzer_t *ptr)
{
	if ( ptr->ostype )
		prelude_string_destroy(ptr->ostype);
		
	ptr->ostype = prelude_string_new();

	return ptr->ostype;
}

/**
 * *idmef_analyzer_get_osversion:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get osversion children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_analyzer_get_osversion(idmef_analyzer_t *ptr)
{
	return ptr->osversion;
}

idmef_value_t *idmef_analyzer_get_osversion_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->osversion )
		return NULL;


	value = idmef_value_new_string(ptr->osversion);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_analyzer_set_osversion:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @osversion: pointer to a #prelude_string_t object.
 *
 * Set @osversion object as a children of @ptr.
 * if @ptr already contain an @osversion object, then it is destroyed,
 * and updated to point to the provided @osversion object.
 */

void idmef_analyzer_set_osversion(idmef_analyzer_t *ptr, prelude_string_t *osversion)
{
	if ( ptr->osversion )
		prelude_string_destroy(ptr->osversion);

	ptr->osversion = osversion;
}

/**
 * idmef_analyzer_new_osversion:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new osversion object, children of #idmef_analyzer_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_analyzer_new_osversion(idmef_analyzer_t *ptr)
{
	if ( ptr->osversion )
		prelude_string_destroy(ptr->osversion);
		
	ptr->osversion = prelude_string_new();

	return ptr->osversion;
}

/**
 * *idmef_analyzer_get_node:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get node children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a idmef_node_t object, or NULL if the children object is not set.
 */
idmef_node_t *idmef_analyzer_get_node(idmef_analyzer_t *ptr)
{
	return ptr->node;
}

idmef_value_t *idmef_analyzer_get_node_value(idmef_analyzer_t *ptr)
{
	if ( ! ptr->node )
		return NULL;

	return idmef_value_new_object(ptr->node, IDMEF_OBJECT_TYPE_NODE);
}

/**
 * idmef_analyzer_set_node:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @node: pointer to a #idmef_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void idmef_analyzer_set_node(idmef_analyzer_t *ptr, idmef_node_t *node)
{
	if ( ptr->node )
		idmef_node_destroy(ptr->node);

	ptr->node = node;
}

/**
 * idmef_analyzer_new_node:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new node object, children of #idmef_analyzer_t.
 * If @ptr already contain a #idmef_node_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_node_t *idmef_analyzer_new_node(idmef_analyzer_t *ptr)
{
	if ( ! ptr->node )
		ptr->node = idmef_node_new();

	return ptr->node;
}

/**
 * *idmef_analyzer_get_process:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get process children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a idmef_process_t object, or NULL if the children object is not set.
 */
idmef_process_t *idmef_analyzer_get_process(idmef_analyzer_t *ptr)
{
	return ptr->process;
}

idmef_value_t *idmef_analyzer_get_process_value(idmef_analyzer_t *ptr)
{
	if ( ! ptr->process )
		return NULL;

	return idmef_value_new_object(ptr->process, IDMEF_OBJECT_TYPE_PROCESS);
}

/**
 * idmef_analyzer_set_process:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @process: pointer to a #idmef_process_t object.
 *
 * Set @process object as a children of @ptr.
 * if @ptr already contain an @process object, then it is destroyed,
 * and updated to point to the provided @process object.
 */

void idmef_analyzer_set_process(idmef_analyzer_t *ptr, idmef_process_t *process)
{
	if ( ptr->process )
		idmef_process_destroy(ptr->process);

	ptr->process = process;
}

/**
 * idmef_analyzer_new_process:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new process object, children of #idmef_analyzer_t.
 * If @ptr already contain a #idmef_process_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_process_t *idmef_analyzer_new_process(idmef_analyzer_t *ptr)
{
	if ( ! ptr->process )
		ptr->process = idmef_process_new();

	return ptr->process;
}

/**
 * *idmef_analyzer_get_analyzer:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Get analyzer children of the #idmef_analyzer_t object.
 *
 * Returns: a pointer to a idmef_analyzer_t object, or NULL if the children object is not set.
 */
idmef_analyzer_t *idmef_analyzer_get_analyzer(idmef_analyzer_t *ptr)
{
	return ptr->analyzer;
}

idmef_value_t *idmef_analyzer_get_analyzer_value(idmef_analyzer_t *ptr)
{
	if ( ! ptr->analyzer )
		return NULL;

	return idmef_value_new_object(ptr->analyzer, IDMEF_OBJECT_TYPE_ANALYZER);
}

/**
 * idmef_analyzer_set_analyzer:
 * @ptr: pointer to a #idmef_analyzer_t object.
 * @analyzer: pointer to a #idmef_analyzer_t object.
 *
 * Set @analyzer object as a children of @ptr.
 * if @ptr already contain an @analyzer object, then it is destroyed,
 * and updated to point to the provided @analyzer object.
 */

void idmef_analyzer_set_analyzer(idmef_analyzer_t *ptr, idmef_analyzer_t *analyzer)
{
	if ( ptr->analyzer )
		idmef_analyzer_destroy(ptr->analyzer);

	ptr->analyzer = analyzer;
}

/**
 * idmef_analyzer_new_analyzer:
 * @ptr: pointer to a #idmef_analyzer_t object.
 *
 * Create a new analyzer object, children of #idmef_analyzer_t.
 * If @ptr already contain a #idmef_analyzer_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_analyzer_t *idmef_analyzer_new_analyzer(idmef_analyzer_t *ptr)
{
	if ( ! ptr->analyzer )
		ptr->analyzer = idmef_analyzer_new();

	return ptr->analyzer;
}

/**
 * idmef_alertident_new:
 * 
 * Create a new #idmef_alertident_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_alertident_t *idmef_alertident_new(void)
{
	idmef_alertident_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_alertident_ref:
 * @ptr: pointer to a #idmef_alertident_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_alertident_t *idmef_alertident_ref(idmef_alertident_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_alertident_get_child(void *p, idmef_child_t child)
{
	idmef_alertident_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_alertident_get_alertident_value(ptr);

		case 1:
			return idmef_alertident_get_analyzerid_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_alertident_new_child(void *p, idmef_child_t child, int n)
{
	idmef_alertident_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_alertident_new_alertident(ptr);

		case 1:
			return idmef_alertident_new_analyzerid(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_alertident_destroy_internal(idmef_alertident_t *ptr)
{


	/* free() should be done by the caller */
}

/**
 * idmef_alertident_destroy:
 * @ptr: pointer to a #idmef_alertident_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_alertident_destroy(idmef_alertident_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_alertident_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_alertident_get_alertident:
 * @ptr: pointer to a #idmef_alertident_t object.
 *
 * Get alertident children of the #idmef_alertident_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_alertident_get_alertident(idmef_alertident_t *ptr)
{
	return ptr->alertident;
}

idmef_value_t *idmef_alertident_get_alertident_value(idmef_alertident_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->alertident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_alertident_set_alertident:
 * @ptr: pointer to a #idmef_alertident_t object.
 * @alertident: pointer to a #uint64_t object.
 *
 * Set @alertident object as a children of @ptr.
 * if @ptr already contain an @alertident object, then it is destroyed,
 * and updated to point to the provided @alertident object.
 */

void idmef_alertident_set_alertident(idmef_alertident_t *ptr, uint64_t alertident)
{
	ptr->alertident = alertident;
}

/**
 * idmef_alertident_new_alertident:
 * @ptr: pointer to a #idmef_alertident_t object.
 *
 * Create a new alertident object, children of #idmef_alertident_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_alertident_new_alertident(idmef_alertident_t *ptr)
{
	return &ptr->alertident;
}

/**
 * *idmef_alertident_get_analyzerid:
 * @ptr: pointer to a #idmef_alertident_t object.
 *
 * Get analyzerid children of the #idmef_alertident_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t *idmef_alertident_get_analyzerid(idmef_alertident_t *ptr)
{
	return ptr->analyzerid_is_set ? &ptr->analyzerid : NULL;
}

idmef_value_t *idmef_alertident_get_analyzerid_value(idmef_alertident_t *ptr)
{
	return ptr->analyzerid_is_set ? idmef_value_new_uint64(ptr->analyzerid) : NULL;

}

/**
 * idmef_alertident_set_analyzerid:
 * @ptr: pointer to a #idmef_alertident_t object.
 * @analyzerid: pointer to a #uint64_t object.
 *
 * Set @analyzerid object as a children of @ptr.
 * if @ptr already contain an @analyzerid object, then it is destroyed,
 * and updated to point to the provided @analyzerid object.
 */

void idmef_alertident_set_analyzerid(idmef_alertident_t *ptr, uint64_t analyzerid)
{
	ptr->analyzerid = analyzerid;
	ptr->analyzerid_is_set = 1;
}

/**
 * idmef_alertident_new_analyzerid:
 * @ptr: pointer to a #idmef_alertident_t object.
 *
 * Create a new analyzerid object, children of #idmef_alertident_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_alertident_new_analyzerid(idmef_alertident_t *ptr)
{
	ptr->analyzerid_is_set = 1;

	return &ptr->analyzerid;
}

/**
 * idmef_impact_new:
 * 
 * Create a new #idmef_impact_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_impact_t *idmef_impact_new(void)
{
	idmef_impact_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_impact_ref:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_impact_t *idmef_impact_ref(idmef_impact_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_impact_get_child(void *p, idmef_child_t child)
{
	idmef_impact_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_impact_get_severity_value(ptr);

		case 1:
			return idmef_impact_get_completion_value(ptr);

		case 2:
			return idmef_impact_get_type_value(ptr);

		case 3:
			return idmef_impact_get_description_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_impact_new_child(void *p, idmef_child_t child, int n)
{
	idmef_impact_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_impact_new_severity(ptr);

		case 1:
			return idmef_impact_new_completion(ptr);

		case 2:
			return idmef_impact_new_type(ptr);

		case 3:
			return idmef_impact_new_description(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_impact_destroy_internal(idmef_impact_t *ptr)
{

	if ( ptr->description ) {
		prelude_string_destroy(ptr->description);
		ptr->description = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_impact_destroy:
 * @ptr: pointer to a #idmef_impact_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_impact_destroy(idmef_impact_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_impact_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_impact_get_severity:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Get severity children of the #idmef_impact_t object.
 *
 * Returns: a pointer to a idmef_impact_severity_t object, or NULL if the children object is not set.
 */
idmef_impact_severity_t *idmef_impact_get_severity(idmef_impact_t *ptr)
{
	return ptr->severity_is_set ? &ptr->severity : NULL;
}

idmef_value_t *idmef_impact_get_severity_value(idmef_impact_t *ptr)
{
	return ptr->severity_is_set ? idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_IMPACT_SEVERITY, ptr->severity) : NULL;
}

/**
 * idmef_impact_set_severity:
 * @ptr: pointer to a #idmef_impact_t object.
 * @severity: pointer to a #idmef_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */

void idmef_impact_set_severity(idmef_impact_t *ptr, idmef_impact_severity_t severity)
{
	ptr->severity = severity;
	ptr->severity_is_set = 1;
}

/**
 * idmef_impact_new_severity:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Create a new severity object, children of #idmef_impact_t.
 * If @ptr already contain a #idmef_impact_severity_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_impact_severity_t *idmef_impact_new_severity(idmef_impact_t *ptr)
{
	ptr->severity_is_set = 1;

	return &ptr->severity;
}

/**
 * *idmef_impact_get_completion:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Get completion children of the #idmef_impact_t object.
 *
 * Returns: a pointer to a idmef_impact_completion_t object, or NULL if the children object is not set.
 */
idmef_impact_completion_t *idmef_impact_get_completion(idmef_impact_t *ptr)
{
	return ptr->completion_is_set ? &ptr->completion : NULL;
}

idmef_value_t *idmef_impact_get_completion_value(idmef_impact_t *ptr)
{
	return ptr->completion_is_set ? idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_IMPACT_COMPLETION, ptr->completion) : NULL;
}

/**
 * idmef_impact_set_completion:
 * @ptr: pointer to a #idmef_impact_t object.
 * @completion: pointer to a #idmef_impact_completion_t object.
 *
 * Set @completion object as a children of @ptr.
 * if @ptr already contain an @completion object, then it is destroyed,
 * and updated to point to the provided @completion object.
 */

void idmef_impact_set_completion(idmef_impact_t *ptr, idmef_impact_completion_t completion)
{
	ptr->completion = completion;
	ptr->completion_is_set = 1;
}

/**
 * idmef_impact_new_completion:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Create a new completion object, children of #idmef_impact_t.
 * If @ptr already contain a #idmef_impact_completion_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_impact_completion_t *idmef_impact_new_completion(idmef_impact_t *ptr)
{
	ptr->completion_is_set = 1;

	return &ptr->completion;
}

/**
 * idmef_impact_get_type:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Get type children of the #idmef_impact_t object.
 *
 * Returns: a pointer to a idmef_impact_type_t object, or NULL if the children object is not set.
 */
idmef_impact_type_t idmef_impact_get_type(idmef_impact_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_impact_get_type_value(idmef_impact_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_IMPACT_TYPE, ptr->type);

}

/**
 * idmef_impact_set_type:
 * @ptr: pointer to a #idmef_impact_t object.
 * @type: pointer to a #idmef_impact_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void idmef_impact_set_type(idmef_impact_t *ptr, idmef_impact_type_t type)
{
	ptr->type = type;
}

/**
 * idmef_impact_new_type:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Create a new type object, children of #idmef_impact_t.
 * If @ptr already contain a #idmef_impact_type_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_impact_type_t *idmef_impact_new_type(idmef_impact_t *ptr)
{
	return &ptr->type;
}

/**
 * *idmef_impact_get_description:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Get description children of the #idmef_impact_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_impact_get_description(idmef_impact_t *ptr)
{
	return ptr->description;
}

idmef_value_t *idmef_impact_get_description_value(idmef_impact_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->description )
		return NULL;


	value = idmef_value_new_string(ptr->description);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_impact_set_description:
 * @ptr: pointer to a #idmef_impact_t object.
 * @description: pointer to a #prelude_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void idmef_impact_set_description(idmef_impact_t *ptr, prelude_string_t *description)
{
	if ( ptr->description )
		prelude_string_destroy(ptr->description);

	ptr->description = description;
}

/**
 * idmef_impact_new_description:
 * @ptr: pointer to a #idmef_impact_t object.
 *
 * Create a new description object, children of #idmef_impact_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_impact_new_description(idmef_impact_t *ptr)
{
	if ( ptr->description )
		prelude_string_destroy(ptr->description);
		
	ptr->description = prelude_string_new();

	return ptr->description;
}

/**
 * idmef_action_new:
 * 
 * Create a new #idmef_action_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_action_t *idmef_action_new(void)
{
	idmef_action_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_action_ref:
 * @ptr: pointer to a #idmef_action_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_action_t *idmef_action_ref(idmef_action_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_action_get_child(void *p, idmef_child_t child)
{
	idmef_action_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_action_get_category_value(ptr);

		case 1:
			return idmef_action_get_description_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_action_new_child(void *p, idmef_child_t child, int n)
{
	idmef_action_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_action_new_category(ptr);

		case 1:
			return idmef_action_new_description(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_action_destroy_internal(idmef_action_t *ptr)
{

	if ( ptr->description ) {
		prelude_string_destroy(ptr->description);
		ptr->description = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_action_destroy:
 * @ptr: pointer to a #idmef_action_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_action_destroy(idmef_action_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_action_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_action_get_category:
 * @ptr: pointer to a #idmef_action_t object.
 *
 * Get category children of the #idmef_action_t object.
 *
 * Returns: a pointer to a idmef_action_category_t object, or NULL if the children object is not set.
 */
idmef_action_category_t idmef_action_get_category(idmef_action_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_action_get_category_value(idmef_action_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ACTION_CATEGORY, ptr->category);

}

/**
 * idmef_action_set_category:
 * @ptr: pointer to a #idmef_action_t object.
 * @category: pointer to a #idmef_action_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void idmef_action_set_category(idmef_action_t *ptr, idmef_action_category_t category)
{
	ptr->category = category;
}

/**
 * idmef_action_new_category:
 * @ptr: pointer to a #idmef_action_t object.
 *
 * Create a new category object, children of #idmef_action_t.
 * If @ptr already contain a #idmef_action_category_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_action_category_t *idmef_action_new_category(idmef_action_t *ptr)
{
	return &ptr->category;
}

/**
 * *idmef_action_get_description:
 * @ptr: pointer to a #idmef_action_t object.
 *
 * Get description children of the #idmef_action_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_action_get_description(idmef_action_t *ptr)
{
	return ptr->description;
}

idmef_value_t *idmef_action_get_description_value(idmef_action_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->description )
		return NULL;


	value = idmef_value_new_string(ptr->description);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_action_set_description:
 * @ptr: pointer to a #idmef_action_t object.
 * @description: pointer to a #prelude_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void idmef_action_set_description(idmef_action_t *ptr, prelude_string_t *description)
{
	if ( ptr->description )
		prelude_string_destroy(ptr->description);

	ptr->description = description;
}

/**
 * idmef_action_new_description:
 * @ptr: pointer to a #idmef_action_t object.
 *
 * Create a new description object, children of #idmef_action_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_action_new_description(idmef_action_t *ptr)
{
	if ( ptr->description )
		prelude_string_destroy(ptr->description);
		
	ptr->description = prelude_string_new();

	return ptr->description;
}

/**
 * idmef_confidence_new:
 * 
 * Create a new #idmef_confidence_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_confidence_t *idmef_confidence_new(void)
{
	idmef_confidence_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_confidence_ref:
 * @ptr: pointer to a #idmef_confidence_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_confidence_t *idmef_confidence_ref(idmef_confidence_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_confidence_get_child(void *p, idmef_child_t child)
{
	idmef_confidence_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_confidence_get_rating_value(ptr);

		case 1:
			return idmef_confidence_get_confidence_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_confidence_new_child(void *p, idmef_child_t child, int n)
{
	idmef_confidence_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_confidence_new_rating(ptr);

		case 1:
			return idmef_confidence_new_confidence(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_confidence_destroy_internal(idmef_confidence_t *ptr)
{


	/* free() should be done by the caller */
}

/**
 * idmef_confidence_destroy:
 * @ptr: pointer to a #idmef_confidence_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_confidence_destroy(idmef_confidence_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_confidence_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_confidence_get_rating:
 * @ptr: pointer to a #idmef_confidence_t object.
 *
 * Get rating children of the #idmef_confidence_t object.
 *
 * Returns: a pointer to a idmef_confidence_rating_t object, or NULL if the children object is not set.
 */
idmef_confidence_rating_t idmef_confidence_get_rating(idmef_confidence_t *ptr)
{
	return ptr->rating;
}

idmef_value_t *idmef_confidence_get_rating_value(idmef_confidence_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_CONFIDENCE_RATING, ptr->rating);

}

/**
 * idmef_confidence_set_rating:
 * @ptr: pointer to a #idmef_confidence_t object.
 * @rating: pointer to a #idmef_confidence_rating_t object.
 *
 * Set @rating object as a children of @ptr.
 * if @ptr already contain an @rating object, then it is destroyed,
 * and updated to point to the provided @rating object.
 */

void idmef_confidence_set_rating(idmef_confidence_t *ptr, idmef_confidence_rating_t rating)
{
	ptr->rating = rating;
}

/**
 * idmef_confidence_new_rating:
 * @ptr: pointer to a #idmef_confidence_t object.
 *
 * Create a new rating object, children of #idmef_confidence_t.
 * If @ptr already contain a #idmef_confidence_rating_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_confidence_rating_t *idmef_confidence_new_rating(idmef_confidence_t *ptr)
{
	return &ptr->rating;
}

/**
 * *idmef_confidence_get_confidence:
 * @ptr: pointer to a #idmef_confidence_t object.
 *
 * Get confidence children of the #idmef_confidence_t object.
 *
 * Returns: a pointer to a float object, or NULL if the children object is not set.
 */
float *idmef_confidence_get_confidence(idmef_confidence_t *ptr)
{
	return ptr->confidence_is_set ? &ptr->confidence : NULL;
}

idmef_value_t *idmef_confidence_get_confidence_value(idmef_confidence_t *ptr)
{
	return ptr->confidence_is_set ? idmef_value_new_float(ptr->confidence) : NULL;

}

/**
 * idmef_confidence_set_confidence:
 * @ptr: pointer to a #idmef_confidence_t object.
 * @confidence: pointer to a #float object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void idmef_confidence_set_confidence(idmef_confidence_t *ptr, float confidence)
{
	ptr->confidence = confidence;
	ptr->confidence_is_set = 1;
}

/**
 * idmef_confidence_new_confidence:
 * @ptr: pointer to a #idmef_confidence_t object.
 *
 * Create a new confidence object, children of #idmef_confidence_t.
 * If @ptr already contain a #float object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
float *idmef_confidence_new_confidence(idmef_confidence_t *ptr)
{
	ptr->confidence_is_set = 1;

	return &ptr->confidence;
}

/**
 * idmef_assessment_new:
 * 
 * Create a new #idmef_assessment_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_assessment_t *idmef_assessment_new(void)
{
	idmef_assessment_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->action_list);
    

	return ret;

}

/**
 * idmef_assessment_ref:
 * @ptr: pointer to a #idmef_assessment_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_assessment_t *idmef_assessment_ref(idmef_assessment_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_assessment_get_child(void *p, idmef_child_t child)
{
	idmef_assessment_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return ptr->impact;

		case 1:
			return &ptr->action_list;

		case 2:
			return ptr->confidence;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_assessment_new_child(void *p, idmef_child_t child, int n)
{
	idmef_assessment_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_assessment_new_impact(ptr);

		case 1: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_assessment_new_action(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->action_list) {
			    		entry = prelude_list_entry(tmp, idmef_action_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_assessment_new_action(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 2:
			return idmef_assessment_new_confidence(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_assessment_destroy_internal(idmef_assessment_t *ptr)
{

	if ( ptr->impact ) {
		idmef_impact_destroy(ptr->impact);
		ptr->impact = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_action_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->action_list) {
			entry = prelude_list_entry(tmp, idmef_action_t, list);
			prelude_list_del(&entry->list);
			idmef_action_destroy(entry);
		}
	}

	if ( ptr->confidence ) {
		idmef_confidence_destroy(ptr->confidence);
		ptr->confidence = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_assessment_destroy:
 * @ptr: pointer to a #idmef_assessment_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_assessment_destroy(idmef_assessment_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_assessment_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_assessment_get_impact:
 * @ptr: pointer to a #idmef_assessment_t object.
 *
 * Get impact children of the #idmef_assessment_t object.
 *
 * Returns: a pointer to a idmef_impact_t object, or NULL if the children object is not set.
 */
idmef_impact_t *idmef_assessment_get_impact(idmef_assessment_t *ptr)
{
	return ptr->impact;
}

idmef_value_t *idmef_assessment_get_impact_value(idmef_assessment_t *ptr)
{
	if ( ! ptr->impact )
		return NULL;

	return idmef_value_new_object(ptr->impact, IDMEF_OBJECT_TYPE_IMPACT);
}

/**
 * idmef_assessment_set_impact:
 * @ptr: pointer to a #idmef_assessment_t object.
 * @impact: pointer to a #idmef_impact_t object.
 *
 * Set @impact object as a children of @ptr.
 * if @ptr already contain an @impact object, then it is destroyed,
 * and updated to point to the provided @impact object.
 */

void idmef_assessment_set_impact(idmef_assessment_t *ptr, idmef_impact_t *impact)
{
	if ( ptr->impact )
		idmef_impact_destroy(ptr->impact);

	ptr->impact = impact;
}

/**
 * idmef_assessment_new_impact:
 * @ptr: pointer to a #idmef_assessment_t object.
 *
 * Create a new impact object, children of #idmef_assessment_t.
 * If @ptr already contain a #idmef_impact_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_impact_t *idmef_assessment_new_impact(idmef_assessment_t *ptr)
{
	if ( ! ptr->impact )
		ptr->impact = idmef_impact_new();

	return ptr->impact;
}

/**
 * idmef_assessment_get_next_action:
 * @ptr: pointer to a #idmef_assessment_t object.
 * @object: pointer to a #idmef_action_t object.
 *
 * Get the next #idmef_action_t object listed in @ptr.
 * When iterating over the idmef_action_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_action_t object.
 * 
 * Returns: the next #idmef_action_t in the list.
 */
idmef_action_t *idmef_assessment_get_next_action(idmef_assessment_t *ptr, idmef_action_t *object)
{
    	return prelude_list_get_next(object, &ptr->action_list, idmef_action_t, list);
}

/**
 * idmef_assessment_set_action:
 * @ptr: pointer to a #idmef_assessment_t object.
 * @object: pointer to a #idmef_action_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_action_t object.
 */
void idmef_assessment_set_action(idmef_assessment_t *ptr, idmef_action_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->action_list);
}

/**
 * idmef_assessment_new_HASH(0x8026160c):
 * @ptr: pointer to a #idmef_assessment_t object.
 * 
 * Create a new HASH(0x8026160c) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_action_t object.
 * 
 * Returns: a pointer to the created #idmef_action_t object, or NULL if an error occured.
 */
idmef_action_t *idmef_assessment_new_action(idmef_assessment_t *ptr)
{
	idmef_action_t *object;
	
	object = idmef_action_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->action_list);
	
	return object;
}

idmef_value_t *idmef_assessment_get_action_value(idmef_assessment_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_action_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->action_list) {
		entry = prelude_list_entry(tmp, idmef_action_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ACTION);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * *idmef_assessment_get_confidence:
 * @ptr: pointer to a #idmef_assessment_t object.
 *
 * Get confidence children of the #idmef_assessment_t object.
 *
 * Returns: a pointer to a idmef_confidence_t object, or NULL if the children object is not set.
 */
idmef_confidence_t *idmef_assessment_get_confidence(idmef_assessment_t *ptr)
{
	return ptr->confidence;
}

idmef_value_t *idmef_assessment_get_confidence_value(idmef_assessment_t *ptr)
{
	if ( ! ptr->confidence )
		return NULL;

	return idmef_value_new_object(ptr->confidence, IDMEF_OBJECT_TYPE_CONFIDENCE);
}

/**
 * idmef_assessment_set_confidence:
 * @ptr: pointer to a #idmef_assessment_t object.
 * @confidence: pointer to a #idmef_confidence_t object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void idmef_assessment_set_confidence(idmef_assessment_t *ptr, idmef_confidence_t *confidence)
{
	if ( ptr->confidence )
		idmef_confidence_destroy(ptr->confidence);

	ptr->confidence = confidence;
}

/**
 * idmef_assessment_new_confidence:
 * @ptr: pointer to a #idmef_assessment_t object.
 *
 * Create a new confidence object, children of #idmef_assessment_t.
 * If @ptr already contain a #idmef_confidence_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_confidence_t *idmef_assessment_new_confidence(idmef_assessment_t *ptr)
{
	if ( ! ptr->confidence )
		ptr->confidence = idmef_confidence_new();

	return ptr->confidence;
}

/**
 * idmef_tool_alert_new:
 * 
 * Create a new #idmef_tool_alert_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_tool_alert_t *idmef_tool_alert_new(void)
{
	idmef_tool_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->alertident_list);
    

	return ret;

}

/**
 * idmef_tool_alert_ref:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_tool_alert_t *idmef_tool_alert_ref(idmef_tool_alert_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_tool_alert_get_child(void *p, idmef_child_t child)
{
	idmef_tool_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_tool_alert_get_name_value(ptr);

		case 1:
			return idmef_tool_alert_get_command_value(ptr);

		case 2:
			return &ptr->alertident_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_tool_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_tool_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_tool_alert_new_name(ptr);

		case 1:
			return idmef_tool_alert_new_command(ptr);

		case 2: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_tool_alert_new_alertident(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->alertident_list) {
			    		entry = prelude_list_entry(tmp, idmef_alertident_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_tool_alert_new_alertident(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_tool_alert_destroy_internal(idmef_tool_alert_t *ptr)
{

	prelude_string_destroy_internal(&ptr->name);

	if ( ptr->command ) {
		prelude_string_destroy(ptr->command);
		ptr->command = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_alertident_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->alertident_list) {
			entry = prelude_list_entry(tmp, idmef_alertident_t, list);
			prelude_list_del(&entry->list);
			idmef_alertident_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_tool_alert_destroy:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_tool_alert_destroy(idmef_tool_alert_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_tool_alert_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_tool_alert_get_name:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 *
 * Get name children of the #idmef_tool_alert_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_tool_alert_get_name(idmef_tool_alert_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_tool_alert_get_name_value(idmef_tool_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_tool_alert_set_name:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_tool_alert_set_name(idmef_tool_alert_t *ptr, prelude_string_t *name)
{
	prelude_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

/**
 * idmef_tool_alert_new_name:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 *
 * Create a new name object, children of #idmef_tool_alert_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_tool_alert_new_name(idmef_tool_alert_t *ptr)
{
	prelude_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

/**
 * *idmef_tool_alert_get_command:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 *
 * Get command children of the #idmef_tool_alert_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_tool_alert_get_command(idmef_tool_alert_t *ptr)
{
	return ptr->command;
}

idmef_value_t *idmef_tool_alert_get_command_value(idmef_tool_alert_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->command )
		return NULL;


	value = idmef_value_new_string(ptr->command);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_tool_alert_set_command:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 * @command: pointer to a #prelude_string_t object.
 *
 * Set @command object as a children of @ptr.
 * if @ptr already contain an @command object, then it is destroyed,
 * and updated to point to the provided @command object.
 */

void idmef_tool_alert_set_command(idmef_tool_alert_t *ptr, prelude_string_t *command)
{
	if ( ptr->command )
		prelude_string_destroy(ptr->command);

	ptr->command = command;
}

/**
 * idmef_tool_alert_new_command:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 *
 * Create a new command object, children of #idmef_tool_alert_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_tool_alert_new_command(idmef_tool_alert_t *ptr)
{
	if ( ptr->command )
		prelude_string_destroy(ptr->command);
		
	ptr->command = prelude_string_new();

	return ptr->command;
}

/**
 * idmef_tool_alert_get_next_alertident:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 * @object: pointer to a #idmef_alertident_t object.
 *
 * Get the next #idmef_alertident_t object listed in @ptr.
 * When iterating over the idmef_alertident_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_alertident_t object.
 * 
 * Returns: the next #idmef_alertident_t in the list.
 */
idmef_alertident_t *idmef_tool_alert_get_next_alertident(idmef_tool_alert_t *ptr, idmef_alertident_t *object)
{
    	return prelude_list_get_next(object, &ptr->alertident_list, idmef_alertident_t, list);
}

/**
 * idmef_tool_alert_set_alertident:
 * @ptr: pointer to a #idmef_tool_alert_t object.
 * @object: pointer to a #idmef_alertident_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_alertident_t object.
 */
void idmef_tool_alert_set_alertident(idmef_tool_alert_t *ptr, idmef_alertident_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
}

/**
 * idmef_tool_alert_new_HASH(0x80262680):
 * @ptr: pointer to a #idmef_tool_alert_t object.
 * 
 * Create a new HASH(0x80262680) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_alertident_t object.
 * 
 * Returns: a pointer to the created #idmef_alertident_t object, or NULL if an error occured.
 */
idmef_alertident_t *idmef_tool_alert_new_alertident(idmef_tool_alert_t *ptr)
{
	idmef_alertident_t *object;
	
	object = idmef_alertident_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
	
	return object;
}

idmef_value_t *idmef_tool_alert_get_alertident_value(idmef_tool_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_alertident_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->alertident_list) {
		entry = prelude_list_entry(tmp, idmef_alertident_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ALERTIDENT);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_correlation_alert_new:
 * 
 * Create a new #idmef_correlation_alert_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_correlation_alert_t *idmef_correlation_alert_new(void)
{
	idmef_correlation_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->alertident_list);
    

	return ret;

}

/**
 * idmef_correlation_alert_ref:
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_correlation_alert_t *idmef_correlation_alert_ref(idmef_correlation_alert_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_correlation_alert_get_child(void *p, idmef_child_t child)
{
	idmef_correlation_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_correlation_alert_get_name_value(ptr);

		case 1:
			return &ptr->alertident_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_correlation_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_correlation_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_correlation_alert_new_name(ptr);

		case 1: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_correlation_alert_new_alertident(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->alertident_list) {
			    		entry = prelude_list_entry(tmp, idmef_alertident_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_correlation_alert_new_alertident(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_correlation_alert_destroy_internal(idmef_correlation_alert_t *ptr)
{

	prelude_string_destroy_internal(&ptr->name);

	{
		prelude_list_t *n, *tmp;
		idmef_alertident_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->alertident_list) {
			entry = prelude_list_entry(tmp, idmef_alertident_t, list);
			prelude_list_del(&entry->list);
			idmef_alertident_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_correlation_alert_destroy:
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_correlation_alert_destroy(idmef_correlation_alert_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_correlation_alert_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_correlation_alert_get_name:
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 *
 * Get name children of the #idmef_correlation_alert_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_correlation_alert_get_name(idmef_correlation_alert_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_correlation_alert_get_name_value(idmef_correlation_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_correlation_alert_set_name:
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 * @name: pointer to a #prelude_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void idmef_correlation_alert_set_name(idmef_correlation_alert_t *ptr, prelude_string_t *name)
{
	prelude_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

/**
 * idmef_correlation_alert_new_name:
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 *
 * Create a new name object, children of #idmef_correlation_alert_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_correlation_alert_new_name(idmef_correlation_alert_t *ptr)
{
	prelude_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

/**
 * idmef_correlation_alert_get_next_alertident:
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 * @object: pointer to a #idmef_alertident_t object.
 *
 * Get the next #idmef_alertident_t object listed in @ptr.
 * When iterating over the idmef_alertident_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_alertident_t object.
 * 
 * Returns: the next #idmef_alertident_t in the list.
 */
idmef_alertident_t *idmef_correlation_alert_get_next_alertident(idmef_correlation_alert_t *ptr, idmef_alertident_t *object)
{
    	return prelude_list_get_next(object, &ptr->alertident_list, idmef_alertident_t, list);
}

/**
 * idmef_correlation_alert_set_alertident:
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 * @object: pointer to a #idmef_alertident_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_alertident_t object.
 */
void idmef_correlation_alert_set_alertident(idmef_correlation_alert_t *ptr, idmef_alertident_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
}

/**
 * idmef_correlation_alert_new_HASH(0x80262860):
 * @ptr: pointer to a #idmef_correlation_alert_t object.
 * 
 * Create a new HASH(0x80262860) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_alertident_t object.
 * 
 * Returns: a pointer to the created #idmef_alertident_t object, or NULL if an error occured.
 */
idmef_alertident_t *idmef_correlation_alert_new_alertident(idmef_correlation_alert_t *ptr)
{
	idmef_alertident_t *object;
	
	object = idmef_alertident_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
	
	return object;
}

idmef_value_t *idmef_correlation_alert_get_alertident_value(idmef_correlation_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_alertident_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->alertident_list) {
		entry = prelude_list_entry(tmp, idmef_alertident_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ALERTIDENT);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_overflow_alert_new:
 * 
 * Create a new #idmef_overflow_alert_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_overflow_alert_t *idmef_overflow_alert_new(void)
{
	idmef_overflow_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_overflow_alert_ref:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_overflow_alert_t *idmef_overflow_alert_ref(idmef_overflow_alert_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_overflow_alert_get_child(void *p, idmef_child_t child)
{
	idmef_overflow_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_overflow_alert_get_program_value(ptr);

		case 1:
			return idmef_overflow_alert_get_size_value(ptr);

		case 2:
			return idmef_overflow_alert_get_buffer_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_overflow_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_overflow_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_overflow_alert_new_program(ptr);

		case 1:
			return idmef_overflow_alert_new_size(ptr);

		case 2:
			return idmef_overflow_alert_new_buffer(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_overflow_alert_destroy_internal(idmef_overflow_alert_t *ptr)
{

	prelude_string_destroy_internal(&ptr->program);

	if ( ptr->buffer ) {
		idmef_data_destroy(ptr->buffer);
		ptr->buffer = NULL;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_overflow_alert_destroy:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_overflow_alert_destroy(idmef_overflow_alert_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_overflow_alert_destroy_internal(ptr);
        free(ptr);
}

/**
 * *idmef_overflow_alert_get_program:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 *
 * Get program children of the #idmef_overflow_alert_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_overflow_alert_get_program(idmef_overflow_alert_t *ptr)
{
	return &ptr->program;
}

idmef_value_t *idmef_overflow_alert_get_program_value(idmef_overflow_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->program);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_overflow_alert_set_program:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 * @program: pointer to a #prelude_string_t object.
 *
 * Set @program object as a children of @ptr.
 * if @ptr already contain an @program object, then it is destroyed,
 * and updated to point to the provided @program object.
 */

void idmef_overflow_alert_set_program(idmef_overflow_alert_t *ptr, prelude_string_t *program)
{
	prelude_string_destroy_internal(&ptr->program);
	memcpy(&ptr->program, program, sizeof (ptr->program));
	free(program);
}

/**
 * idmef_overflow_alert_new_program:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 *
 * Create a new program object, children of #idmef_overflow_alert_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_overflow_alert_new_program(idmef_overflow_alert_t *ptr)
{
	prelude_string_destroy_internal(&ptr->program);

	return &ptr->program;
}

/**
 * *idmef_overflow_alert_get_size:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 *
 * Get size children of the #idmef_overflow_alert_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *idmef_overflow_alert_get_size(idmef_overflow_alert_t *ptr)
{
	return ptr->size_is_set ? &ptr->size : NULL;
}

idmef_value_t *idmef_overflow_alert_get_size_value(idmef_overflow_alert_t *ptr)
{
	return ptr->size_is_set ? idmef_value_new_uint32(ptr->size) : NULL;

}

/**
 * idmef_overflow_alert_set_size:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 * @size: pointer to a #uint32_t object.
 *
 * Set @size object as a children of @ptr.
 * if @ptr already contain an @size object, then it is destroyed,
 * and updated to point to the provided @size object.
 */

void idmef_overflow_alert_set_size(idmef_overflow_alert_t *ptr, uint32_t size)
{
	ptr->size = size;
	ptr->size_is_set = 1;
}

/**
 * idmef_overflow_alert_new_size:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 *
 * Create a new size object, children of #idmef_overflow_alert_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint32_t *idmef_overflow_alert_new_size(idmef_overflow_alert_t *ptr)
{
	ptr->size_is_set = 1;

	return &ptr->size;
}

/**
 * *idmef_overflow_alert_get_buffer:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 *
 * Get buffer children of the #idmef_overflow_alert_t object.
 *
 * Returns: a pointer to a idmef_data_t object, or NULL if the children object is not set.
 */
idmef_data_t *idmef_overflow_alert_get_buffer(idmef_overflow_alert_t *ptr)
{
	return ptr->buffer;
}

idmef_value_t *idmef_overflow_alert_get_buffer_value(idmef_overflow_alert_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->buffer )
		return NULL;


	value = idmef_value_new_data(ptr->buffer);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_overflow_alert_set_buffer:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 * @buffer: pointer to a #idmef_data_t object.
 *
 * Set @buffer object as a children of @ptr.
 * if @ptr already contain an @buffer object, then it is destroyed,
 * and updated to point to the provided @buffer object.
 */

void idmef_overflow_alert_set_buffer(idmef_overflow_alert_t *ptr, idmef_data_t *buffer)
{
	if ( ptr->buffer )
		idmef_data_destroy(ptr->buffer);

	ptr->buffer = buffer;
}

/**
 * idmef_overflow_alert_new_buffer:
 * @ptr: pointer to a #idmef_overflow_alert_t object.
 *
 * Create a new buffer object, children of #idmef_overflow_alert_t.
 * If @ptr already contain a #idmef_data_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_data_t *idmef_overflow_alert_new_buffer(idmef_overflow_alert_t *ptr)
{
	if ( ptr->buffer )
		idmef_data_destroy(ptr->buffer);
		
	ptr->buffer = idmef_data_new();

	return ptr->buffer;
}

/**
 * idmef_alert_new:
 * 
 * Create a new #idmef_alert_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_alert_t *idmef_alert_new(void)
{
	idmef_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->source_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->target_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->additional_data_list);
    

	return ret;

}

void *idmef_alert_get_child(void *p, idmef_child_t child)
{
	idmef_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_alert_get_messageid_value(ptr);

		case 1:
			return ptr->analyzer;

		case 2:
			return idmef_alert_get_create_time_value(ptr);

		case 3:
			return ptr->classification;

		case 4:
			return idmef_alert_get_detect_time_value(ptr);

		case 5:
			return idmef_alert_get_analyzer_time_value(ptr);

		case 6:
			return &ptr->source_list;

		case 7:
			return &ptr->target_list;

		case 8:
			return ptr->assessment;

		case 9:
			return &ptr->additional_data_list;

		case 10:
			return idmef_alert_get_type_value(ptr);

		case 11: 
			if ( ptr->type == IDMEF_ALERT_TYPE_TOOL ) 
				return ptr->detail.tool_alert;
			return NULL;   	   

		case 12: 
			if ( ptr->type == IDMEF_ALERT_TYPE_CORRELATION ) 
				return ptr->detail.correlation_alert;
			return NULL;   	   

		case 13: 
			if ( ptr->type == IDMEF_ALERT_TYPE_OVERFLOW ) 
				return ptr->detail.overflow_alert;
			return NULL;   	   

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_alert_new_messageid(ptr);

		case 1:
			return idmef_alert_new_analyzer(ptr);

		case 2:
			return idmef_alert_new_create_time(ptr);

		case 3:
			return idmef_alert_new_classification(ptr);

		case 4:
			return idmef_alert_new_detect_time(ptr);

		case 5:
			return idmef_alert_new_analyzer_time(ptr);

		case 6: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_alert_new_source(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->source_list) {
			    		entry = prelude_list_entry(tmp, idmef_source_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_alert_new_source(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 7: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_alert_new_target(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->target_list) {
			    		entry = prelude_list_entry(tmp, idmef_target_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_alert_new_target(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 8:
			return idmef_alert_new_assessment(ptr);

		case 9: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_alert_new_additional_data(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->additional_data_list) {
			    		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_alert_new_additional_data(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 11:
			return idmef_alert_new_tool_alert(ptr);

		case 12:
			return idmef_alert_new_correlation_alert(ptr);

		case 13:
			return idmef_alert_new_overflow_alert(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_alert_destroy_internal(idmef_alert_t *ptr)
{

	if ( ptr->analyzer ) {
		idmef_analyzer_destroy(ptr->analyzer);
		ptr->analyzer = NULL;
	}

	idmef_time_destroy_internal(&ptr->create_time);

	if ( ptr->classification ) {
		idmef_classification_destroy(ptr->classification);
		ptr->classification = NULL;
	}

	if ( ptr->detect_time ) {
		idmef_time_destroy(ptr->detect_time);
		ptr->detect_time = NULL;
	}

	if ( ptr->analyzer_time ) {
		idmef_time_destroy(ptr->analyzer_time);
		ptr->analyzer_time = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_source_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->source_list) {
			entry = prelude_list_entry(tmp, idmef_source_t, list);
			prelude_list_del(&entry->list);
			idmef_source_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		idmef_target_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->target_list) {
			entry = prelude_list_entry(tmp, idmef_target_t, list);
			prelude_list_del(&entry->list);
			idmef_target_destroy(entry);
		}
	}

	if ( ptr->assessment ) {
		idmef_assessment_destroy(ptr->assessment);
		ptr->assessment = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_additional_data_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->additional_data_list) {
			entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
			prelude_list_del(&entry->list);
			idmef_additional_data_destroy(entry);
		}
	}

	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			ptr->detail.tool_alert = NULL;
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			ptr->detail.correlation_alert = NULL;
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			ptr->detail.overflow_alert = NULL;
			break;

		default:
			break;
	}


	/* free() should be done by the caller */
}

/**
 * idmef_alert_destroy:
 * @ptr: pointer to a #idmef_alert_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_alert_destroy(idmef_alert_t *ptr)
{
	idmef_alert_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_alert_get_messageid:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Get messageid children of the #idmef_alert_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_alert_get_messageid(idmef_alert_t *ptr)
{
	return ptr->messageid;
}

idmef_value_t *idmef_alert_get_messageid_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->messageid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_alert_set_messageid:
 * @ptr: pointer to a #idmef_alert_t object.
 * @messageid: pointer to a #uint64_t object.
 *
 * Set @messageid object as a children of @ptr.
 * if @ptr already contain an @messageid object, then it is destroyed,
 * and updated to point to the provided @messageid object.
 */

void idmef_alert_set_messageid(idmef_alert_t *ptr, uint64_t messageid)
{
	ptr->messageid = messageid;
}

/**
 * idmef_alert_new_messageid:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new messageid object, children of #idmef_alert_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_alert_new_messageid(idmef_alert_t *ptr)
{
	return &ptr->messageid;
}

/**
 * *idmef_alert_get_analyzer:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Get analyzer children of the #idmef_alert_t object.
 *
 * Returns: a pointer to a idmef_analyzer_t object, or NULL if the children object is not set.
 */
idmef_analyzer_t *idmef_alert_get_analyzer(idmef_alert_t *ptr)
{
	return ptr->analyzer;
}

idmef_value_t *idmef_alert_get_analyzer_value(idmef_alert_t *ptr)
{
	if ( ! ptr->analyzer )
		return NULL;

	return idmef_value_new_object(ptr->analyzer, IDMEF_OBJECT_TYPE_ANALYZER);
}

/**
 * idmef_alert_set_analyzer:
 * @ptr: pointer to a #idmef_alert_t object.
 * @analyzer: pointer to a #idmef_analyzer_t object.
 *
 * Set @analyzer object as a children of @ptr.
 * if @ptr already contain an @analyzer object, then it is destroyed,
 * and updated to point to the provided @analyzer object.
 */

void idmef_alert_set_analyzer(idmef_alert_t *ptr, idmef_analyzer_t *analyzer)
{
	if ( ptr->analyzer )
		idmef_analyzer_destroy(ptr->analyzer);

	ptr->analyzer = analyzer;
}

/**
 * idmef_alert_new_analyzer:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new analyzer object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_analyzer_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_analyzer_t *idmef_alert_new_analyzer(idmef_alert_t *ptr)
{
	if ( ! ptr->analyzer )
		ptr->analyzer = idmef_analyzer_new();

	return ptr->analyzer;
}

/**
 * *idmef_alert_get_create_time:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Get create_time children of the #idmef_alert_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_alert_get_create_time(idmef_alert_t *ptr)
{
	return &ptr->create_time;
}

idmef_value_t *idmef_alert_get_create_time_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(&ptr->create_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_alert_set_create_time:
 * @ptr: pointer to a #idmef_alert_t object.
 * @create_time: pointer to a #idmef_time_t object.
 *
 * Set @create_time object as a children of @ptr.
 * if @ptr already contain an @create_time object, then it is destroyed,
 * and updated to point to the provided @create_time object.
 */

void idmef_alert_set_create_time(idmef_alert_t *ptr, idmef_time_t *create_time)
{
	idmef_time_destroy_internal(&ptr->create_time);
	memcpy(&ptr->create_time, create_time, sizeof (ptr->create_time));
	free(create_time);
}

/**
 * idmef_alert_new_create_time:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new create_time object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_alert_new_create_time(idmef_alert_t *ptr)
{
	idmef_time_destroy_internal(&ptr->create_time);

	return &ptr->create_time;
}

/**
 * *idmef_alert_get_classification:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Get classification children of the #idmef_alert_t object.
 *
 * Returns: a pointer to a idmef_classification_t object, or NULL if the children object is not set.
 */
idmef_classification_t *idmef_alert_get_classification(idmef_alert_t *ptr)
{
	return ptr->classification;
}

idmef_value_t *idmef_alert_get_classification_value(idmef_alert_t *ptr)
{
	if ( ! ptr->classification )
		return NULL;

	return idmef_value_new_object(ptr->classification, IDMEF_OBJECT_TYPE_CLASSIFICATION);
}

/**
 * idmef_alert_set_classification:
 * @ptr: pointer to a #idmef_alert_t object.
 * @classification: pointer to a #idmef_classification_t object.
 *
 * Set @classification object as a children of @ptr.
 * if @ptr already contain an @classification object, then it is destroyed,
 * and updated to point to the provided @classification object.
 */

void idmef_alert_set_classification(idmef_alert_t *ptr, idmef_classification_t *classification)
{
	if ( ptr->classification )
		idmef_classification_destroy(ptr->classification);

	ptr->classification = classification;
}

/**
 * idmef_alert_new_classification:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new classification object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_classification_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_classification_t *idmef_alert_new_classification(idmef_alert_t *ptr)
{
	if ( ! ptr->classification )
		ptr->classification = idmef_classification_new();

	return ptr->classification;
}

/**
 * *idmef_alert_get_detect_time:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Get detect_time children of the #idmef_alert_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_alert_get_detect_time(idmef_alert_t *ptr)
{
	return ptr->detect_time;
}

idmef_value_t *idmef_alert_get_detect_time_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->detect_time )
		return NULL;


	value = idmef_value_new_time(ptr->detect_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_alert_set_detect_time:
 * @ptr: pointer to a #idmef_alert_t object.
 * @detect_time: pointer to a #idmef_time_t object.
 *
 * Set @detect_time object as a children of @ptr.
 * if @ptr already contain an @detect_time object, then it is destroyed,
 * and updated to point to the provided @detect_time object.
 */

void idmef_alert_set_detect_time(idmef_alert_t *ptr, idmef_time_t *detect_time)
{
	if ( ptr->detect_time )
		idmef_time_destroy(ptr->detect_time);

	ptr->detect_time = detect_time;
}

/**
 * idmef_alert_new_detect_time:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new detect_time object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_alert_new_detect_time(idmef_alert_t *ptr)
{
	if ( ptr->detect_time )
		idmef_time_destroy(ptr->detect_time);
		
	ptr->detect_time = idmef_time_new();

	return ptr->detect_time;
}

/**
 * *idmef_alert_get_analyzer_time:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Get analyzer_time children of the #idmef_alert_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_alert_get_analyzer_time(idmef_alert_t *ptr)
{
	return ptr->analyzer_time;
}

idmef_value_t *idmef_alert_get_analyzer_time_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->analyzer_time )
		return NULL;


	value = idmef_value_new_time(ptr->analyzer_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_alert_set_analyzer_time:
 * @ptr: pointer to a #idmef_alert_t object.
 * @analyzer_time: pointer to a #idmef_time_t object.
 *
 * Set @analyzer_time object as a children of @ptr.
 * if @ptr already contain an @analyzer_time object, then it is destroyed,
 * and updated to point to the provided @analyzer_time object.
 */

void idmef_alert_set_analyzer_time(idmef_alert_t *ptr, idmef_time_t *analyzer_time)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);

	ptr->analyzer_time = analyzer_time;
}

/**
 * idmef_alert_new_analyzer_time:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new analyzer_time object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_alert_new_analyzer_time(idmef_alert_t *ptr)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);
		
	ptr->analyzer_time = idmef_time_new();

	return ptr->analyzer_time;
}

/**
 * idmef_alert_get_next_source:
 * @ptr: pointer to a #idmef_alert_t object.
 * @object: pointer to a #idmef_source_t object.
 *
 * Get the next #idmef_source_t object listed in @ptr.
 * When iterating over the idmef_source_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_source_t object.
 * 
 * Returns: the next #idmef_source_t in the list.
 */
idmef_source_t *idmef_alert_get_next_source(idmef_alert_t *ptr, idmef_source_t *object)
{
    	return prelude_list_get_next(object, &ptr->source_list, idmef_source_t, list);
}

/**
 * idmef_alert_set_source:
 * @ptr: pointer to a #idmef_alert_t object.
 * @object: pointer to a #idmef_source_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_source_t object.
 */
void idmef_alert_set_source(idmef_alert_t *ptr, idmef_source_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->source_list);
}

/**
 * idmef_alert_new_HASH(0x80264df8):
 * @ptr: pointer to a #idmef_alert_t object.
 * 
 * Create a new HASH(0x80264df8) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_source_t object.
 * 
 * Returns: a pointer to the created #idmef_source_t object, or NULL if an error occured.
 */
idmef_source_t *idmef_alert_new_source(idmef_alert_t *ptr)
{
	idmef_source_t *object;
	
	object = idmef_source_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->source_list);
	
	return object;
}

idmef_value_t *idmef_alert_get_source_value(idmef_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_source_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->source_list) {
		entry = prelude_list_entry(tmp, idmef_source_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_SOURCE);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_alert_get_next_target:
 * @ptr: pointer to a #idmef_alert_t object.
 * @object: pointer to a #idmef_target_t object.
 *
 * Get the next #idmef_target_t object listed in @ptr.
 * When iterating over the idmef_target_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_target_t object.
 * 
 * Returns: the next #idmef_target_t in the list.
 */
idmef_target_t *idmef_alert_get_next_target(idmef_alert_t *ptr, idmef_target_t *object)
{
    	return prelude_list_get_next(object, &ptr->target_list, idmef_target_t, list);
}

/**
 * idmef_alert_set_target:
 * @ptr: pointer to a #idmef_alert_t object.
 * @object: pointer to a #idmef_target_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_target_t object.
 */
void idmef_alert_set_target(idmef_alert_t *ptr, idmef_target_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->target_list);
}

/**
 * idmef_alert_new_HASH(0x80264e64):
 * @ptr: pointer to a #idmef_alert_t object.
 * 
 * Create a new HASH(0x80264e64) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_target_t object.
 * 
 * Returns: a pointer to the created #idmef_target_t object, or NULL if an error occured.
 */
idmef_target_t *idmef_alert_new_target(idmef_alert_t *ptr)
{
	idmef_target_t *object;
	
	object = idmef_target_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->target_list);
	
	return object;
}

idmef_value_t *idmef_alert_get_target_value(idmef_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_target_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->target_list) {
		entry = prelude_list_entry(tmp, idmef_target_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_TARGET);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * *idmef_alert_get_assessment:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Get assessment children of the #idmef_alert_t object.
 *
 * Returns: a pointer to a idmef_assessment_t object, or NULL if the children object is not set.
 */
idmef_assessment_t *idmef_alert_get_assessment(idmef_alert_t *ptr)
{
	return ptr->assessment;
}

idmef_value_t *idmef_alert_get_assessment_value(idmef_alert_t *ptr)
{
	if ( ! ptr->assessment )
		return NULL;

	return idmef_value_new_object(ptr->assessment, IDMEF_OBJECT_TYPE_ASSESSMENT);
}

/**
 * idmef_alert_set_assessment:
 * @ptr: pointer to a #idmef_alert_t object.
 * @assessment: pointer to a #idmef_assessment_t object.
 *
 * Set @assessment object as a children of @ptr.
 * if @ptr already contain an @assessment object, then it is destroyed,
 * and updated to point to the provided @assessment object.
 */

void idmef_alert_set_assessment(idmef_alert_t *ptr, idmef_assessment_t *assessment)
{
	if ( ptr->assessment )
		idmef_assessment_destroy(ptr->assessment);

	ptr->assessment = assessment;
}

/**
 * idmef_alert_new_assessment:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new assessment object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_assessment_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_assessment_t *idmef_alert_new_assessment(idmef_alert_t *ptr)
{
	if ( ! ptr->assessment )
		ptr->assessment = idmef_assessment_new();

	return ptr->assessment;
}

/**
 * idmef_alert_get_next_additional_data:
 * @ptr: pointer to a #idmef_alert_t object.
 * @object: pointer to a #idmef_additional_data_t object.
 *
 * Get the next #idmef_additional_data_t object listed in @ptr.
 * When iterating over the idmef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_additional_data_t object.
 * 
 * Returns: the next #idmef_additional_data_t in the list.
 */
idmef_additional_data_t *idmef_alert_get_next_additional_data(idmef_alert_t *ptr, idmef_additional_data_t *object)
{
    	return prelude_list_get_next(object, &ptr->additional_data_list, idmef_additional_data_t, list);
}

/**
 * idmef_alert_set_additional_data:
 * @ptr: pointer to a #idmef_alert_t object.
 * @object: pointer to a #idmef_additional_data_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_additional_data_t object.
 */
void idmef_alert_set_additional_data(idmef_alert_t *ptr, idmef_additional_data_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
}

/**
 * idmef_alert_new_HASH(0x802659a0):
 * @ptr: pointer to a #idmef_alert_t object.
 * 
 * Create a new HASH(0x802659a0) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_additional_data_t object.
 * 
 * Returns: a pointer to the created #idmef_additional_data_t object, or NULL if an error occured.
 */
idmef_additional_data_t *idmef_alert_new_additional_data(idmef_alert_t *ptr)
{
	idmef_additional_data_t *object;
	
	object = idmef_additional_data_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
	
	return object;
}

idmef_value_t *idmef_alert_get_additional_data_value(idmef_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_additional_data_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->additional_data_list) {
		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ADDITIONAL_DATA);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/** 
 * idmef_alert_get_type:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Access the type children of @ptr.
 *
 * Returns: a pointer to the #idmef_alert_type_t children, or NULL if it is not set.
 */
idmef_alert_type_t idmef_alert_get_type(idmef_alert_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_alert_get_type_value(idmef_alert_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ALERT_TYPE, ptr->type);
}

/** 
 * idmef_alert_get_tool_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Access the tool_alert children of @ptr.
 *
 * Returns: a pointer to the #idmef_tool_alert_t children, or NULL if it is not set.
 */
idmef_tool_alert_t *idmef_alert_get_tool_alert(idmef_alert_t *ptr)
{
	return (ptr->type == IDMEF_ALERT_TYPE_TOOL) ? ptr->detail.tool_alert : NULL;
}

/**
 * idmef_alert_set_tool_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 * @tool_alert: pointer to a #idmef_tool_alert_t object.
 *
 * Set @tool_alert object as a children of @ptr.
 * if @ptr already contain a @tool_alert object, then it is destroyed,
 * and updated to point to the provided @tool_alert object.
 */
void idmef_alert_set_tool_alert(idmef_alert_t *ptr, idmef_tool_alert_t *tool_alert)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.tool_alert = tool_alert;
	ptr->type = IDMEF_ALERT_TYPE_TOOL;
}

idmef_value_t *idmef_alert_get_tool_alert_value(idmef_alert_t *ptr)
{
	return ((ptr->type == IDMEF_ALERT_TYPE_TOOL) ?
		idmef_value_new_object(ptr->detail.tool_alert, IDMEF_OBJECT_TYPE_TOOL_ALERT) :
		NULL);
}

/**
 * idmef_alert_new_tool_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new tool_alert object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_tool_alert_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_tool_alert_t *idmef_alert_new_tool_alert(idmef_alert_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			return ptr->detail.tool_alert;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.tool_alert = idmef_tool_alert_new();
	ptr->type = IDMEF_ALERT_TYPE_TOOL;

	return ptr->detail.tool_alert;
}

/** 
 * idmef_alert_get_correlation_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Access the correlation_alert children of @ptr.
 *
 * Returns: a pointer to the #idmef_correlation_alert_t children, or NULL if it is not set.
 */
idmef_correlation_alert_t *idmef_alert_get_correlation_alert(idmef_alert_t *ptr)
{
	return (ptr->type == IDMEF_ALERT_TYPE_CORRELATION) ? ptr->detail.correlation_alert : NULL;
}

/**
 * idmef_alert_set_correlation_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 * @correlation_alert: pointer to a #idmef_correlation_alert_t object.
 *
 * Set @correlation_alert object as a children of @ptr.
 * if @ptr already contain a @correlation_alert object, then it is destroyed,
 * and updated to point to the provided @correlation_alert object.
 */
void idmef_alert_set_correlation_alert(idmef_alert_t *ptr, idmef_correlation_alert_t *correlation_alert)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.correlation_alert = correlation_alert;
	ptr->type = IDMEF_ALERT_TYPE_CORRELATION;
}

idmef_value_t *idmef_alert_get_correlation_alert_value(idmef_alert_t *ptr)
{
	return ((ptr->type == IDMEF_ALERT_TYPE_CORRELATION) ?
		idmef_value_new_object(ptr->detail.correlation_alert, IDMEF_OBJECT_TYPE_CORRELATION_ALERT) :
		NULL);
}

/**
 * idmef_alert_new_correlation_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new correlation_alert object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_correlation_alert_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_correlation_alert_t *idmef_alert_new_correlation_alert(idmef_alert_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			return ptr->detail.correlation_alert;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.correlation_alert = idmef_correlation_alert_new();
	ptr->type = IDMEF_ALERT_TYPE_CORRELATION;

	return ptr->detail.correlation_alert;
}

/** 
 * idmef_alert_get_overflow_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Access the overflow_alert children of @ptr.
 *
 * Returns: a pointer to the #idmef_overflow_alert_t children, or NULL if it is not set.
 */
idmef_overflow_alert_t *idmef_alert_get_overflow_alert(idmef_alert_t *ptr)
{
	return (ptr->type == IDMEF_ALERT_TYPE_OVERFLOW) ? ptr->detail.overflow_alert : NULL;
}

/**
 * idmef_alert_set_overflow_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 * @overflow_alert: pointer to a #idmef_overflow_alert_t object.
 *
 * Set @overflow_alert object as a children of @ptr.
 * if @ptr already contain a @overflow_alert object, then it is destroyed,
 * and updated to point to the provided @overflow_alert object.
 */
void idmef_alert_set_overflow_alert(idmef_alert_t *ptr, idmef_overflow_alert_t *overflow_alert)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.overflow_alert = overflow_alert;
	ptr->type = IDMEF_ALERT_TYPE_OVERFLOW;
}

idmef_value_t *idmef_alert_get_overflow_alert_value(idmef_alert_t *ptr)
{
	return ((ptr->type == IDMEF_ALERT_TYPE_OVERFLOW) ?
		idmef_value_new_object(ptr->detail.overflow_alert, IDMEF_OBJECT_TYPE_OVERFLOW_ALERT) :
		NULL);
}

/**
 * idmef_alert_new_overflow_alert:
 * @ptr: pointer to a #idmef_alert_t object.
 *
 * Create a new overflow_alert object, children of #idmef_alert_t.
 * If @ptr already contain a #idmef_overflow_alert_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_overflow_alert_t *idmef_alert_new_overflow_alert(idmef_alert_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			return ptr->detail.overflow_alert;

		default:
			break;
	}

	ptr->detail.overflow_alert = idmef_overflow_alert_new();
	ptr->type = IDMEF_ALERT_TYPE_OVERFLOW;

	return ptr->detail.overflow_alert;
}

/**
 * idmef_heartbeat_new:
 * 
 * Create a new #idmef_heartbeat_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_heartbeat_t *idmef_heartbeat_new(void)
{
	idmef_heartbeat_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->additional_data_list);
    

	return ret;

}

void *idmef_heartbeat_get_child(void *p, idmef_child_t child)
{
	idmef_heartbeat_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_heartbeat_get_messageid_value(ptr);

		case 1:
			return ptr->analyzer;

		case 2:
			return idmef_heartbeat_get_create_time_value(ptr);

		case 3:
			return idmef_heartbeat_get_analyzer_time_value(ptr);

		case 4:
			return &ptr->additional_data_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_heartbeat_new_child(void *p, idmef_child_t child, int n)
{
	idmef_heartbeat_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_heartbeat_new_messageid(ptr);

		case 1:
			return idmef_heartbeat_new_analyzer(ptr);

		case 2:
			return idmef_heartbeat_new_create_time(ptr);

		case 3:
			return idmef_heartbeat_new_analyzer_time(ptr);

		case 4: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_heartbeat_new_additional_data(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->additional_data_list) {
			    		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_heartbeat_new_additional_data(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_heartbeat_destroy_internal(idmef_heartbeat_t *ptr)
{

	if ( ptr->analyzer ) {
		idmef_analyzer_destroy(ptr->analyzer);
		ptr->analyzer = NULL;
	}

	idmef_time_destroy_internal(&ptr->create_time);

	if ( ptr->analyzer_time ) {
		idmef_time_destroy(ptr->analyzer_time);
		ptr->analyzer_time = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_additional_data_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->additional_data_list) {
			entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
			prelude_list_del(&entry->list);
			idmef_additional_data_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

/**
 * idmef_heartbeat_destroy:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * 
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void idmef_heartbeat_destroy(idmef_heartbeat_t *ptr)
{
	idmef_heartbeat_destroy_internal(ptr);
        free(ptr);
}

/**
 * idmef_heartbeat_get_messageid:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Get messageid children of the #idmef_heartbeat_t object.
 *
 * Returns: a pointer to a uint64_t object, or NULL if the children object is not set.
 */
uint64_t idmef_heartbeat_get_messageid(idmef_heartbeat_t *ptr)
{
	return ptr->messageid;
}

idmef_value_t *idmef_heartbeat_get_messageid_value(idmef_heartbeat_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->messageid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_heartbeat_set_messageid:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * @messageid: pointer to a #uint64_t object.
 *
 * Set @messageid object as a children of @ptr.
 * if @ptr already contain an @messageid object, then it is destroyed,
 * and updated to point to the provided @messageid object.
 */

void idmef_heartbeat_set_messageid(idmef_heartbeat_t *ptr, uint64_t messageid)
{
	ptr->messageid = messageid;
}

/**
 * idmef_heartbeat_new_messageid:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Create a new messageid object, children of #idmef_heartbeat_t.
 * If @ptr already contain a #uint64_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
uint64_t *idmef_heartbeat_new_messageid(idmef_heartbeat_t *ptr)
{
	return &ptr->messageid;
}

/**
 * *idmef_heartbeat_get_analyzer:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Get analyzer children of the #idmef_heartbeat_t object.
 *
 * Returns: a pointer to a idmef_analyzer_t object, or NULL if the children object is not set.
 */
idmef_analyzer_t *idmef_heartbeat_get_analyzer(idmef_heartbeat_t *ptr)
{
	return ptr->analyzer;
}

idmef_value_t *idmef_heartbeat_get_analyzer_value(idmef_heartbeat_t *ptr)
{
	if ( ! ptr->analyzer )
		return NULL;

	return idmef_value_new_object(ptr->analyzer, IDMEF_OBJECT_TYPE_ANALYZER);
}

/**
 * idmef_heartbeat_set_analyzer:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * @analyzer: pointer to a #idmef_analyzer_t object.
 *
 * Set @analyzer object as a children of @ptr.
 * if @ptr already contain an @analyzer object, then it is destroyed,
 * and updated to point to the provided @analyzer object.
 */

void idmef_heartbeat_set_analyzer(idmef_heartbeat_t *ptr, idmef_analyzer_t *analyzer)
{
	if ( ptr->analyzer )
		idmef_analyzer_destroy(ptr->analyzer);

	ptr->analyzer = analyzer;
}

/**
 * idmef_heartbeat_new_analyzer:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Create a new analyzer object, children of #idmef_heartbeat_t.
 * If @ptr already contain a #idmef_analyzer_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_analyzer_t *idmef_heartbeat_new_analyzer(idmef_heartbeat_t *ptr)
{
	if ( ! ptr->analyzer )
		ptr->analyzer = idmef_analyzer_new();

	return ptr->analyzer;
}

/**
 * *idmef_heartbeat_get_create_time:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Get create_time children of the #idmef_heartbeat_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_heartbeat_get_create_time(idmef_heartbeat_t *ptr)
{
	return &ptr->create_time;
}

idmef_value_t *idmef_heartbeat_get_create_time_value(idmef_heartbeat_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(&ptr->create_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_heartbeat_set_create_time:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * @create_time: pointer to a #idmef_time_t object.
 *
 * Set @create_time object as a children of @ptr.
 * if @ptr already contain an @create_time object, then it is destroyed,
 * and updated to point to the provided @create_time object.
 */

void idmef_heartbeat_set_create_time(idmef_heartbeat_t *ptr, idmef_time_t *create_time)
{
	idmef_time_destroy_internal(&ptr->create_time);
	memcpy(&ptr->create_time, create_time, sizeof (ptr->create_time));
	free(create_time);
}

/**
 * idmef_heartbeat_new_create_time:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Create a new create_time object, children of #idmef_heartbeat_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_heartbeat_new_create_time(idmef_heartbeat_t *ptr)
{
	idmef_time_destroy_internal(&ptr->create_time);

	return &ptr->create_time;
}

/**
 * *idmef_heartbeat_get_analyzer_time:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Get analyzer_time children of the #idmef_heartbeat_t object.
 *
 * Returns: a pointer to a idmef_time_t object, or NULL if the children object is not set.
 */
idmef_time_t *idmef_heartbeat_get_analyzer_time(idmef_heartbeat_t *ptr)
{
	return ptr->analyzer_time;
}

idmef_value_t *idmef_heartbeat_get_analyzer_time_value(idmef_heartbeat_t *ptr)
{
	idmef_value_t *value;
	if ( ! ptr->analyzer_time )
		return NULL;


	value = idmef_value_new_time(ptr->analyzer_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_heartbeat_set_analyzer_time:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * @analyzer_time: pointer to a #idmef_time_t object.
 *
 * Set @analyzer_time object as a children of @ptr.
 * if @ptr already contain an @analyzer_time object, then it is destroyed,
 * and updated to point to the provided @analyzer_time object.
 */

void idmef_heartbeat_set_analyzer_time(idmef_heartbeat_t *ptr, idmef_time_t *analyzer_time)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);

	ptr->analyzer_time = analyzer_time;
}

/**
 * idmef_heartbeat_new_analyzer_time:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 *
 * Create a new analyzer_time object, children of #idmef_heartbeat_t.
 * If @ptr already contain a #idmef_time_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_time_t *idmef_heartbeat_new_analyzer_time(idmef_heartbeat_t *ptr)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);
		
	ptr->analyzer_time = idmef_time_new();

	return ptr->analyzer_time;
}

/**
 * idmef_heartbeat_get_next_additional_data:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * @object: pointer to a #idmef_additional_data_t object.
 *
 * Get the next #idmef_additional_data_t object listed in @ptr.
 * When iterating over the idmef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #idmef_additional_data_t object.
 * 
 * Returns: the next #idmef_additional_data_t in the list.
 */
idmef_additional_data_t *idmef_heartbeat_get_next_additional_data(idmef_heartbeat_t *ptr, idmef_additional_data_t *object)
{
    	return prelude_list_get_next(object, &ptr->additional_data_list, idmef_additional_data_t, list);
}

/**
 * idmef_heartbeat_set_additional_data:
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * @object: pointer to a #idmef_additional_data_t object.
 *
 * Add @object to the tail of @ptr list of #idmef_additional_data_t object.
 */
void idmef_heartbeat_set_additional_data(idmef_heartbeat_t *ptr, idmef_additional_data_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
}

/**
 * idmef_heartbeat_new_HASH(0x80266754):
 * @ptr: pointer to a #idmef_heartbeat_t object.
 * 
 * Create a new HASH(0x80266754) children of @ptr,
 * and add it to the tail of @ptr list of #idmef_additional_data_t object.
 * 
 * Returns: a pointer to the created #idmef_additional_data_t object, or NULL if an error occured.
 */
idmef_additional_data_t *idmef_heartbeat_new_additional_data(idmef_heartbeat_t *ptr)
{
	idmef_additional_data_t *object;
	
	object = idmef_additional_data_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
	
	return object;
}

idmef_value_t *idmef_heartbeat_get_additional_data_value(idmef_heartbeat_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_additional_data_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->additional_data_list) {
		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ADDITIONAL_DATA);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


/**
 * idmef_message_new:
 * 
 * Create a new #idmef_message_t object.
 *
 * Returns: a pointer to the newly created object, or NULL if an error occured.
 */
idmef_message_t *idmef_message_new(void)
{
	idmef_message_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

/**
 * idmef_message_ref:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Increase @ptr reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @ptr.
 */
idmef_message_t *idmef_message_ref(idmef_message_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_message_get_child(void *p, idmef_child_t child)
{
	idmef_message_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_message_get_version_value(ptr);

		case 1:
			return idmef_message_get_type_value(ptr);

		case 2: 
			if ( ptr->type == IDMEF_MESSAGE_TYPE_ALERT ) 
				return ptr->message.alert;
			return NULL;   	   

		case 3: 
			if ( ptr->type == IDMEF_MESSAGE_TYPE_HEARTBEAT ) 
				return ptr->message.heartbeat;
			return NULL;   	   

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_message_new_child(void *p, idmef_child_t child, int n)
{
	idmef_message_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_message_new_version(ptr);

		case 2:
			return idmef_message_new_alert(ptr);

		case 3:
			return idmef_message_new_heartbeat(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_message_destroy_internal(idmef_message_t *ptr)
{

	prelude_string_destroy_internal(&ptr->version);

	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			ptr->message.alert = NULL;
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			ptr->message.heartbeat = NULL;
			break;

		default:
			break;
	}


	/* free() should be done by the caller */
}

/**
 * *idmef_message_get_version:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Get version children of the #idmef_message_t object.
 *
 * Returns: a pointer to a prelude_string_t object, or NULL if the children object is not set.
 */
prelude_string_t *idmef_message_get_version(idmef_message_t *ptr)
{
	return &ptr->version;
}

idmef_value_t *idmef_message_get_version_value(idmef_message_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->version);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

/**
 * idmef_message_set_version:
 * @ptr: pointer to a #idmef_message_t object.
 * @version: pointer to a #prelude_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void idmef_message_set_version(idmef_message_t *ptr, prelude_string_t *version)
{
	prelude_string_destroy_internal(&ptr->version);
	memcpy(&ptr->version, version, sizeof (ptr->version));
	free(version);
}

/**
 * idmef_message_new_version:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Create a new version object, children of #idmef_message_t.
 * If @ptr already contain a #prelude_string_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
prelude_string_t *idmef_message_new_version(idmef_message_t *ptr)
{
	prelude_string_destroy_internal(&ptr->version);

	return &ptr->version;
}

/** 
 * idmef_message_get_type:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Access the type children of @ptr.
 *
 * Returns: a pointer to the #idmef_message_type_t children, or NULL if it is not set.
 */
idmef_message_type_t idmef_message_get_type(idmef_message_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_message_get_type_value(idmef_message_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_MESSAGE_TYPE, ptr->type);
}

/** 
 * idmef_message_get_alert:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Access the alert children of @ptr.
 *
 * Returns: a pointer to the #idmef_alert_t children, or NULL if it is not set.
 */
idmef_alert_t *idmef_message_get_alert(idmef_message_t *ptr)
{
	return (ptr->type == IDMEF_MESSAGE_TYPE_ALERT) ? ptr->message.alert : NULL;
}

/**
 * idmef_message_set_alert:
 * @ptr: pointer to a #idmef_message_t object.
 * @alert: pointer to a #idmef_alert_t object.
 *
 * Set @alert object as a children of @ptr.
 * if @ptr already contain a @alert object, then it is destroyed,
 * and updated to point to the provided @alert object.
 */
void idmef_message_set_alert(idmef_message_t *ptr, idmef_alert_t *alert)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			break;

		default:
			break;
	}

	ptr->message.alert = alert;
	ptr->type = IDMEF_MESSAGE_TYPE_ALERT;
}

idmef_value_t *idmef_message_get_alert_value(idmef_message_t *ptr)
{
	return ((ptr->type == IDMEF_MESSAGE_TYPE_ALERT) ?
		idmef_value_new_object(ptr->message.alert, IDMEF_OBJECT_TYPE_ALERT) :
		NULL);
}

/**
 * idmef_message_new_alert:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Create a new alert object, children of #idmef_message_t.
 * If @ptr already contain a #idmef_alert_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_alert_t *idmef_message_new_alert(idmef_message_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			return ptr->message.alert;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			break;

		default:
			break;
	}

	ptr->message.alert = idmef_alert_new();
	ptr->type = IDMEF_MESSAGE_TYPE_ALERT;

	return ptr->message.alert;
}

/** 
 * idmef_message_get_heartbeat:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Access the heartbeat children of @ptr.
 *
 * Returns: a pointer to the #idmef_heartbeat_t children, or NULL if it is not set.
 */
idmef_heartbeat_t *idmef_message_get_heartbeat(idmef_message_t *ptr)
{
	return (ptr->type == IDMEF_MESSAGE_TYPE_HEARTBEAT) ? ptr->message.heartbeat : NULL;
}

/**
 * idmef_message_set_heartbeat:
 * @ptr: pointer to a #idmef_message_t object.
 * @heartbeat: pointer to a #idmef_heartbeat_t object.
 *
 * Set @heartbeat object as a children of @ptr.
 * if @ptr already contain a @heartbeat object, then it is destroyed,
 * and updated to point to the provided @heartbeat object.
 */
void idmef_message_set_heartbeat(idmef_message_t *ptr, idmef_heartbeat_t *heartbeat)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			break;

		default:
			break;
	}

	ptr->message.heartbeat = heartbeat;
	ptr->type = IDMEF_MESSAGE_TYPE_HEARTBEAT;
}

idmef_value_t *idmef_message_get_heartbeat_value(idmef_message_t *ptr)
{
	return ((ptr->type == IDMEF_MESSAGE_TYPE_HEARTBEAT) ?
		idmef_value_new_object(ptr->message.heartbeat, IDMEF_OBJECT_TYPE_HEARTBEAT) :
		NULL);
}

/**
 * idmef_message_new_heartbeat:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Create a new heartbeat object, children of #idmef_message_t.
 * If @ptr already contain a #idmef_heartbeat_t object, then it is destroyed.
 *
 * Returns: A pointer to the newly allocated object, or NULL if an error occured.
 */
idmef_heartbeat_t *idmef_message_new_heartbeat(idmef_message_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			return ptr->message.heartbeat;

		default:
			break;
	}

	ptr->message.heartbeat = idmef_heartbeat_new();
	ptr->type = IDMEF_MESSAGE_TYPE_HEARTBEAT;

	return ptr->message.heartbeat;
}

void idmef_message_set_pmsg(idmef_message_t *message, prelude_msg_t *msg)
{
        message->pmsg = msg;
}


prelude_msg_t *idmef_message_get_pmsg(idmef_message_t *message)
{
        return message->pmsg;
}


/**
 * idmef_message_destroy:
 * @ptr: pointer to a #idmef_message_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmef_message_destroy(idmef_message_t *ptr)
{
        if ( --ptr->refcount )
                return;

        idmef_message_destroy_internal(ptr);

        if ( ptr->pmsg )
                prelude_msg_destroy(ptr->pmsg);

        free(ptr);
}
