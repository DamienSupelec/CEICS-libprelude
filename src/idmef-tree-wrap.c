
/* Auto-generated by the GenerateIDMEFTreeWrapC package (Tue Jul 20 14:53:42 2004) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <strings.h>
#include <sys/types.h>

#include "prelude-list.h"

#include "idmef-string.h"
#include "idmef-time.h"
#include "idmef-data.h"
#include "idmef-type.h"
#include "idmef-value.h"

#include "idmef-tree.h"
#include "idmef-tree-wrap.h"



int idmef_additional_data_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "string" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_STRING;

	if ( strcasecmp(name, "boolean" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_BOOLEAN;

	if ( strcasecmp(name, "byte" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_BYTE;

	if ( strcasecmp(name, "character" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_CHARACTER;

	if ( strcasecmp(name, "date-time" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_DATE_TIME;

	if ( strcasecmp(name, "integer" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_INTEGER;

	if ( strcasecmp(name, "ntpstamp" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_NTPSTAMP;

	if ( strcasecmp(name, "portlist" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_PORTLIST;

	if ( strcasecmp(name, "real" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_REAL;

	if ( strcasecmp(name, "xml" ) == 0)
		return IDMEF_ADDITIONAL_DATA_TYPE_XML;


	return -1;
}	

const char *idmef_additional_data_type_to_string(int val)
{
	switch ( val ) {

		case IDMEF_ADDITIONAL_DATA_TYPE_STRING:
			return "string";

		case IDMEF_ADDITIONAL_DATA_TYPE_BOOLEAN:
			return "boolean";

		case IDMEF_ADDITIONAL_DATA_TYPE_BYTE:
			return "byte";

		case IDMEF_ADDITIONAL_DATA_TYPE_CHARACTER:
			return "character";

		case IDMEF_ADDITIONAL_DATA_TYPE_DATE_TIME:
			return "date-time";

		case IDMEF_ADDITIONAL_DATA_TYPE_INTEGER:
			return "integer";

		case IDMEF_ADDITIONAL_DATA_TYPE_NTPSTAMP:
			return "ntpstamp";

		case IDMEF_ADDITIONAL_DATA_TYPE_PORTLIST:
			return "portlist";

		case IDMEF_ADDITIONAL_DATA_TYPE_REAL:
			return "real";

		case IDMEF_ADDITIONAL_DATA_TYPE_XML:
			return "xml";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 *         idmef_additional_data_type_t type;
 *         idmef_string_t meaning;
 *         idmef_data_t data;
 * } TYPE_ID(idmef_additional_data_t, 4);
 */


idmef_additional_data_t *idmef_additional_data_new(void)
{
	idmef_additional_data_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_additional_data_t *idmef_additional_data_ref(idmef_additional_data_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_additional_data_get_child(void *p, idmef_child_t child)
{
	idmef_additional_data_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_additional_data_get_type_value(ptr);

		case 1:
			return idmef_additional_data_get_meaning_value(ptr);

		case 2:
			return idmef_additional_data_get_data_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_additional_data_new_child(void *p, idmef_child_t child, int n)
{
	idmef_additional_data_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_additional_data_new_type(ptr);

		case 1:
			return idmef_additional_data_new_meaning(ptr);

		case 2:
			return idmef_additional_data_new_data(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_additional_data_destroy_internal(idmef_additional_data_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->meaning);

	idmef_data_destroy_internal(&ptr->data);


	/* free() should be done by the caller */
}

void idmef_additional_data_destroy(idmef_additional_data_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_additional_data_destroy_internal(ptr);
        free(ptr);
}

idmef_additional_data_type_t idmef_additional_data_get_type(idmef_additional_data_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_additional_data_get_type_value(idmef_additional_data_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ADDITIONAL_DATA_TYPE, ptr->type);
}

void idmef_additional_data_set_type(idmef_additional_data_t *ptr, idmef_additional_data_type_t type)
{
	ptr->type = type;
}

idmef_additional_data_type_t *idmef_additional_data_new_type(idmef_additional_data_t *ptr)
{
	return &ptr->type;
}

idmef_string_t *idmef_additional_data_get_meaning(idmef_additional_data_t *ptr)
{
	return &ptr->meaning;
}

idmef_value_t *idmef_additional_data_get_meaning_value(idmef_additional_data_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->meaning);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_additional_data_set_meaning(idmef_additional_data_t *ptr, idmef_string_t *meaning)
{
	idmef_string_destroy_internal(&ptr->meaning);
	memcpy(&ptr->meaning, meaning, sizeof (ptr->meaning));
	free(meaning);
}

idmef_string_t *idmef_additional_data_new_meaning(idmef_additional_data_t *ptr)
{
	idmef_string_destroy_internal(&ptr->meaning);

	return &ptr->meaning;
}

idmef_data_t *idmef_additional_data_get_data(idmef_additional_data_t *ptr)
{
	return &ptr->data;
}

idmef_value_t *idmef_additional_data_get_data_value(idmef_additional_data_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_data(&ptr->data);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_additional_data_set_data(idmef_additional_data_t *ptr, idmef_data_t *data)
{
	idmef_data_destroy_internal(&ptr->data);
	memcpy(&ptr->data, data, sizeof (ptr->data));
	free(data);
}

idmef_data_t *idmef_additional_data_new_data(idmef_additional_data_t *ptr)
{
	idmef_data_destroy_internal(&ptr->data);

	return &ptr->data;
}

int idmef_classification_origin_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_CLASSIFICATION_ORIGIN_UNKNOWN;

	if ( strcasecmp(name, "bugtraqid" ) == 0)
		return IDMEF_CLASSIFICATION_ORIGIN_BUGTRAQID;

	if ( strcasecmp(name, "cve" ) == 0)
		return IDMEF_CLASSIFICATION_ORIGIN_CVE;

	if ( strcasecmp(name, "vendor-specific" ) == 0)
		return IDMEF_CLASSIFICATION_ORIGIN_VENDOR_SPECIFIC;

	if ( strcasecmp(name, "osvdb" ) == 0)
		return IDMEF_CLASSIFICATION_ORIGIN_OSVDB;


	return -1;
}	

const char *idmef_classification_origin_to_string(int val)
{
	switch ( val ) {

		case IDMEF_CLASSIFICATION_ORIGIN_UNKNOWN:
			return "unknown";

		case IDMEF_CLASSIFICATION_ORIGIN_BUGTRAQID:
			return "bugtraqid";

		case IDMEF_CLASSIFICATION_ORIGIN_CVE:
			return "cve";

		case IDMEF_CLASSIFICATION_ORIGIN_VENDOR_SPECIFIC:
			return "vendor-specific";

		case IDMEF_CLASSIFICATION_ORIGIN_OSVDB:
			return "osvdb";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 *         idmef_classification_origin_t origin;
 *         idmef_string_t name;
 *         idmef_string_t url;
 * } TYPE_ID(idmef_classification_t, 6);
 */


idmef_classification_t *idmef_classification_new(void)
{
	idmef_classification_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_classification_t *idmef_classification_ref(idmef_classification_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_classification_get_child(void *p, idmef_child_t child)
{
	idmef_classification_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_classification_get_origin_value(ptr);

		case 1:
			return idmef_classification_get_name_value(ptr);

		case 2:
			return idmef_classification_get_url_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_classification_new_child(void *p, idmef_child_t child, int n)
{
	idmef_classification_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_classification_new_origin(ptr);

		case 1:
			return idmef_classification_new_name(ptr);

		case 2:
			return idmef_classification_new_url(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_classification_destroy_internal(idmef_classification_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->name);

	idmef_string_destroy_internal(&ptr->url);


	/* free() should be done by the caller */
}

void idmef_classification_destroy(idmef_classification_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_classification_destroy_internal(ptr);
        free(ptr);
}

idmef_classification_origin_t idmef_classification_get_origin(idmef_classification_t *ptr)
{
	return ptr->origin;
}

idmef_value_t *idmef_classification_get_origin_value(idmef_classification_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_CLASSIFICATION_ORIGIN, ptr->origin);
}

void idmef_classification_set_origin(idmef_classification_t *ptr, idmef_classification_origin_t origin)
{
	ptr->origin = origin;
}

idmef_classification_origin_t *idmef_classification_new_origin(idmef_classification_t *ptr)
{
	return &ptr->origin;
}

idmef_string_t *idmef_classification_get_name(idmef_classification_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_classification_get_name_value(idmef_classification_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_classification_set_name(idmef_classification_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_classification_new_name(idmef_classification_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

idmef_string_t *idmef_classification_get_url(idmef_classification_t *ptr)
{
	return &ptr->url;
}

idmef_value_t *idmef_classification_get_url_value(idmef_classification_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->url);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_classification_set_url(idmef_classification_t *ptr, idmef_string_t *url)
{
	idmef_string_destroy_internal(&ptr->url);
	memcpy(&ptr->url, url, sizeof (ptr->url));
	free(url);
}

idmef_string_t *idmef_classification_new_url(idmef_classification_t *ptr)
{
	idmef_string_destroy_internal(&ptr->url);

	return &ptr->url;
}

int idmef_userid_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "original-user" ) == 0)
		return IDMEF_USERID_TYPE_ORIGINAL_USER;

	if ( strcasecmp(name, "current-user" ) == 0)
		return IDMEF_USERID_TYPE_CURRENT_USER;

	if ( strcasecmp(name, "target-user" ) == 0)
		return IDMEF_USERID_TYPE_TARGET_USER;

	if ( strcasecmp(name, "user-privs" ) == 0)
		return IDMEF_USERID_TYPE_USER_PRIVS;

	if ( strcasecmp(name, "current-group" ) == 0)
		return IDMEF_USERID_TYPE_CURRENT_GROUP;

	if ( strcasecmp(name, "group-privs" ) == 0)
		return IDMEF_USERID_TYPE_GROUP_PRIVS;

	if ( strcasecmp(name, "other-privs" ) == 0)
		return IDMEF_USERID_TYPE_OTHER_PRIVS;


	return -1;
}	

const char *idmef_userid_type_to_string(int val)
{
	switch ( val ) {

		case IDMEF_USERID_TYPE_ORIGINAL_USER:
			return "original-user";

		case IDMEF_USERID_TYPE_CURRENT_USER:
			return "current-user";

		case IDMEF_USERID_TYPE_TARGET_USER:
			return "target-user";

		case IDMEF_USERID_TYPE_USER_PRIVS:
			return "user-privs";

		case IDMEF_USERID_TYPE_CURRENT_GROUP:
			return "current-group";

		case IDMEF_USERID_TYPE_GROUP_PRIVS:
			return "group-privs";

		case IDMEF_USERID_TYPE_OTHER_PRIVS:
			return "other-privs";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 *         uint64_t ident;
 *         idmef_userid_type_t type;
 *         idmef_string_t name;
 *         uint32_t number;
 * } TYPE_ID(idmef_userid_t, 8);
 */


idmef_userid_t *idmef_userid_new(void)
{
	idmef_userid_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_userid_t *idmef_userid_ref(idmef_userid_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_userid_get_child(void *p, idmef_child_t child)
{
	idmef_userid_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_userid_get_ident_value(ptr);

		case 1:
			return idmef_userid_get_type_value(ptr);

		case 2:
			return idmef_userid_get_name_value(ptr);

		case 3:
			return idmef_userid_get_number_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_userid_new_child(void *p, idmef_child_t child, int n)
{
	idmef_userid_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_userid_new_ident(ptr);

		case 1:
			return idmef_userid_new_type(ptr);

		case 2:
			return idmef_userid_new_name(ptr);

		case 3:
			return idmef_userid_new_number(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_userid_destroy_internal(idmef_userid_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->name);


	/* free() should be done by the caller */
}

void idmef_userid_destroy(idmef_userid_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_userid_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_userid_get_ident(idmef_userid_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_userid_get_ident_value(idmef_userid_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_userid_set_ident(idmef_userid_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_userid_new_ident(idmef_userid_t *ptr)
{
	return &ptr->ident;
}

idmef_userid_type_t idmef_userid_get_type(idmef_userid_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_userid_get_type_value(idmef_userid_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_USERID_TYPE, ptr->type);
}

void idmef_userid_set_type(idmef_userid_t *ptr, idmef_userid_type_t type)
{
	ptr->type = type;
}

idmef_userid_type_t *idmef_userid_new_type(idmef_userid_t *ptr)
{
	return &ptr->type;
}

idmef_string_t *idmef_userid_get_name(idmef_userid_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_userid_get_name_value(idmef_userid_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_userid_set_name(idmef_userid_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_userid_new_name(idmef_userid_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

uint32_t idmef_userid_get_number(idmef_userid_t *ptr)
{
	return ptr->number;
}

idmef_value_t *idmef_userid_get_number_value(idmef_userid_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->number);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_userid_set_number(idmef_userid_t *ptr, uint32_t number)
{
	ptr->number = number;
}

uint32_t *idmef_userid_new_number(idmef_userid_t *ptr)
{
	return &ptr->number;
}

int idmef_user_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_USER_CATEGORY_UNKNOWN;

	if ( strcasecmp(name, "application" ) == 0)
		return IDMEF_USER_CATEGORY_APPLICATION;

	if ( strcasecmp(name, "os-device" ) == 0)
		return IDMEF_USER_CATEGORY_OS_DEVICE;


	return -1;
}	

const char *idmef_user_category_to_string(int val)
{
	switch ( val ) {

		case IDMEF_USER_CATEGORY_UNKNOWN:
			return "unknown";

		case IDMEF_USER_CATEGORY_APPLICATION:
			return "application";

		case IDMEF_USER_CATEGORY_OS_DEVICE:
			return "os-device";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         REFCOUNT;
 *         uint64_t ident;
 *         idmef_user_category_t category;
 *         LISTED_OBJECT(userid_list, idmef_userid_t);
 * } TYPE_ID(idmef_user_t, 10);
 */


idmef_user_t *idmef_user_new(void)
{
	idmef_user_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->userid_list);
    

	return ret;

}

idmef_user_t *idmef_user_ref(idmef_user_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_user_get_child(void *p, idmef_child_t child)
{
	idmef_user_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_user_get_ident_value(ptr);

		case 1:
			return idmef_user_get_category_value(ptr);

		case 2:
			return &ptr->userid_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_user_new_child(void *p, idmef_child_t child, int n)
{
	idmef_user_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_user_new_ident(ptr);

		case 1:
			return idmef_user_new_category(ptr);

		case 2: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_user_new_userid(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->userid_list) {
			    		entry = prelude_list_entry(tmp, idmef_userid_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_user_new_userid(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_user_destroy_internal(idmef_user_t *ptr)
{

	{
		prelude_list_t *n, *tmp;
		idmef_userid_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->userid_list) {
			entry = prelude_list_entry(tmp, idmef_userid_t, list);
			idmef_userid_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_user_destroy(idmef_user_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_user_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_user_get_ident(idmef_user_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_user_get_ident_value(idmef_user_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_user_set_ident(idmef_user_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_user_new_ident(idmef_user_t *ptr)
{
	return &ptr->ident;
}

idmef_user_category_t idmef_user_get_category(idmef_user_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_user_get_category_value(idmef_user_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_USER_CATEGORY, ptr->category);
}

void idmef_user_set_category(idmef_user_t *ptr, idmef_user_category_t category)
{
	ptr->category = category;
}

idmef_user_category_t *idmef_user_new_category(idmef_user_t *ptr)
{
	return &ptr->category;
}

    
idmef_userid_t *idmef_user_get_next_userid(idmef_user_t *ptr, idmef_userid_t *object)
{
    	return prelude_list_get_next(object, &ptr->userid_list, idmef_userid_t, list);
}

void idmef_user_set_userid(idmef_user_t *ptr, idmef_userid_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->userid_list);
}

idmef_userid_t *idmef_user_new_userid(idmef_user_t *ptr)
{
	idmef_userid_t *object;
	
	object = idmef_userid_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->userid_list);
	
	return object;
}

idmef_value_t *idmef_user_get_userid_value(idmef_user_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_userid_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->userid_list) {
		entry = prelude_list_entry(tmp, idmef_userid_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_USERID);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


int idmef_address_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_UNKNOWN;

	if ( strcasecmp(name, "atm" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_ATM;

	if ( strcasecmp(name, "e-mail" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_E_MAIL;

	if ( strcasecmp(name, "lotus-notes" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_LOTUS_NOTES;

	if ( strcasecmp(name, "mac" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_MAC;

	if ( strcasecmp(name, "sna" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_SNA;

	if ( strcasecmp(name, "vm" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_VM;

	if ( strcasecmp(name, "ipv4-addr" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_ADDR;

	if ( strcasecmp(name, "ipv4-addr-hex" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_ADDR_HEX;

	if ( strcasecmp(name, "ipv4-net" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_NET;

	if ( strcasecmp(name, "ipv4-net-mask" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV4_NET_MASK;

	if ( strcasecmp(name, "ipv6-addr" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_ADDR;

	if ( strcasecmp(name, "ipv6-addr-hex" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_ADDR_HEX;

	if ( strcasecmp(name, "ipv6-net" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_NET;

	if ( strcasecmp(name, "ipv6-net-mask" ) == 0)
		return IDMEF_ADDRESS_CATEGORY_IPV6_NET_MASK;


	return -1;
}	

const char *idmef_address_category_to_string(int val)
{
	switch ( val ) {

		case IDMEF_ADDRESS_CATEGORY_UNKNOWN:
			return "unknown";

		case IDMEF_ADDRESS_CATEGORY_ATM:
			return "atm";

		case IDMEF_ADDRESS_CATEGORY_E_MAIL:
			return "e-mail";

		case IDMEF_ADDRESS_CATEGORY_LOTUS_NOTES:
			return "lotus-notes";

		case IDMEF_ADDRESS_CATEGORY_MAC:
			return "mac";

		case IDMEF_ADDRESS_CATEGORY_SNA:
			return "sna";

		case IDMEF_ADDRESS_CATEGORY_VM:
			return "vm";

		case IDMEF_ADDRESS_CATEGORY_IPV4_ADDR:
			return "ipv4-addr";

		case IDMEF_ADDRESS_CATEGORY_IPV4_ADDR_HEX:
			return "ipv4-addr-hex";

		case IDMEF_ADDRESS_CATEGORY_IPV4_NET:
			return "ipv4-net";

		case IDMEF_ADDRESS_CATEGORY_IPV4_NET_MASK:
			return "ipv4-net-mask";

		case IDMEF_ADDRESS_CATEGORY_IPV6_ADDR:
			return "ipv6-addr";

		case IDMEF_ADDRESS_CATEGORY_IPV6_ADDR_HEX:
			return "ipv6-addr-hex";

		case IDMEF_ADDRESS_CATEGORY_IPV6_NET:
			return "ipv6-net";

		case IDMEF_ADDRESS_CATEGORY_IPV6_NET_MASK:
			return "ipv6-net-mask";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 *         uint64_t ident;
 *         idmef_address_category_t category;
 *         idmef_string_t vlan_name;
 *         uint32_t vlan_num;
 *         idmef_string_t address;
 *         idmef_string_t netmask;
 * } TYPE_ID(idmef_address_t, 12);
 */


idmef_address_t *idmef_address_new(void)
{
	idmef_address_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_address_t *idmef_address_ref(idmef_address_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_address_get_child(void *p, idmef_child_t child)
{
	idmef_address_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_address_get_ident_value(ptr);

		case 1:
			return idmef_address_get_category_value(ptr);

		case 2:
			return idmef_address_get_vlan_name_value(ptr);

		case 3:
			return idmef_address_get_vlan_num_value(ptr);

		case 4:
			return idmef_address_get_address_value(ptr);

		case 5:
			return idmef_address_get_netmask_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_address_new_child(void *p, idmef_child_t child, int n)
{
	idmef_address_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_address_new_ident(ptr);

		case 1:
			return idmef_address_new_category(ptr);

		case 2:
			return idmef_address_new_vlan_name(ptr);

		case 3:
			return idmef_address_new_vlan_num(ptr);

		case 4:
			return idmef_address_new_address(ptr);

		case 5:
			return idmef_address_new_netmask(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_address_destroy_internal(idmef_address_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->vlan_name);

	idmef_string_destroy_internal(&ptr->address);

	idmef_string_destroy_internal(&ptr->netmask);


	/* free() should be done by the caller */
}

void idmef_address_destroy(idmef_address_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_address_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_address_get_ident(idmef_address_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_address_get_ident_value(idmef_address_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_address_set_ident(idmef_address_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_address_new_ident(idmef_address_t *ptr)
{
	return &ptr->ident;
}

idmef_address_category_t idmef_address_get_category(idmef_address_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_address_get_category_value(idmef_address_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ADDRESS_CATEGORY, ptr->category);
}

void idmef_address_set_category(idmef_address_t *ptr, idmef_address_category_t category)
{
	ptr->category = category;
}

idmef_address_category_t *idmef_address_new_category(idmef_address_t *ptr)
{
	return &ptr->category;
}

idmef_string_t *idmef_address_get_vlan_name(idmef_address_t *ptr)
{
	return &ptr->vlan_name;
}

idmef_value_t *idmef_address_get_vlan_name_value(idmef_address_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->vlan_name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_address_set_vlan_name(idmef_address_t *ptr, idmef_string_t *vlan_name)
{
	idmef_string_destroy_internal(&ptr->vlan_name);
	memcpy(&ptr->vlan_name, vlan_name, sizeof (ptr->vlan_name));
	free(vlan_name);
}

idmef_string_t *idmef_address_new_vlan_name(idmef_address_t *ptr)
{
	idmef_string_destroy_internal(&ptr->vlan_name);

	return &ptr->vlan_name;
}

uint32_t idmef_address_get_vlan_num(idmef_address_t *ptr)
{
	return ptr->vlan_num;
}

idmef_value_t *idmef_address_get_vlan_num_value(idmef_address_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->vlan_num);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_address_set_vlan_num(idmef_address_t *ptr, uint32_t vlan_num)
{
	ptr->vlan_num = vlan_num;
}

uint32_t *idmef_address_new_vlan_num(idmef_address_t *ptr)
{
	return &ptr->vlan_num;
}

idmef_string_t *idmef_address_get_address(idmef_address_t *ptr)
{
	return &ptr->address;
}

idmef_value_t *idmef_address_get_address_value(idmef_address_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->address);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_address_set_address(idmef_address_t *ptr, idmef_string_t *address)
{
	idmef_string_destroy_internal(&ptr->address);
	memcpy(&ptr->address, address, sizeof (ptr->address));
	free(address);
}

idmef_string_t *idmef_address_new_address(idmef_address_t *ptr)
{
	idmef_string_destroy_internal(&ptr->address);

	return &ptr->address;
}

idmef_string_t *idmef_address_get_netmask(idmef_address_t *ptr)
{
	return &ptr->netmask;
}

idmef_value_t *idmef_address_get_netmask_value(idmef_address_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->netmask);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_address_set_netmask(idmef_address_t *ptr, idmef_string_t *netmask)
{
	idmef_string_destroy_internal(&ptr->netmask);
	memcpy(&ptr->netmask, netmask, sizeof (ptr->netmask));
	free(netmask);
}

idmef_string_t *idmef_address_new_netmask(idmef_address_t *ptr)
{
	idmef_string_destroy_internal(&ptr->netmask);

	return &ptr->netmask;
}


/*
 * typedef struct {
 *         REFCOUNT;
 *         uint64_t ident;
 *         idmef_string_t name;
 *         uint32_t pid;
 *         idmef_string_t path;
 * 
 *         LISTED_OBJECT(arg_list, idmef_string_t);
 *         LISTED_OBJECT(env_list, idmef_string_t);
 * } TYPE_ID(idmef_process_t, 13);
 */


idmef_process_t *idmef_process_new(void)
{
	idmef_process_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->arg_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->env_list);
    

	return ret;

}

idmef_process_t *idmef_process_ref(idmef_process_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_process_get_child(void *p, idmef_child_t child)
{
	idmef_process_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_process_get_ident_value(ptr);

		case 1:
			return idmef_process_get_name_value(ptr);

		case 2:
			return idmef_process_get_pid_value(ptr);

		case 3:
			return idmef_process_get_path_value(ptr);

		case 4:
			return &ptr->arg_list;

		case 5:
			return &ptr->env_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_process_new_child(void *p, idmef_child_t child, int n)
{
	idmef_process_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_process_new_ident(ptr);

		case 1:
			return idmef_process_new_name(ptr);

		case 2:
			return idmef_process_new_pid(ptr);

		case 3:
			return idmef_process_new_path(ptr);

		case 4: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_process_new_arg(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->arg_list) {
			    		entry = prelude_list_entry(tmp, idmef_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_process_new_arg(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 5: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_process_new_env(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->env_list) {
			    		entry = prelude_list_entry(tmp, idmef_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_process_new_env(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_process_destroy_internal(idmef_process_t *ptr)
{

	idmef_string_destroy_internal(&ptr->name);

	idmef_string_destroy_internal(&ptr->path);

	{
		prelude_list_t *n, *tmp;
		idmef_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->arg_list) {
			entry = prelude_list_entry(tmp, idmef_string_t, list);
			idmef_string_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		idmef_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->env_list) {
			entry = prelude_list_entry(tmp, idmef_string_t, list);
			idmef_string_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_process_destroy(idmef_process_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_process_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_process_get_ident(idmef_process_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_process_get_ident_value(idmef_process_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_process_set_ident(idmef_process_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_process_new_ident(idmef_process_t *ptr)
{
	return &ptr->ident;
}

idmef_string_t *idmef_process_get_name(idmef_process_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_process_get_name_value(idmef_process_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_process_set_name(idmef_process_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_process_new_name(idmef_process_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

uint32_t idmef_process_get_pid(idmef_process_t *ptr)
{
	return ptr->pid;
}

idmef_value_t *idmef_process_get_pid_value(idmef_process_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->pid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_process_set_pid(idmef_process_t *ptr, uint32_t pid)
{
	ptr->pid = pid;
}

uint32_t *idmef_process_new_pid(idmef_process_t *ptr)
{
	return &ptr->pid;
}

idmef_string_t *idmef_process_get_path(idmef_process_t *ptr)
{
	return &ptr->path;
}

idmef_value_t *idmef_process_get_path_value(idmef_process_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->path);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_process_set_path(idmef_process_t *ptr, idmef_string_t *path)
{
	idmef_string_destroy_internal(&ptr->path);
	memcpy(&ptr->path, path, sizeof (ptr->path));
	free(path);
}

idmef_string_t *idmef_process_new_path(idmef_process_t *ptr)
{
	idmef_string_destroy_internal(&ptr->path);

	return &ptr->path;
}

    
idmef_string_t *idmef_process_get_next_arg(idmef_process_t *ptr, idmef_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->arg_list, idmef_string_t, list);
}

void idmef_process_set_arg(idmef_process_t *ptr, idmef_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->arg_list);
}

idmef_string_t *idmef_process_new_arg(idmef_process_t *ptr)
{
	idmef_string_t *object;
	
	object = idmef_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->arg_list);
	
	return object;
}

idmef_value_t *idmef_process_get_arg_value(idmef_process_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->arg_list) {
		entry = prelude_list_entry(tmp, idmef_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


    
idmef_string_t *idmef_process_get_next_env(idmef_process_t *ptr, idmef_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->env_list, idmef_string_t, list);
}

void idmef_process_set_env(idmef_process_t *ptr, idmef_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->env_list);
}

idmef_string_t *idmef_process_new_env(idmef_process_t *ptr)
{
	idmef_string_t *object;
	
	object = idmef_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->env_list);
	
	return object;
}

idmef_value_t *idmef_process_get_env_value(idmef_process_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->env_list) {
		entry = prelude_list_entry(tmp, idmef_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}



/*
 * typedef struct {
 *         REFCOUNT;
 *         idmef_string_t url;
 *         idmef_string_t cgi;
 *         idmef_string_t http_method;
 *         LISTED_OBJECT(arg_list, idmef_string_t);
 * } TYPE_ID(idmef_webservice_t, 14);
 */


idmef_webservice_t *idmef_webservice_new(void)
{
	idmef_webservice_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->arg_list);
    

	return ret;

}

idmef_webservice_t *idmef_webservice_ref(idmef_webservice_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_webservice_get_child(void *p, idmef_child_t child)
{
	idmef_webservice_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_webservice_get_url_value(ptr);

		case 1:
			return idmef_webservice_get_cgi_value(ptr);

		case 2:
			return idmef_webservice_get_http_method_value(ptr);

		case 3:
			return &ptr->arg_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_webservice_new_child(void *p, idmef_child_t child, int n)
{
	idmef_webservice_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_webservice_new_url(ptr);

		case 1:
			return idmef_webservice_new_cgi(ptr);

		case 2:
			return idmef_webservice_new_http_method(ptr);

		case 3: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_webservice_new_arg(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->arg_list) {
			    		entry = prelude_list_entry(tmp, idmef_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_webservice_new_arg(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_webservice_destroy_internal(idmef_webservice_t *ptr)
{

	idmef_string_destroy_internal(&ptr->url);

	idmef_string_destroy_internal(&ptr->cgi);

	idmef_string_destroy_internal(&ptr->http_method);

	{
		prelude_list_t *n, *tmp;
		idmef_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->arg_list) {
			entry = prelude_list_entry(tmp, idmef_string_t, list);
			idmef_string_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_webservice_destroy(idmef_webservice_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_webservice_destroy_internal(ptr);
        free(ptr);
}

idmef_string_t *idmef_webservice_get_url(idmef_webservice_t *ptr)
{
	return &ptr->url;
}

idmef_value_t *idmef_webservice_get_url_value(idmef_webservice_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->url);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_webservice_set_url(idmef_webservice_t *ptr, idmef_string_t *url)
{
	idmef_string_destroy_internal(&ptr->url);
	memcpy(&ptr->url, url, sizeof (ptr->url));
	free(url);
}

idmef_string_t *idmef_webservice_new_url(idmef_webservice_t *ptr)
{
	idmef_string_destroy_internal(&ptr->url);

	return &ptr->url;
}

idmef_string_t *idmef_webservice_get_cgi(idmef_webservice_t *ptr)
{
	return &ptr->cgi;
}

idmef_value_t *idmef_webservice_get_cgi_value(idmef_webservice_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->cgi);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_webservice_set_cgi(idmef_webservice_t *ptr, idmef_string_t *cgi)
{
	idmef_string_destroy_internal(&ptr->cgi);
	memcpy(&ptr->cgi, cgi, sizeof (ptr->cgi));
	free(cgi);
}

idmef_string_t *idmef_webservice_new_cgi(idmef_webservice_t *ptr)
{
	idmef_string_destroy_internal(&ptr->cgi);

	return &ptr->cgi;
}

idmef_string_t *idmef_webservice_get_http_method(idmef_webservice_t *ptr)
{
	return &ptr->http_method;
}

idmef_value_t *idmef_webservice_get_http_method_value(idmef_webservice_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->http_method);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_webservice_set_http_method(idmef_webservice_t *ptr, idmef_string_t *http_method)
{
	idmef_string_destroy_internal(&ptr->http_method);
	memcpy(&ptr->http_method, http_method, sizeof (ptr->http_method));
	free(http_method);
}

idmef_string_t *idmef_webservice_new_http_method(idmef_webservice_t *ptr)
{
	idmef_string_destroy_internal(&ptr->http_method);

	return &ptr->http_method;
}

    
idmef_string_t *idmef_webservice_get_next_arg(idmef_webservice_t *ptr, idmef_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->arg_list, idmef_string_t, list);
}

void idmef_webservice_set_arg(idmef_webservice_t *ptr, idmef_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->arg_list);
}

idmef_string_t *idmef_webservice_new_arg(idmef_webservice_t *ptr)
{
	idmef_string_t *object;
	
	object = idmef_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->arg_list);
	
	return object;
}

idmef_value_t *idmef_webservice_get_arg_value(idmef_webservice_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->arg_list) {
		entry = prelude_list_entry(tmp, idmef_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}



/*
 * typedef struct {
 *         REFCOUNT;
 *         idmef_string_t oid;
 *         idmef_string_t community;
 *         idmef_string_t command;
 * } TYPE_ID(idmef_snmpservice_t, 15);
 */


idmef_snmpservice_t *idmef_snmpservice_new(void)
{
	idmef_snmpservice_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

idmef_snmpservice_t *idmef_snmpservice_ref(idmef_snmpservice_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_snmpservice_get_child(void *p, idmef_child_t child)
{
	idmef_snmpservice_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_snmpservice_get_oid_value(ptr);

		case 1:
			return idmef_snmpservice_get_community_value(ptr);

		case 2:
			return idmef_snmpservice_get_command_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_snmpservice_new_child(void *p, idmef_child_t child, int n)
{
	idmef_snmpservice_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_snmpservice_new_oid(ptr);

		case 1:
			return idmef_snmpservice_new_community(ptr);

		case 2:
			return idmef_snmpservice_new_command(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_snmpservice_destroy_internal(idmef_snmpservice_t *ptr)
{

	idmef_string_destroy_internal(&ptr->oid);

	idmef_string_destroy_internal(&ptr->community);

	idmef_string_destroy_internal(&ptr->command);


	/* free() should be done by the caller */
}

void idmef_snmpservice_destroy(idmef_snmpservice_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_snmpservice_destroy_internal(ptr);
        free(ptr);
}

idmef_string_t *idmef_snmpservice_get_oid(idmef_snmpservice_t *ptr)
{
	return &ptr->oid;
}

idmef_value_t *idmef_snmpservice_get_oid_value(idmef_snmpservice_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->oid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_snmpservice_set_oid(idmef_snmpservice_t *ptr, idmef_string_t *oid)
{
	idmef_string_destroy_internal(&ptr->oid);
	memcpy(&ptr->oid, oid, sizeof (ptr->oid));
	free(oid);
}

idmef_string_t *idmef_snmpservice_new_oid(idmef_snmpservice_t *ptr)
{
	idmef_string_destroy_internal(&ptr->oid);

	return &ptr->oid;
}

idmef_string_t *idmef_snmpservice_get_community(idmef_snmpservice_t *ptr)
{
	return &ptr->community;
}

idmef_value_t *idmef_snmpservice_get_community_value(idmef_snmpservice_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->community);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_snmpservice_set_community(idmef_snmpservice_t *ptr, idmef_string_t *community)
{
	idmef_string_destroy_internal(&ptr->community);
	memcpy(&ptr->community, community, sizeof (ptr->community));
	free(community);
}

idmef_string_t *idmef_snmpservice_new_community(idmef_snmpservice_t *ptr)
{
	idmef_string_destroy_internal(&ptr->community);

	return &ptr->community;
}

idmef_string_t *idmef_snmpservice_get_command(idmef_snmpservice_t *ptr)
{
	return &ptr->command;
}

idmef_value_t *idmef_snmpservice_get_command_value(idmef_snmpservice_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->command);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_snmpservice_set_command(idmef_snmpservice_t *ptr, idmef_string_t *command)
{
	idmef_string_destroy_internal(&ptr->command);
	memcpy(&ptr->command, command, sizeof (ptr->command));
	free(command);
}

idmef_string_t *idmef_snmpservice_new_command(idmef_snmpservice_t *ptr)
{
	idmef_string_destroy_internal(&ptr->command);

	return &ptr->command;
}

int idmef_service_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "default" ) == 0)
		return IDMEF_SERVICE_TYPE_DEFAULT;

	if ( strcasecmp(name, "web" ) == 0)
		return IDMEF_SERVICE_TYPE_WEB;

	if ( strcasecmp(name, "snmp" ) == 0)
		return IDMEF_SERVICE_TYPE_SNMP;


	return -1;
}	

const char *idmef_service_type_to_string(int val)
{
	switch ( val ) {

		case IDMEF_SERVICE_TYPE_DEFAULT:
			return "default";

		case IDMEF_SERVICE_TYPE_WEB:
			return "web";

		case IDMEF_SERVICE_TYPE_SNMP:
			return "snmp";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         REFCOUNT;
 *         uint64_t ident;
 *         idmef_string_t name;
 *         uint16_t port;
 *         idmef_string_t portlist;
 *         idmef_string_t protocol;
 * 
 *         UNION(idmef_service_type_t, type) {
 *                 UNION_MEMBER(IDMEF_SERVICE_TYPE_WEB, idmef_webservice_t, *web);
 *                 UNION_MEMBER(IDMEF_SERVICE_TYPE_SNMP, idmef_snmpservice_t, *snmp);
 *         } specific;
 * 
 * } TYPE_ID(idmef_service_t, 17);
 */


idmef_service_t *idmef_service_new(void)
{
	idmef_service_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

idmef_service_t *idmef_service_ref(idmef_service_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_service_get_child(void *p, idmef_child_t child)
{
	idmef_service_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_service_get_ident_value(ptr);

		case 1:
			return idmef_service_get_name_value(ptr);

		case 2:
			return idmef_service_get_port_value(ptr);

		case 3:
			return idmef_service_get_portlist_value(ptr);

		case 4:
			return idmef_service_get_protocol_value(ptr);

		case 5:
			return idmef_service_get_type_value(ptr);

		case 6: 
			if ( ptr->type == IDMEF_SERVICE_TYPE_WEB ) 
				return ptr->specific.web;
			return NULL;   	   

		case 7: 
			if ( ptr->type == IDMEF_SERVICE_TYPE_SNMP ) 
				return ptr->specific.snmp;
			return NULL;   	   

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_service_new_child(void *p, idmef_child_t child, int n)
{
	idmef_service_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_service_new_ident(ptr);

		case 1:
			return idmef_service_new_name(ptr);

		case 2:
			return idmef_service_new_port(ptr);

		case 3:
			return idmef_service_new_portlist(ptr);

		case 4:
			return idmef_service_new_protocol(ptr);

		case 6:
			return idmef_service_new_web(ptr);

		case 7:
			return idmef_service_new_snmp(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_service_destroy_internal(idmef_service_t *ptr)
{

	idmef_string_destroy_internal(&ptr->name);

	idmef_string_destroy_internal(&ptr->portlist);

	idmef_string_destroy_internal(&ptr->protocol);

	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_webservice_destroy(ptr->specific.web);
			ptr->specific.web = NULL;
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmpservice_destroy(ptr->specific.snmp);
			ptr->specific.snmp = NULL;
			break;

		default:
			break;
	}


	/* free() should be done by the caller */
}

void idmef_service_destroy(idmef_service_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_service_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_service_get_ident(idmef_service_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_service_get_ident_value(idmef_service_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_service_set_ident(idmef_service_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_service_new_ident(idmef_service_t *ptr)
{
	return &ptr->ident;
}

idmef_string_t *idmef_service_get_name(idmef_service_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_service_get_name_value(idmef_service_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_service_set_name(idmef_service_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_service_new_name(idmef_service_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

uint16_t idmef_service_get_port(idmef_service_t *ptr)
{
	return ptr->port;
}

idmef_value_t *idmef_service_get_port_value(idmef_service_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint16(ptr->port);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_service_set_port(idmef_service_t *ptr, uint16_t port)
{
	ptr->port = port;
}

uint16_t *idmef_service_new_port(idmef_service_t *ptr)
{
	return &ptr->port;
}

idmef_string_t *idmef_service_get_portlist(idmef_service_t *ptr)
{
	return &ptr->portlist;
}

idmef_value_t *idmef_service_get_portlist_value(idmef_service_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->portlist);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_service_set_portlist(idmef_service_t *ptr, idmef_string_t *portlist)
{
	idmef_string_destroy_internal(&ptr->portlist);
	memcpy(&ptr->portlist, portlist, sizeof (ptr->portlist));
	free(portlist);
}

idmef_string_t *idmef_service_new_portlist(idmef_service_t *ptr)
{
	idmef_string_destroy_internal(&ptr->portlist);

	return &ptr->portlist;
}

idmef_string_t *idmef_service_get_protocol(idmef_service_t *ptr)
{
	return &ptr->protocol;
}

idmef_value_t *idmef_service_get_protocol_value(idmef_service_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->protocol);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_service_set_protocol(idmef_service_t *ptr, idmef_string_t *protocol)
{
	idmef_string_destroy_internal(&ptr->protocol);
	memcpy(&ptr->protocol, protocol, sizeof (ptr->protocol));
	free(protocol);
}

idmef_string_t *idmef_service_new_protocol(idmef_service_t *ptr)
{
	idmef_string_destroy_internal(&ptr->protocol);

	return &ptr->protocol;
}

idmef_service_type_t idmef_service_get_type(idmef_service_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_service_get_type_value(idmef_service_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_SERVICE_TYPE, ptr->type);
}

idmef_webservice_t *idmef_service_get_web(idmef_service_t *ptr)
{
	return (ptr->type == IDMEF_SERVICE_TYPE_WEB) ? ptr->specific.web : NULL;
}

void idmef_service_set_web(idmef_service_t *ptr, idmef_webservice_t *web)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_webservice_destroy(ptr->specific.web);
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmpservice_destroy(ptr->specific.snmp);
			break;

		default:
			break;
	}

	ptr->specific.web = web;
	ptr->type = IDMEF_SERVICE_TYPE_WEB;
}

idmef_value_t *idmef_service_get_web_value(idmef_service_t *ptr)
{
	return ((ptr->type == IDMEF_SERVICE_TYPE_WEB) ?
		idmef_value_new_object(ptr->specific.web, IDMEF_OBJECT_TYPE_WEBSERVICE) :
		NULL);
}

idmef_webservice_t *idmef_service_new_web(idmef_service_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			return ptr->specific.web;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmpservice_destroy(ptr->specific.snmp);
			break;

		default:
			break;
	}

	ptr->specific.web = idmef_webservice_new();
	ptr->type = IDMEF_SERVICE_TYPE_WEB;

	return ptr->specific.web;
}

idmef_snmpservice_t *idmef_service_get_snmp(idmef_service_t *ptr)
{
	return (ptr->type == IDMEF_SERVICE_TYPE_SNMP) ? ptr->specific.snmp : NULL;
}

void idmef_service_set_snmp(idmef_service_t *ptr, idmef_snmpservice_t *snmp)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_webservice_destroy(ptr->specific.web);
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			idmef_snmpservice_destroy(ptr->specific.snmp);
			break;

		default:
			break;
	}

	ptr->specific.snmp = snmp;
	ptr->type = IDMEF_SERVICE_TYPE_SNMP;
}

idmef_value_t *idmef_service_get_snmp_value(idmef_service_t *ptr)
{
	return ((ptr->type == IDMEF_SERVICE_TYPE_SNMP) ?
		idmef_value_new_object(ptr->specific.snmp, IDMEF_OBJECT_TYPE_SNMPSERVICE) :
		NULL);
}

idmef_snmpservice_t *idmef_service_new_snmp(idmef_service_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_SERVICE_TYPE_WEB:
			idmef_webservice_destroy(ptr->specific.web);
			break;

		case IDMEF_SERVICE_TYPE_SNMP:
			return ptr->specific.snmp;

		default:
			break;
	}

	ptr->specific.snmp = idmef_snmpservice_new();
	ptr->type = IDMEF_SERVICE_TYPE_SNMP;

	return ptr->specific.snmp;
}

int idmef_node_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_NODE_CATEGORY_UNKNOWN;

	if ( strcasecmp(name, "ads" ) == 0)
		return IDMEF_NODE_CATEGORY_ADS;

	if ( strcasecmp(name, "afs" ) == 0)
		return IDMEF_NODE_CATEGORY_AFS;

	if ( strcasecmp(name, "coda" ) == 0)
		return IDMEF_NODE_CATEGORY_CODA;

	if ( strcasecmp(name, "dfs" ) == 0)
		return IDMEF_NODE_CATEGORY_DFS;

	if ( strcasecmp(name, "dns" ) == 0)
		return IDMEF_NODE_CATEGORY_DNS;

	if ( strcasecmp(name, "hosts" ) == 0)
		return IDMEF_NODE_CATEGORY_HOSTS;

	if ( strcasecmp(name, "kerberos" ) == 0)
		return IDMEF_NODE_CATEGORY_KERBEROS;

	if ( strcasecmp(name, "nds" ) == 0)
		return IDMEF_NODE_CATEGORY_NDS;

	if ( strcasecmp(name, "nis" ) == 0)
		return IDMEF_NODE_CATEGORY_NIS;

	if ( strcasecmp(name, "nisplus" ) == 0)
		return IDMEF_NODE_CATEGORY_NISPLUS;

	if ( strcasecmp(name, "nt" ) == 0)
		return IDMEF_NODE_CATEGORY_NT;

	if ( strcasecmp(name, "wfw" ) == 0)
		return IDMEF_NODE_CATEGORY_WFW;


	return -1;
}	

const char *idmef_node_category_to_string(int val)
{
	switch ( val ) {

		case IDMEF_NODE_CATEGORY_UNKNOWN:
			return "unknown";

		case IDMEF_NODE_CATEGORY_ADS:
			return "ads";

		case IDMEF_NODE_CATEGORY_AFS:
			return "afs";

		case IDMEF_NODE_CATEGORY_CODA:
			return "coda";

		case IDMEF_NODE_CATEGORY_DFS:
			return "dfs";

		case IDMEF_NODE_CATEGORY_DNS:
			return "dns";

		case IDMEF_NODE_CATEGORY_HOSTS:
			return "hosts";

		case IDMEF_NODE_CATEGORY_KERBEROS:
			return "kerberos";

		case IDMEF_NODE_CATEGORY_NDS:
			return "nds";

		case IDMEF_NODE_CATEGORY_NIS:
			return "nis";

		case IDMEF_NODE_CATEGORY_NISPLUS:
			return "nisplus";

		case IDMEF_NODE_CATEGORY_NT:
			return "nt";

		case IDMEF_NODE_CATEGORY_WFW:
			return "wfw";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         REFCOUNT;
 *         uint64_t ident;
 *         idmef_node_category_t category;
 *         idmef_string_t location;
 *         idmef_string_t name;
 *         LISTED_OBJECT(address_list, idmef_address_t);
 * } TYPE_ID(idmef_node_t, 19);
 */


idmef_node_t *idmef_node_new(void)
{
	idmef_node_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->address_list);
    

	return ret;

}

idmef_node_t *idmef_node_ref(idmef_node_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_node_get_child(void *p, idmef_child_t child)
{
	idmef_node_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_node_get_ident_value(ptr);

		case 1:
			return idmef_node_get_category_value(ptr);

		case 2:
			return idmef_node_get_location_value(ptr);

		case 3:
			return idmef_node_get_name_value(ptr);

		case 4:
			return &ptr->address_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_node_new_child(void *p, idmef_child_t child, int n)
{
	idmef_node_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_node_new_ident(ptr);

		case 1:
			return idmef_node_new_category(ptr);

		case 2:
			return idmef_node_new_location(ptr);

		case 3:
			return idmef_node_new_name(ptr);

		case 4: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_node_new_address(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->address_list) {
			    		entry = prelude_list_entry(tmp, idmef_address_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_node_new_address(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_node_destroy_internal(idmef_node_t *ptr)
{

	idmef_string_destroy_internal(&ptr->location);

	idmef_string_destroy_internal(&ptr->name);

	{
		prelude_list_t *n, *tmp;
		idmef_address_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->address_list) {
			entry = prelude_list_entry(tmp, idmef_address_t, list);
			idmef_address_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_node_destroy(idmef_node_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_node_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_node_get_ident(idmef_node_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_node_get_ident_value(idmef_node_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_node_set_ident(idmef_node_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_node_new_ident(idmef_node_t *ptr)
{
	return &ptr->ident;
}

idmef_node_category_t idmef_node_get_category(idmef_node_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_node_get_category_value(idmef_node_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_NODE_CATEGORY, ptr->category);
}

void idmef_node_set_category(idmef_node_t *ptr, idmef_node_category_t category)
{
	ptr->category = category;
}

idmef_node_category_t *idmef_node_new_category(idmef_node_t *ptr)
{
	return &ptr->category;
}

idmef_string_t *idmef_node_get_location(idmef_node_t *ptr)
{
	return &ptr->location;
}

idmef_value_t *idmef_node_get_location_value(idmef_node_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->location);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_node_set_location(idmef_node_t *ptr, idmef_string_t *location)
{
	idmef_string_destroy_internal(&ptr->location);
	memcpy(&ptr->location, location, sizeof (ptr->location));
	free(location);
}

idmef_string_t *idmef_node_new_location(idmef_node_t *ptr)
{
	idmef_string_destroy_internal(&ptr->location);

	return &ptr->location;
}

idmef_string_t *idmef_node_get_name(idmef_node_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_node_get_name_value(idmef_node_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_node_set_name(idmef_node_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_node_new_name(idmef_node_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

    
idmef_address_t *idmef_node_get_next_address(idmef_node_t *ptr, idmef_address_t *object)
{
    	return prelude_list_get_next(object, &ptr->address_list, idmef_address_t, list);
}

void idmef_node_set_address(idmef_node_t *ptr, idmef_address_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->address_list);
}

idmef_address_t *idmef_node_new_address(idmef_node_t *ptr)
{
	idmef_address_t *object;
	
	object = idmef_address_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->address_list);
	
	return object;
}

idmef_value_t *idmef_node_get_address_value(idmef_node_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_address_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->address_list) {
		entry = prelude_list_entry(tmp, idmef_address_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ADDRESS);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


int idmef_source_spoofed_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_SOURCE_SPOOFED_UNKNOWN;

	if ( strcasecmp(name, "yes" ) == 0)
		return IDMEF_SOURCE_SPOOFED_YES;

	if ( strcasecmp(name, "no" ) == 0)
		return IDMEF_SOURCE_SPOOFED_NO;


	return -1;
}	

const char *idmef_source_spoofed_to_string(int val)
{
	switch ( val ) {

		case IDMEF_SOURCE_SPOOFED_UNKNOWN:
			return "unknown";

		case IDMEF_SOURCE_SPOOFED_YES:
			return "yes";

		case IDMEF_SOURCE_SPOOFED_NO:
			return "no";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 * 
 *         uint64_t ident;
 *         idmef_source_spoofed_t spoofed;
 *         idmef_string_t interface;
 * 
 *         idmef_node_t *node;
 *         idmef_user_t *user;
 *         idmef_process_t *process;
 *         idmef_service_t *service;
 * 
 * } TYPE_ID(idmef_source_t, 21);
 */


idmef_source_t *idmef_source_new(void)
{
	idmef_source_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_source_t *idmef_source_ref(idmef_source_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_source_get_child(void *p, idmef_child_t child)
{
	idmef_source_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_source_get_ident_value(ptr);

		case 1:
			return idmef_source_get_spoofed_value(ptr);

		case 2:
			return idmef_source_get_interface_value(ptr);

		case 3:
			return ptr->node;

		case 4:
			return ptr->user;

		case 5:
			return ptr->process;

		case 6:
			return ptr->service;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_source_new_child(void *p, idmef_child_t child, int n)
{
	idmef_source_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_source_new_ident(ptr);

		case 1:
			return idmef_source_new_spoofed(ptr);

		case 2:
			return idmef_source_new_interface(ptr);

		case 3:
			return idmef_source_new_node(ptr);

		case 4:
			return idmef_source_new_user(ptr);

		case 5:
			return idmef_source_new_process(ptr);

		case 6:
			return idmef_source_new_service(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_source_destroy_internal(idmef_source_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->interface);

	if ( ptr->node ) {
		idmef_node_destroy(ptr->node);
		ptr->node = NULL;
	}

	if ( ptr->user ) {
		idmef_user_destroy(ptr->user);
		ptr->user = NULL;
	}

	if ( ptr->process ) {
		idmef_process_destroy(ptr->process);
		ptr->process = NULL;
	}

	if ( ptr->service ) {
		idmef_service_destroy(ptr->service);
		ptr->service = NULL;
	}


	/* free() should be done by the caller */
}

void idmef_source_destroy(idmef_source_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_source_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_source_get_ident(idmef_source_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_source_get_ident_value(idmef_source_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_source_set_ident(idmef_source_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_source_new_ident(idmef_source_t *ptr)
{
	return &ptr->ident;
}

idmef_source_spoofed_t idmef_source_get_spoofed(idmef_source_t *ptr)
{
	return ptr->spoofed;
}

idmef_value_t *idmef_source_get_spoofed_value(idmef_source_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_SOURCE_SPOOFED, ptr->spoofed);
}

void idmef_source_set_spoofed(idmef_source_t *ptr, idmef_source_spoofed_t spoofed)
{
	ptr->spoofed = spoofed;
}

idmef_source_spoofed_t *idmef_source_new_spoofed(idmef_source_t *ptr)
{
	return &ptr->spoofed;
}

idmef_string_t *idmef_source_get_interface(idmef_source_t *ptr)
{
	return &ptr->interface;
}

idmef_value_t *idmef_source_get_interface_value(idmef_source_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->interface);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_source_set_interface(idmef_source_t *ptr, idmef_string_t *interface)
{
	idmef_string_destroy_internal(&ptr->interface);
	memcpy(&ptr->interface, interface, sizeof (ptr->interface));
	free(interface);
}

idmef_string_t *idmef_source_new_interface(idmef_source_t *ptr)
{
	idmef_string_destroy_internal(&ptr->interface);

	return &ptr->interface;
}

idmef_node_t *idmef_source_get_node(idmef_source_t *ptr)
{
	return ptr->node;
}

idmef_value_t *idmef_source_get_node_value(idmef_source_t *ptr)
{
	return idmef_value_new_object(ptr->node, IDMEF_OBJECT_TYPE_NODE);
}

void idmef_source_set_node(idmef_source_t *ptr, idmef_node_t *node)
{
	if ( ptr->node )
		idmef_node_destroy(ptr->node);

	ptr->node = node;
}

idmef_node_t *idmef_source_new_node(idmef_source_t *ptr)
{
	if ( ! ptr->node )
		ptr->node = idmef_node_new();

	return ptr->node;
}

idmef_user_t *idmef_source_get_user(idmef_source_t *ptr)
{
	return ptr->user;
}

idmef_value_t *idmef_source_get_user_value(idmef_source_t *ptr)
{
	return idmef_value_new_object(ptr->user, IDMEF_OBJECT_TYPE_USER);
}

void idmef_source_set_user(idmef_source_t *ptr, idmef_user_t *user)
{
	if ( ptr->user )
		idmef_user_destroy(ptr->user);

	ptr->user = user;
}

idmef_user_t *idmef_source_new_user(idmef_source_t *ptr)
{
	if ( ! ptr->user )
		ptr->user = idmef_user_new();

	return ptr->user;
}

idmef_process_t *idmef_source_get_process(idmef_source_t *ptr)
{
	return ptr->process;
}

idmef_value_t *idmef_source_get_process_value(idmef_source_t *ptr)
{
	return idmef_value_new_object(ptr->process, IDMEF_OBJECT_TYPE_PROCESS);
}

void idmef_source_set_process(idmef_source_t *ptr, idmef_process_t *process)
{
	if ( ptr->process )
		idmef_process_destroy(ptr->process);

	ptr->process = process;
}

idmef_process_t *idmef_source_new_process(idmef_source_t *ptr)
{
	if ( ! ptr->process )
		ptr->process = idmef_process_new();

	return ptr->process;
}

idmef_service_t *idmef_source_get_service(idmef_source_t *ptr)
{
	return ptr->service;
}

idmef_value_t *idmef_source_get_service_value(idmef_source_t *ptr)
{
	return idmef_value_new_object(ptr->service, IDMEF_OBJECT_TYPE_SERVICE);
}

void idmef_source_set_service(idmef_source_t *ptr, idmef_service_t *service)
{
	if ( ptr->service )
		idmef_service_destroy(ptr->service);

	ptr->service = service;
}

idmef_service_t *idmef_source_new_service(idmef_source_t *ptr)
{
	if ( ! ptr->service )
		ptr->service = idmef_service_new();

	return ptr->service;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 * 
 *         idmef_userid_t userid;
 *         LISTED_OBJECT(permission_list, idmef_string_t);
 * } TYPE_ID(idmef_file_access_t, 22);
 */


idmef_file_access_t *idmef_file_access_new(void)
{
	idmef_file_access_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->permission_list);
    

	return ret;

}

idmef_file_access_t *idmef_file_access_ref(idmef_file_access_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_file_access_get_child(void *p, idmef_child_t child)
{
	idmef_file_access_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return &ptr->userid;

		case 1:
			return &ptr->permission_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_file_access_new_child(void *p, idmef_child_t child, int n)
{
	idmef_file_access_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_file_access_new_userid(ptr);

		case 1: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_file_access_new_permission(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->permission_list) {
			    		entry = prelude_list_entry(tmp, idmef_string_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_file_access_new_permission(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_file_access_destroy_internal(idmef_file_access_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_userid_destroy_internal(&ptr->userid);

	{
		prelude_list_t *n, *tmp;
		idmef_string_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->permission_list) {
			entry = prelude_list_entry(tmp, idmef_string_t, list);
			idmef_string_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_file_access_destroy(idmef_file_access_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_file_access_destroy_internal(ptr);
        free(ptr);
}

idmef_userid_t *idmef_file_access_get_userid(idmef_file_access_t *ptr)
{
	return &ptr->userid;
}

idmef_value_t *idmef_file_access_get_userid_value(idmef_file_access_t *ptr)
{
	return idmef_value_new_object(&ptr->userid, IDMEF_OBJECT_TYPE_USERID);
}

void idmef_file_access_set_userid(idmef_file_access_t *ptr, idmef_userid_t *userid)
{
	idmef_userid_destroy_internal(&ptr->userid);
	memcpy(&ptr->userid, userid, sizeof (ptr->userid));
	free(userid);
}

idmef_userid_t *idmef_file_access_new_userid(idmef_file_access_t *ptr)
{
	return &ptr->userid;
}

    
idmef_string_t *idmef_file_access_get_next_permission(idmef_file_access_t *ptr, idmef_string_t *object)
{
    	return prelude_list_get_next(object, &ptr->permission_list, idmef_string_t, list);
}

void idmef_file_access_set_permission(idmef_file_access_t *ptr, idmef_string_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->permission_list);
}

idmef_string_t *idmef_file_access_new_permission(idmef_file_access_t *ptr)
{
	idmef_string_t *object;
	
	object = idmef_string_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->permission_list);
	
	return object;
}

idmef_value_t *idmef_file_access_get_permission_value(idmef_file_access_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_string_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->permission_list) {
		entry = prelude_list_entry(tmp, idmef_string_t, list);

		val = idmef_value_new_string(entry);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}
		idmef_value_dont_have_own_data(val);

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}



/*
 * typedef struct {
 *         REFCOUNT;
 *         idmef_time_t *change_time;
 *         uint32_t number;
 *         uint32_t major_device;
 *         uint32_t minor_device;
 *         uint32_t c_major_device;
 *         uint32_t c_minor_device;
 * } TYPE_ID(idmef_inode_t, 23);
 */


idmef_inode_t *idmef_inode_new(void)
{
	idmef_inode_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

idmef_inode_t *idmef_inode_ref(idmef_inode_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_inode_get_child(void *p, idmef_child_t child)
{
	idmef_inode_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_inode_get_change_time_value(ptr);

		case 1:
			return idmef_inode_get_number_value(ptr);

		case 2:
			return idmef_inode_get_major_device_value(ptr);

		case 3:
			return idmef_inode_get_minor_device_value(ptr);

		case 4:
			return idmef_inode_get_c_major_device_value(ptr);

		case 5:
			return idmef_inode_get_c_minor_device_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_inode_new_child(void *p, idmef_child_t child, int n)
{
	idmef_inode_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_inode_new_change_time(ptr);

		case 1:
			return idmef_inode_new_number(ptr);

		case 2:
			return idmef_inode_new_major_device(ptr);

		case 3:
			return idmef_inode_new_minor_device(ptr);

		case 4:
			return idmef_inode_new_c_major_device(ptr);

		case 5:
			return idmef_inode_new_c_minor_device(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_inode_destroy_internal(idmef_inode_t *ptr)
{

	if ( ptr->change_time ) {
		idmef_time_destroy(ptr->change_time);
		ptr->change_time = NULL;
	}


	/* free() should be done by the caller */
}

void idmef_inode_destroy(idmef_inode_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_inode_destroy_internal(ptr);
        free(ptr);
}

idmef_time_t *idmef_inode_get_change_time(idmef_inode_t *ptr)
{
	return ptr->change_time;
}

idmef_value_t *idmef_inode_get_change_time_value(idmef_inode_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(ptr->change_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_inode_set_change_time(idmef_inode_t *ptr, idmef_time_t *change_time)
{
	if ( ptr->change_time )
		idmef_time_destroy(ptr->change_time);

	ptr->change_time = change_time;
}

idmef_time_t *idmef_inode_new_change_time(idmef_inode_t *ptr)
{
	if ( ptr->change_time )
		idmef_time_destroy(ptr->change_time);
		
	ptr->change_time = idmef_time_new();

	return ptr->change_time;
}

uint32_t idmef_inode_get_number(idmef_inode_t *ptr)
{
	return ptr->number;
}

idmef_value_t *idmef_inode_get_number_value(idmef_inode_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->number);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_inode_set_number(idmef_inode_t *ptr, uint32_t number)
{
	ptr->number = number;
}

uint32_t *idmef_inode_new_number(idmef_inode_t *ptr)
{
	return &ptr->number;
}

uint32_t idmef_inode_get_major_device(idmef_inode_t *ptr)
{
	return ptr->major_device;
}

idmef_value_t *idmef_inode_get_major_device_value(idmef_inode_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->major_device);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_inode_set_major_device(idmef_inode_t *ptr, uint32_t major_device)
{
	ptr->major_device = major_device;
}

uint32_t *idmef_inode_new_major_device(idmef_inode_t *ptr)
{
	return &ptr->major_device;
}

uint32_t idmef_inode_get_minor_device(idmef_inode_t *ptr)
{
	return ptr->minor_device;
}

idmef_value_t *idmef_inode_get_minor_device_value(idmef_inode_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->minor_device);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_inode_set_minor_device(idmef_inode_t *ptr, uint32_t minor_device)
{
	ptr->minor_device = minor_device;
}

uint32_t *idmef_inode_new_minor_device(idmef_inode_t *ptr)
{
	return &ptr->minor_device;
}

uint32_t idmef_inode_get_c_major_device(idmef_inode_t *ptr)
{
	return ptr->c_major_device;
}

idmef_value_t *idmef_inode_get_c_major_device_value(idmef_inode_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->c_major_device);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_inode_set_c_major_device(idmef_inode_t *ptr, uint32_t c_major_device)
{
	ptr->c_major_device = c_major_device;
}

uint32_t *idmef_inode_new_c_major_device(idmef_inode_t *ptr)
{
	return &ptr->c_major_device;
}

uint32_t idmef_inode_get_c_minor_device(idmef_inode_t *ptr)
{
	return ptr->c_minor_device;
}

idmef_value_t *idmef_inode_get_c_minor_device_value(idmef_inode_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->c_minor_device);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_inode_set_c_minor_device(idmef_inode_t *ptr, uint32_t c_minor_device)
{
	ptr->c_minor_device = c_minor_device;
}

uint32_t *idmef_inode_new_c_minor_device(idmef_inode_t *ptr)
{
	return &ptr->c_minor_device;
}

int idmef_file_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "current" ) == 0)
		return IDMEF_FILE_CATEGORY_CURRENT;

	if ( strcasecmp(name, "original" ) == 0)
		return IDMEF_FILE_CATEGORY_ORIGINAL;


	return -1;
}	

const char *idmef_file_category_to_string(int val)
{
	switch ( val ) {

		case 0:
			return "NULL";

		case IDMEF_FILE_CATEGORY_CURRENT:
			return "current";

		case IDMEF_FILE_CATEGORY_ORIGINAL:
			return "original";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}

int idmef_file_fstype_to_numeric(const char *name)
{

	if ( strcasecmp(name, "ufs" ) == 0)
		return IDMEF_FILE_FSTYPE_UFS;

	if ( strcasecmp(name, "efs" ) == 0)
		return IDMEF_FILE_FSTYPE_EFS;

	if ( strcasecmp(name, "nfs" ) == 0)
		return IDMEF_FILE_FSTYPE_NFS;

	if ( strcasecmp(name, "afs" ) == 0)
		return IDMEF_FILE_FSTYPE_AFS;

	if ( strcasecmp(name, "ntfs" ) == 0)
		return IDMEF_FILE_FSTYPE_NTFS;

	if ( strcasecmp(name, "fat16" ) == 0)
		return IDMEF_FILE_FSTYPE_FAT16;

	if ( strcasecmp(name, "fat32" ) == 0)
		return IDMEF_FILE_FSTYPE_FAT32;

	if ( strcasecmp(name, "pcfs" ) == 0)
		return IDMEF_FILE_FSTYPE_PCFS;

	if ( strcasecmp(name, "joliet" ) == 0)
		return IDMEF_FILE_FSTYPE_JOLIET;

	if ( strcasecmp(name, "iso9660" ) == 0)
		return IDMEF_FILE_FSTYPE_ISO9660;


	return -1;
}	

const char *idmef_file_fstype_to_string(int val)
{
	switch ( val ) {

		case 0:
			return "NULL";

		case IDMEF_FILE_FSTYPE_UFS:
			return "ufs";

		case IDMEF_FILE_FSTYPE_EFS:
			return "efs";

		case IDMEF_FILE_FSTYPE_NFS:
			return "nfs";

		case IDMEF_FILE_FSTYPE_AFS:
			return "afs";

		case IDMEF_FILE_FSTYPE_NTFS:
			return "ntfs";

		case IDMEF_FILE_FSTYPE_FAT16:
			return "fat16";

		case IDMEF_FILE_FSTYPE_FAT32:
			return "fat32";

		case IDMEF_FILE_FSTYPE_PCFS:
			return "pcfs";

		case IDMEF_FILE_FSTYPE_JOLIET:
			return "joliet";

		case IDMEF_FILE_FSTYPE_ISO9660:
			return "iso9660";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 * 
 *         uint64_t ident;
 *         idmef_file_category_t category;
 *         idmef_file_fstype_t fstype;
 * 
 *         idmef_string_t name;
 *         idmef_string_t path;
 * 
 *         idmef_time_t *create_time;
 *         idmef_time_t *modify_time;
 *         idmef_time_t *access_time;
 * 
 *         uint32_t data_size;
 *         uint32_t disk_size;
 * 
 *         LISTED_OBJECT(file_access_list, idmef_file_access_t);
 *         LISTED_OBJECT(file_linkage_list, idmef_linkage_t);
 * 
 *         idmef_inode_t *inode;
 * } TYPE_ID(idmef_file_t, 26);
 */


idmef_file_t *idmef_file_new(void)
{
	idmef_file_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->file_access_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->file_linkage_list);
    

	return ret;

}

idmef_file_t *idmef_file_ref(idmef_file_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_file_get_child(void *p, idmef_child_t child)
{
	idmef_file_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_file_get_ident_value(ptr);

		case 1:
			return idmef_file_get_category_value(ptr);

		case 2:
			return idmef_file_get_fstype_value(ptr);

		case 3:
			return idmef_file_get_name_value(ptr);

		case 4:
			return idmef_file_get_path_value(ptr);

		case 5:
			return idmef_file_get_create_time_value(ptr);

		case 6:
			return idmef_file_get_modify_time_value(ptr);

		case 7:
			return idmef_file_get_access_time_value(ptr);

		case 8:
			return idmef_file_get_data_size_value(ptr);

		case 9:
			return idmef_file_get_disk_size_value(ptr);

		case 10:
			return &ptr->file_access_list;

		case 11:
			return &ptr->file_linkage_list;

		case 12:
			return ptr->inode;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_file_new_child(void *p, idmef_child_t child, int n)
{
	idmef_file_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_file_new_ident(ptr);

		case 1:
			return idmef_file_new_category(ptr);

		case 2:
			return idmef_file_new_fstype(ptr);

		case 3:
			return idmef_file_new_name(ptr);

		case 4:
			return idmef_file_new_path(ptr);

		case 5:
			return idmef_file_new_create_time(ptr);

		case 6:
			return idmef_file_new_modify_time(ptr);

		case 7:
			return idmef_file_new_access_time(ptr);

		case 8:
			return idmef_file_new_data_size(ptr);

		case 9:
			return idmef_file_new_disk_size(ptr);

		case 10: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_file_new_file_access(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->file_access_list) {
			    		entry = prelude_list_entry(tmp, idmef_file_access_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_file_new_file_access(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 11: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_file_new_file_linkage(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->file_linkage_list) {
			    		entry = prelude_list_entry(tmp, idmef_linkage_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_file_new_file_linkage(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 12:
			return idmef_file_new_inode(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_file_destroy_internal(idmef_file_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->name);

	idmef_string_destroy_internal(&ptr->path);

	if ( ptr->create_time ) {
		idmef_time_destroy(ptr->create_time);
		ptr->create_time = NULL;
	}

	if ( ptr->modify_time ) {
		idmef_time_destroy(ptr->modify_time);
		ptr->modify_time = NULL;
	}

	if ( ptr->access_time ) {
		idmef_time_destroy(ptr->access_time);
		ptr->access_time = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_file_access_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->file_access_list) {
			entry = prelude_list_entry(tmp, idmef_file_access_t, list);
			idmef_file_access_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		idmef_linkage_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->file_linkage_list) {
			entry = prelude_list_entry(tmp, idmef_linkage_t, list);
			idmef_linkage_destroy(entry);
		}
	}

	if ( ptr->inode ) {
		idmef_inode_destroy(ptr->inode);
		ptr->inode = NULL;
	}


	/* free() should be done by the caller */
}

void idmef_file_destroy(idmef_file_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_file_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_file_get_ident(idmef_file_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_file_get_ident_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_ident(idmef_file_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_file_new_ident(idmef_file_t *ptr)
{
	return &ptr->ident;
}

idmef_file_category_t idmef_file_get_category(idmef_file_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_file_get_category_value(idmef_file_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_FILE_CATEGORY, ptr->category);
}

void idmef_file_set_category(idmef_file_t *ptr, idmef_file_category_t category)
{
	ptr->category = category;
}

idmef_file_category_t *idmef_file_new_category(idmef_file_t *ptr)
{
	return &ptr->category;
}

idmef_file_fstype_t idmef_file_get_fstype(idmef_file_t *ptr)
{
	return ptr->fstype;
}

idmef_value_t *idmef_file_get_fstype_value(idmef_file_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_FILE_FSTYPE, ptr->fstype);
}

void idmef_file_set_fstype(idmef_file_t *ptr, idmef_file_fstype_t fstype)
{
	ptr->fstype = fstype;
}

idmef_file_fstype_t *idmef_file_new_fstype(idmef_file_t *ptr)
{
	return &ptr->fstype;
}

idmef_string_t *idmef_file_get_name(idmef_file_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_file_get_name_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_name(idmef_file_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_file_new_name(idmef_file_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

idmef_string_t *idmef_file_get_path(idmef_file_t *ptr)
{
	return &ptr->path;
}

idmef_value_t *idmef_file_get_path_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->path);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_path(idmef_file_t *ptr, idmef_string_t *path)
{
	idmef_string_destroy_internal(&ptr->path);
	memcpy(&ptr->path, path, sizeof (ptr->path));
	free(path);
}

idmef_string_t *idmef_file_new_path(idmef_file_t *ptr)
{
	idmef_string_destroy_internal(&ptr->path);

	return &ptr->path;
}

idmef_time_t *idmef_file_get_create_time(idmef_file_t *ptr)
{
	return ptr->create_time;
}

idmef_value_t *idmef_file_get_create_time_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(ptr->create_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_create_time(idmef_file_t *ptr, idmef_time_t *create_time)
{
	if ( ptr->create_time )
		idmef_time_destroy(ptr->create_time);

	ptr->create_time = create_time;
}

idmef_time_t *idmef_file_new_create_time(idmef_file_t *ptr)
{
	if ( ptr->create_time )
		idmef_time_destroy(ptr->create_time);
		
	ptr->create_time = idmef_time_new();

	return ptr->create_time;
}

idmef_time_t *idmef_file_get_modify_time(idmef_file_t *ptr)
{
	return ptr->modify_time;
}

idmef_value_t *idmef_file_get_modify_time_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(ptr->modify_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_modify_time(idmef_file_t *ptr, idmef_time_t *modify_time)
{
	if ( ptr->modify_time )
		idmef_time_destroy(ptr->modify_time);

	ptr->modify_time = modify_time;
}

idmef_time_t *idmef_file_new_modify_time(idmef_file_t *ptr)
{
	if ( ptr->modify_time )
		idmef_time_destroy(ptr->modify_time);
		
	ptr->modify_time = idmef_time_new();

	return ptr->modify_time;
}

idmef_time_t *idmef_file_get_access_time(idmef_file_t *ptr)
{
	return ptr->access_time;
}

idmef_value_t *idmef_file_get_access_time_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(ptr->access_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_access_time(idmef_file_t *ptr, idmef_time_t *access_time)
{
	if ( ptr->access_time )
		idmef_time_destroy(ptr->access_time);

	ptr->access_time = access_time;
}

idmef_time_t *idmef_file_new_access_time(idmef_file_t *ptr)
{
	if ( ptr->access_time )
		idmef_time_destroy(ptr->access_time);
		
	ptr->access_time = idmef_time_new();

	return ptr->access_time;
}

uint32_t idmef_file_get_data_size(idmef_file_t *ptr)
{
	return ptr->data_size;
}

idmef_value_t *idmef_file_get_data_size_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->data_size);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_data_size(idmef_file_t *ptr, uint32_t data_size)
{
	ptr->data_size = data_size;
}

uint32_t *idmef_file_new_data_size(idmef_file_t *ptr)
{
	return &ptr->data_size;
}

uint32_t idmef_file_get_disk_size(idmef_file_t *ptr)
{
	return ptr->disk_size;
}

idmef_value_t *idmef_file_get_disk_size_value(idmef_file_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint32(ptr->disk_size);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_file_set_disk_size(idmef_file_t *ptr, uint32_t disk_size)
{
	ptr->disk_size = disk_size;
}

uint32_t *idmef_file_new_disk_size(idmef_file_t *ptr)
{
	return &ptr->disk_size;
}

    
idmef_file_access_t *idmef_file_get_next_file_access(idmef_file_t *ptr, idmef_file_access_t *object)
{
    	return prelude_list_get_next(object, &ptr->file_access_list, idmef_file_access_t, list);
}

void idmef_file_set_file_access(idmef_file_t *ptr, idmef_file_access_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->file_access_list);
}

idmef_file_access_t *idmef_file_new_file_access(idmef_file_t *ptr)
{
	idmef_file_access_t *object;
	
	object = idmef_file_access_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->file_access_list);
	
	return object;
}

idmef_value_t *idmef_file_get_file_access_value(idmef_file_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_file_access_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->file_access_list) {
		entry = prelude_list_entry(tmp, idmef_file_access_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_FILE_ACCESS);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


    
idmef_linkage_t *idmef_file_get_next_file_linkage(idmef_file_t *ptr, idmef_linkage_t *object)
{
    	return prelude_list_get_next(object, &ptr->file_linkage_list, idmef_linkage_t, list);
}

void idmef_file_set_file_linkage(idmef_file_t *ptr, idmef_linkage_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->file_linkage_list);
}

idmef_linkage_t *idmef_file_new_file_linkage(idmef_file_t *ptr)
{
	idmef_linkage_t *object;
	
	object = idmef_linkage_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->file_linkage_list);
	
	return object;
}

idmef_value_t *idmef_file_get_file_linkage_value(idmef_file_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_linkage_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->file_linkage_list) {
		entry = prelude_list_entry(tmp, idmef_linkage_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_LINKAGE);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


idmef_inode_t *idmef_file_get_inode(idmef_file_t *ptr)
{
	return ptr->inode;
}

idmef_value_t *idmef_file_get_inode_value(idmef_file_t *ptr)
{
	return idmef_value_new_object(ptr->inode, IDMEF_OBJECT_TYPE_INODE);
}

void idmef_file_set_inode(idmef_file_t *ptr, idmef_inode_t *inode)
{
	if ( ptr->inode )
		idmef_inode_destroy(ptr->inode);

	ptr->inode = inode;
}

idmef_inode_t *idmef_file_new_inode(idmef_file_t *ptr)
{
	if ( ! ptr->inode )
		ptr->inode = idmef_inode_new();

	return ptr->inode;
}

int idmef_linkage_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "hard-link" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_HARD_LINK;

	if ( strcasecmp(name, "mount-point" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_MOUNT_POINT;

	if ( strcasecmp(name, "reparse-point" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_REPARSE_POINT;

	if ( strcasecmp(name, "shortcut" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_SHORTCUT;

	if ( strcasecmp(name, "stream" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_STREAM;

	if ( strcasecmp(name, "symbolic-link" ) == 0)
		return IDMEF_LINKAGE_CATEGORY_SYMBOLIC_LINK;


	return -1;
}	

const char *idmef_linkage_category_to_string(int val)
{
	switch ( val ) {

		case 0:
			return "NULL";

		case IDMEF_LINKAGE_CATEGORY_HARD_LINK:
			return "hard-link";

		case IDMEF_LINKAGE_CATEGORY_MOUNT_POINT:
			return "mount-point";

		case IDMEF_LINKAGE_CATEGORY_REPARSE_POINT:
			return "reparse-point";

		case IDMEF_LINKAGE_CATEGORY_SHORTCUT:
			return "shortcut";

		case IDMEF_LINKAGE_CATEGORY_STREAM:
			return "stream";

		case IDMEF_LINKAGE_CATEGORY_SYMBOLIC_LINK:
			return "symbolic-link";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 * 
 *         idmef_linkage_category_t category;
 *         idmef_string_t name;
 *         idmef_string_t path;
 *         idmef_file_t *file;
 * } TYPE_ID(idmef_linkage_t, 28);
 */


idmef_linkage_t *idmef_linkage_new(void)
{
	idmef_linkage_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_linkage_t *idmef_linkage_ref(idmef_linkage_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_linkage_get_child(void *p, idmef_child_t child)
{
	idmef_linkage_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_linkage_get_category_value(ptr);

		case 1:
			return idmef_linkage_get_name_value(ptr);

		case 2:
			return idmef_linkage_get_path_value(ptr);

		case 3:
			return ptr->file;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_linkage_new_child(void *p, idmef_child_t child, int n)
{
	idmef_linkage_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_linkage_new_category(ptr);

		case 1:
			return idmef_linkage_new_name(ptr);

		case 2:
			return idmef_linkage_new_path(ptr);

		case 3:
			return idmef_linkage_new_file(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_linkage_destroy_internal(idmef_linkage_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->name);

	idmef_string_destroy_internal(&ptr->path);

	if ( ptr->file ) {
		idmef_file_destroy(ptr->file);
		ptr->file = NULL;
	}


	/* free() should be done by the caller */
}

void idmef_linkage_destroy(idmef_linkage_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_linkage_destroy_internal(ptr);
        free(ptr);
}

idmef_linkage_category_t idmef_linkage_get_category(idmef_linkage_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_linkage_get_category_value(idmef_linkage_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_LINKAGE_CATEGORY, ptr->category);
}

void idmef_linkage_set_category(idmef_linkage_t *ptr, idmef_linkage_category_t category)
{
	ptr->category = category;
}

idmef_linkage_category_t *idmef_linkage_new_category(idmef_linkage_t *ptr)
{
	return &ptr->category;
}

idmef_string_t *idmef_linkage_get_name(idmef_linkage_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_linkage_get_name_value(idmef_linkage_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_linkage_set_name(idmef_linkage_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_linkage_new_name(idmef_linkage_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

idmef_string_t *idmef_linkage_get_path(idmef_linkage_t *ptr)
{
	return &ptr->path;
}

idmef_value_t *idmef_linkage_get_path_value(idmef_linkage_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->path);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_linkage_set_path(idmef_linkage_t *ptr, idmef_string_t *path)
{
	idmef_string_destroy_internal(&ptr->path);
	memcpy(&ptr->path, path, sizeof (ptr->path));
	free(path);
}

idmef_string_t *idmef_linkage_new_path(idmef_linkage_t *ptr)
{
	idmef_string_destroy_internal(&ptr->path);

	return &ptr->path;
}

idmef_file_t *idmef_linkage_get_file(idmef_linkage_t *ptr)
{
	return ptr->file;
}

idmef_value_t *idmef_linkage_get_file_value(idmef_linkage_t *ptr)
{
	return idmef_value_new_object(ptr->file, IDMEF_OBJECT_TYPE_FILE);
}

void idmef_linkage_set_file(idmef_linkage_t *ptr, idmef_file_t *file)
{
	if ( ptr->file )
		idmef_file_destroy(ptr->file);

	ptr->file = file;
}

idmef_file_t *idmef_linkage_new_file(idmef_linkage_t *ptr)
{
	if ( ! ptr->file )
		ptr->file = idmef_file_new();

	return ptr->file;
}

int idmef_target_decoy_to_numeric(const char *name)
{

	if ( strcasecmp(name, "unknown" ) == 0)
		return IDMEF_TARGET_DECOY_UNKNOWN;

	if ( strcasecmp(name, "yes" ) == 0)
		return IDMEF_TARGET_DECOY_YES;

	if ( strcasecmp(name, "no" ) == 0)
		return IDMEF_TARGET_DECOY_NO;


	return -1;
}	

const char *idmef_target_decoy_to_string(int val)
{
	switch ( val ) {

		case IDMEF_TARGET_DECOY_UNKNOWN:
			return "unknown";

		case IDMEF_TARGET_DECOY_YES:
			return "yes";

		case IDMEF_TARGET_DECOY_NO:
			return "no";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 * 
 *         uint64_t ident;
 *         idmef_target_decoy_t decoy;
 *         idmef_string_t interface;
 * 
 *         idmef_node_t *node;
 *         idmef_user_t *user;
 *         idmef_process_t *process;
 *         idmef_service_t *service;
 *         LISTED_OBJECT(file_list, idmef_file_t);
 * } TYPE_ID(idmef_target_t, 30);
 */


idmef_target_t *idmef_target_new(void)
{
	idmef_target_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->file_list);
    

	return ret;

}

idmef_target_t *idmef_target_ref(idmef_target_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_target_get_child(void *p, idmef_child_t child)
{
	idmef_target_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_target_get_ident_value(ptr);

		case 1:
			return idmef_target_get_decoy_value(ptr);

		case 2:
			return idmef_target_get_interface_value(ptr);

		case 3:
			return ptr->node;

		case 4:
			return ptr->user;

		case 5:
			return ptr->process;

		case 6:
			return ptr->service;

		case 7:
			return &ptr->file_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_target_new_child(void *p, idmef_child_t child, int n)
{
	idmef_target_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_target_new_ident(ptr);

		case 1:
			return idmef_target_new_decoy(ptr);

		case 2:
			return idmef_target_new_interface(ptr);

		case 3:
			return idmef_target_new_node(ptr);

		case 4:
			return idmef_target_new_user(ptr);

		case 5:
			return idmef_target_new_process(ptr);

		case 6:
			return idmef_target_new_service(ptr);

		case 7: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_target_new_file(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->file_list) {
			    		entry = prelude_list_entry(tmp, idmef_file_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_target_new_file(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_target_destroy_internal(idmef_target_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->interface);

	if ( ptr->node ) {
		idmef_node_destroy(ptr->node);
		ptr->node = NULL;
	}

	if ( ptr->user ) {
		idmef_user_destroy(ptr->user);
		ptr->user = NULL;
	}

	if ( ptr->process ) {
		idmef_process_destroy(ptr->process);
		ptr->process = NULL;
	}

	if ( ptr->service ) {
		idmef_service_destroy(ptr->service);
		ptr->service = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_file_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->file_list) {
			entry = prelude_list_entry(tmp, idmef_file_t, list);
			idmef_file_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_target_destroy(idmef_target_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_target_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_target_get_ident(idmef_target_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_target_get_ident_value(idmef_target_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_target_set_ident(idmef_target_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_target_new_ident(idmef_target_t *ptr)
{
	return &ptr->ident;
}

idmef_target_decoy_t idmef_target_get_decoy(idmef_target_t *ptr)
{
	return ptr->decoy;
}

idmef_value_t *idmef_target_get_decoy_value(idmef_target_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_TARGET_DECOY, ptr->decoy);
}

void idmef_target_set_decoy(idmef_target_t *ptr, idmef_target_decoy_t decoy)
{
	ptr->decoy = decoy;
}

idmef_target_decoy_t *idmef_target_new_decoy(idmef_target_t *ptr)
{
	return &ptr->decoy;
}

idmef_string_t *idmef_target_get_interface(idmef_target_t *ptr)
{
	return &ptr->interface;
}

idmef_value_t *idmef_target_get_interface_value(idmef_target_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->interface);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_target_set_interface(idmef_target_t *ptr, idmef_string_t *interface)
{
	idmef_string_destroy_internal(&ptr->interface);
	memcpy(&ptr->interface, interface, sizeof (ptr->interface));
	free(interface);
}

idmef_string_t *idmef_target_new_interface(idmef_target_t *ptr)
{
	idmef_string_destroy_internal(&ptr->interface);

	return &ptr->interface;
}

idmef_node_t *idmef_target_get_node(idmef_target_t *ptr)
{
	return ptr->node;
}

idmef_value_t *idmef_target_get_node_value(idmef_target_t *ptr)
{
	return idmef_value_new_object(ptr->node, IDMEF_OBJECT_TYPE_NODE);
}

void idmef_target_set_node(idmef_target_t *ptr, idmef_node_t *node)
{
	if ( ptr->node )
		idmef_node_destroy(ptr->node);

	ptr->node = node;
}

idmef_node_t *idmef_target_new_node(idmef_target_t *ptr)
{
	if ( ! ptr->node )
		ptr->node = idmef_node_new();

	return ptr->node;
}

idmef_user_t *idmef_target_get_user(idmef_target_t *ptr)
{
	return ptr->user;
}

idmef_value_t *idmef_target_get_user_value(idmef_target_t *ptr)
{
	return idmef_value_new_object(ptr->user, IDMEF_OBJECT_TYPE_USER);
}

void idmef_target_set_user(idmef_target_t *ptr, idmef_user_t *user)
{
	if ( ptr->user )
		idmef_user_destroy(ptr->user);

	ptr->user = user;
}

idmef_user_t *idmef_target_new_user(idmef_target_t *ptr)
{
	if ( ! ptr->user )
		ptr->user = idmef_user_new();

	return ptr->user;
}

idmef_process_t *idmef_target_get_process(idmef_target_t *ptr)
{
	return ptr->process;
}

idmef_value_t *idmef_target_get_process_value(idmef_target_t *ptr)
{
	return idmef_value_new_object(ptr->process, IDMEF_OBJECT_TYPE_PROCESS);
}

void idmef_target_set_process(idmef_target_t *ptr, idmef_process_t *process)
{
	if ( ptr->process )
		idmef_process_destroy(ptr->process);

	ptr->process = process;
}

idmef_process_t *idmef_target_new_process(idmef_target_t *ptr)
{
	if ( ! ptr->process )
		ptr->process = idmef_process_new();

	return ptr->process;
}

idmef_service_t *idmef_target_get_service(idmef_target_t *ptr)
{
	return ptr->service;
}

idmef_value_t *idmef_target_get_service_value(idmef_target_t *ptr)
{
	return idmef_value_new_object(ptr->service, IDMEF_OBJECT_TYPE_SERVICE);
}

void idmef_target_set_service(idmef_target_t *ptr, idmef_service_t *service)
{
	if ( ptr->service )
		idmef_service_destroy(ptr->service);

	ptr->service = service;
}

idmef_service_t *idmef_target_new_service(idmef_target_t *ptr)
{
	if ( ! ptr->service )
		ptr->service = idmef_service_new();

	return ptr->service;
}

    
idmef_file_t *idmef_target_get_next_file(idmef_target_t *ptr, idmef_file_t *object)
{
    	return prelude_list_get_next(object, &ptr->file_list, idmef_file_t, list);
}

void idmef_target_set_file(idmef_target_t *ptr, idmef_file_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->file_list);
}

idmef_file_t *idmef_target_new_file(idmef_target_t *ptr)
{
	idmef_file_t *object;
	
	object = idmef_file_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->file_list);
	
	return object;
}

idmef_value_t *idmef_target_get_file_value(idmef_target_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_file_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->file_list) {
		entry = prelude_list_entry(tmp, idmef_file_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_FILE);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}



/*
 * typedef struct idmef_analyzer {
 *         REFCOUNT;
 * 
 *         uint64_t analyzerid;
 *         idmef_string_t manufacturer;
 *         idmef_string_t model;
 *         idmef_string_t version;
 *         idmef_string_t class;
 *         idmef_string_t ostype;
 *         idmef_string_t osversion;
 * 
 *         idmef_node_t *node;
 *         idmef_process_t *process;
 *         struct idmef_analyzer *analyzer;
 * 
 * } TYPE_ID(idmef_analyzer_t, 31);
 */


idmef_analyzer_t *idmef_analyzer_new(void)
{
	idmef_analyzer_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

idmef_analyzer_t *idmef_analyzer_ref(idmef_analyzer_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_analyzer_get_child(void *p, idmef_child_t child)
{
	idmef_analyzer_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_analyzer_get_analyzerid_value(ptr);

		case 1:
			return idmef_analyzer_get_manufacturer_value(ptr);

		case 2:
			return idmef_analyzer_get_model_value(ptr);

		case 3:
			return idmef_analyzer_get_version_value(ptr);

		case 4:
			return idmef_analyzer_get_class_value(ptr);

		case 5:
			return idmef_analyzer_get_ostype_value(ptr);

		case 6:
			return idmef_analyzer_get_osversion_value(ptr);

		case 7:
			return ptr->node;

		case 8:
			return ptr->process;

		case 9:
			return ptr->analyzer;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_analyzer_new_child(void *p, idmef_child_t child, int n)
{
	idmef_analyzer_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_analyzer_new_analyzerid(ptr);

		case 1:
			return idmef_analyzer_new_manufacturer(ptr);

		case 2:
			return idmef_analyzer_new_model(ptr);

		case 3:
			return idmef_analyzer_new_version(ptr);

		case 4:
			return idmef_analyzer_new_class(ptr);

		case 5:
			return idmef_analyzer_new_ostype(ptr);

		case 6:
			return idmef_analyzer_new_osversion(ptr);

		case 7:
			return idmef_analyzer_new_node(ptr);

		case 8:
			return idmef_analyzer_new_process(ptr);

		case 9:
			return idmef_analyzer_new_analyzer(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_analyzer_destroy_internal(idmef_analyzer_t *ptr)
{

	idmef_string_destroy_internal(&ptr->manufacturer);

	idmef_string_destroy_internal(&ptr->model);

	idmef_string_destroy_internal(&ptr->version);

	idmef_string_destroy_internal(&ptr->class);

	idmef_string_destroy_internal(&ptr->ostype);

	idmef_string_destroy_internal(&ptr->osversion);

	if ( ptr->node ) {
		idmef_node_destroy(ptr->node);
		ptr->node = NULL;
	}

	if ( ptr->process ) {
		idmef_process_destroy(ptr->process);
		ptr->process = NULL;
	}

	if ( ptr->analyzer ) {
		idmef_analyzer_destroy(ptr->analyzer);
		ptr->analyzer = NULL;
	}


	/* free() should be done by the caller */
}

void idmef_analyzer_destroy(idmef_analyzer_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_analyzer_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_analyzer_get_analyzerid(idmef_analyzer_t *ptr)
{
	return ptr->analyzerid;
}

idmef_value_t *idmef_analyzer_get_analyzerid_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->analyzerid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_analyzer_set_analyzerid(idmef_analyzer_t *ptr, uint64_t analyzerid)
{
	ptr->analyzerid = analyzerid;
}

uint64_t *idmef_analyzer_new_analyzerid(idmef_analyzer_t *ptr)
{
	return &ptr->analyzerid;
}

idmef_string_t *idmef_analyzer_get_manufacturer(idmef_analyzer_t *ptr)
{
	return &ptr->manufacturer;
}

idmef_value_t *idmef_analyzer_get_manufacturer_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->manufacturer);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_analyzer_set_manufacturer(idmef_analyzer_t *ptr, idmef_string_t *manufacturer)
{
	idmef_string_destroy_internal(&ptr->manufacturer);
	memcpy(&ptr->manufacturer, manufacturer, sizeof (ptr->manufacturer));
	free(manufacturer);
}

idmef_string_t *idmef_analyzer_new_manufacturer(idmef_analyzer_t *ptr)
{
	idmef_string_destroy_internal(&ptr->manufacturer);

	return &ptr->manufacturer;
}

idmef_string_t *idmef_analyzer_get_model(idmef_analyzer_t *ptr)
{
	return &ptr->model;
}

idmef_value_t *idmef_analyzer_get_model_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->model);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_analyzer_set_model(idmef_analyzer_t *ptr, idmef_string_t *model)
{
	idmef_string_destroy_internal(&ptr->model);
	memcpy(&ptr->model, model, sizeof (ptr->model));
	free(model);
}

idmef_string_t *idmef_analyzer_new_model(idmef_analyzer_t *ptr)
{
	idmef_string_destroy_internal(&ptr->model);

	return &ptr->model;
}

idmef_string_t *idmef_analyzer_get_version(idmef_analyzer_t *ptr)
{
	return &ptr->version;
}

idmef_value_t *idmef_analyzer_get_version_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->version);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_analyzer_set_version(idmef_analyzer_t *ptr, idmef_string_t *version)
{
	idmef_string_destroy_internal(&ptr->version);
	memcpy(&ptr->version, version, sizeof (ptr->version));
	free(version);
}

idmef_string_t *idmef_analyzer_new_version(idmef_analyzer_t *ptr)
{
	idmef_string_destroy_internal(&ptr->version);

	return &ptr->version;
}

idmef_string_t *idmef_analyzer_get_class(idmef_analyzer_t *ptr)
{
	return &ptr->class;
}

idmef_value_t *idmef_analyzer_get_class_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->class);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_analyzer_set_class(idmef_analyzer_t *ptr, idmef_string_t *class)
{
	idmef_string_destroy_internal(&ptr->class);
	memcpy(&ptr->class, class, sizeof (ptr->class));
	free(class);
}

idmef_string_t *idmef_analyzer_new_class(idmef_analyzer_t *ptr)
{
	idmef_string_destroy_internal(&ptr->class);

	return &ptr->class;
}

idmef_string_t *idmef_analyzer_get_ostype(idmef_analyzer_t *ptr)
{
	return &ptr->ostype;
}

idmef_value_t *idmef_analyzer_get_ostype_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->ostype);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_analyzer_set_ostype(idmef_analyzer_t *ptr, idmef_string_t *ostype)
{
	idmef_string_destroy_internal(&ptr->ostype);
	memcpy(&ptr->ostype, ostype, sizeof (ptr->ostype));
	free(ostype);
}

idmef_string_t *idmef_analyzer_new_ostype(idmef_analyzer_t *ptr)
{
	idmef_string_destroy_internal(&ptr->ostype);

	return &ptr->ostype;
}

idmef_string_t *idmef_analyzer_get_osversion(idmef_analyzer_t *ptr)
{
	return &ptr->osversion;
}

idmef_value_t *idmef_analyzer_get_osversion_value(idmef_analyzer_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->osversion);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_analyzer_set_osversion(idmef_analyzer_t *ptr, idmef_string_t *osversion)
{
	idmef_string_destroy_internal(&ptr->osversion);
	memcpy(&ptr->osversion, osversion, sizeof (ptr->osversion));
	free(osversion);
}

idmef_string_t *idmef_analyzer_new_osversion(idmef_analyzer_t *ptr)
{
	idmef_string_destroy_internal(&ptr->osversion);

	return &ptr->osversion;
}

idmef_node_t *idmef_analyzer_get_node(idmef_analyzer_t *ptr)
{
	return ptr->node;
}

idmef_value_t *idmef_analyzer_get_node_value(idmef_analyzer_t *ptr)
{
	return idmef_value_new_object(ptr->node, IDMEF_OBJECT_TYPE_NODE);
}

void idmef_analyzer_set_node(idmef_analyzer_t *ptr, idmef_node_t *node)
{
	if ( ptr->node )
		idmef_node_destroy(ptr->node);

	ptr->node = node;
}

idmef_node_t *idmef_analyzer_new_node(idmef_analyzer_t *ptr)
{
	if ( ! ptr->node )
		ptr->node = idmef_node_new();

	return ptr->node;
}

idmef_process_t *idmef_analyzer_get_process(idmef_analyzer_t *ptr)
{
	return ptr->process;
}

idmef_value_t *idmef_analyzer_get_process_value(idmef_analyzer_t *ptr)
{
	return idmef_value_new_object(ptr->process, IDMEF_OBJECT_TYPE_PROCESS);
}

void idmef_analyzer_set_process(idmef_analyzer_t *ptr, idmef_process_t *process)
{
	if ( ptr->process )
		idmef_process_destroy(ptr->process);

	ptr->process = process;
}

idmef_process_t *idmef_analyzer_new_process(idmef_analyzer_t *ptr)
{
	if ( ! ptr->process )
		ptr->process = idmef_process_new();

	return ptr->process;
}

idmef_analyzer_t *idmef_analyzer_get_analyzer(idmef_analyzer_t *ptr)
{
	return ptr->analyzer;
}

idmef_value_t *idmef_analyzer_get_analyzer_value(idmef_analyzer_t *ptr)
{
	return idmef_value_new_object(ptr->analyzer, IDMEF_OBJECT_TYPE_ANALYZER);
}

void idmef_analyzer_set_analyzer(idmef_analyzer_t *ptr, idmef_analyzer_t *analyzer)
{
	if ( ptr->analyzer )
		idmef_analyzer_destroy(ptr->analyzer);

	ptr->analyzer = analyzer;
}

idmef_analyzer_t *idmef_analyzer_new_analyzer(idmef_analyzer_t *ptr)
{
	if ( ! ptr->analyzer )
		ptr->analyzer = idmef_analyzer_new();

	return ptr->analyzer;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 * 
 *         uint64_t alertident;
 *         uint64_t analyzerid;
 * } TYPE_ID(idmef_alertident_t, 32);
 */


idmef_alertident_t *idmef_alertident_new(void)
{
	idmef_alertident_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_alertident_t *idmef_alertident_ref(idmef_alertident_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_alertident_get_child(void *p, idmef_child_t child)
{
	idmef_alertident_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_alertident_get_alertident_value(ptr);

		case 1:
			return idmef_alertident_get_analyzerid_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_alertident_new_child(void *p, idmef_child_t child, int n)
{
	idmef_alertident_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_alertident_new_alertident(ptr);

		case 1:
			return idmef_alertident_new_analyzerid(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_alertident_destroy_internal(idmef_alertident_t *ptr)
{

	prelude_list_del(&ptr->list);


	/* free() should be done by the caller */
}

void idmef_alertident_destroy(idmef_alertident_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_alertident_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_alertident_get_alertident(idmef_alertident_t *ptr)
{
	return ptr->alertident;
}

idmef_value_t *idmef_alertident_get_alertident_value(idmef_alertident_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->alertident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_alertident_set_alertident(idmef_alertident_t *ptr, uint64_t alertident)
{
	ptr->alertident = alertident;
}

uint64_t *idmef_alertident_new_alertident(idmef_alertident_t *ptr)
{
	return &ptr->alertident;
}

uint64_t idmef_alertident_get_analyzerid(idmef_alertident_t *ptr)
{
	return ptr->analyzerid;
}

idmef_value_t *idmef_alertident_get_analyzerid_value(idmef_alertident_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->analyzerid);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_alertident_set_analyzerid(idmef_alertident_t *ptr, uint64_t analyzerid)
{
	ptr->analyzerid = analyzerid;
}

uint64_t *idmef_alertident_new_analyzerid(idmef_alertident_t *ptr)
{
	return &ptr->analyzerid;
}

int idmef_impact_severity_to_numeric(const char *name)
{

	if ( strcasecmp(name, "low" ) == 0)
		return IDMEF_IMPACT_SEVERITY_LOW;

	if ( strcasecmp(name, "medium" ) == 0)
		return IDMEF_IMPACT_SEVERITY_MEDIUM;

	if ( strcasecmp(name, "high" ) == 0)
		return IDMEF_IMPACT_SEVERITY_HIGH;

	if ( strcasecmp(name, "info" ) == 0)
		return IDMEF_IMPACT_SEVERITY_INFO;


	return -1;
}	

const char *idmef_impact_severity_to_string(int val)
{
	switch ( val ) {

		case 0:
			return "NULL";

		case IDMEF_IMPACT_SEVERITY_LOW:
			return "low";

		case IDMEF_IMPACT_SEVERITY_MEDIUM:
			return "medium";

		case IDMEF_IMPACT_SEVERITY_HIGH:
			return "high";

		case IDMEF_IMPACT_SEVERITY_INFO:
			return "info";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}

int idmef_impact_completion_to_numeric(const char *name)
{

	if ( strcasecmp(name, "failed" ) == 0)
		return IDMEF_IMPACT_COMPLETION_FAILED;

	if ( strcasecmp(name, "succeeded" ) == 0)
		return IDMEF_IMPACT_COMPLETION_SUCCEEDED;


	return -1;
}	

const char *idmef_impact_completion_to_string(int val)
{
	switch ( val ) {

		case 0:
			return "NULL";

		case IDMEF_IMPACT_COMPLETION_FAILED:
			return "failed";

		case IDMEF_IMPACT_COMPLETION_SUCCEEDED:
			return "succeeded";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}

int idmef_impact_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "other" ) == 0)
		return IDMEF_IMPACT_TYPE_OTHER;

	if ( strcasecmp(name, "admin" ) == 0)
		return IDMEF_IMPACT_TYPE_ADMIN;

	if ( strcasecmp(name, "dos" ) == 0)
		return IDMEF_IMPACT_TYPE_DOS;

	if ( strcasecmp(name, "file" ) == 0)
		return IDMEF_IMPACT_TYPE_FILE;

	if ( strcasecmp(name, "recon" ) == 0)
		return IDMEF_IMPACT_TYPE_RECON;

	if ( strcasecmp(name, "user" ) == 0)
		return IDMEF_IMPACT_TYPE_USER;


	return -1;
}	

const char *idmef_impact_type_to_string(int val)
{
	switch ( val ) {

		case IDMEF_IMPACT_TYPE_OTHER:
			return "other";

		case IDMEF_IMPACT_TYPE_ADMIN:
			return "admin";

		case IDMEF_IMPACT_TYPE_DOS:
			return "dos";

		case IDMEF_IMPACT_TYPE_FILE:
			return "file";

		case IDMEF_IMPACT_TYPE_RECON:
			return "recon";

		case IDMEF_IMPACT_TYPE_USER:
			return "user";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         REFCOUNT;
 * 
 *         idmef_impact_severity_t severity;
 *         idmef_impact_completion_t completion;
 *         idmef_impact_type_t type;
 *         idmef_string_t description;
 * } TYPE_ID(idmef_impact_t, 36);
 */


idmef_impact_t *idmef_impact_new(void)
{
	idmef_impact_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

idmef_impact_t *idmef_impact_ref(idmef_impact_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_impact_get_child(void *p, idmef_child_t child)
{
	idmef_impact_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_impact_get_severity_value(ptr);

		case 1:
			return idmef_impact_get_completion_value(ptr);

		case 2:
			return idmef_impact_get_type_value(ptr);

		case 3:
			return idmef_impact_get_description_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_impact_new_child(void *p, idmef_child_t child, int n)
{
	idmef_impact_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_impact_new_severity(ptr);

		case 1:
			return idmef_impact_new_completion(ptr);

		case 2:
			return idmef_impact_new_type(ptr);

		case 3:
			return idmef_impact_new_description(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_impact_destroy_internal(idmef_impact_t *ptr)
{

	idmef_string_destroy_internal(&ptr->description);


	/* free() should be done by the caller */
}

void idmef_impact_destroy(idmef_impact_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_impact_destroy_internal(ptr);
        free(ptr);
}

idmef_impact_severity_t idmef_impact_get_severity(idmef_impact_t *ptr)
{
	return ptr->severity;
}

idmef_value_t *idmef_impact_get_severity_value(idmef_impact_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_IMPACT_SEVERITY, ptr->severity);
}

void idmef_impact_set_severity(idmef_impact_t *ptr, idmef_impact_severity_t severity)
{
	ptr->severity = severity;
}

idmef_impact_severity_t *idmef_impact_new_severity(idmef_impact_t *ptr)
{
	return &ptr->severity;
}

idmef_impact_completion_t idmef_impact_get_completion(idmef_impact_t *ptr)
{
	return ptr->completion;
}

idmef_value_t *idmef_impact_get_completion_value(idmef_impact_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_IMPACT_COMPLETION, ptr->completion);
}

void idmef_impact_set_completion(idmef_impact_t *ptr, idmef_impact_completion_t completion)
{
	ptr->completion = completion;
}

idmef_impact_completion_t *idmef_impact_new_completion(idmef_impact_t *ptr)
{
	return &ptr->completion;
}

idmef_impact_type_t idmef_impact_get_type(idmef_impact_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_impact_get_type_value(idmef_impact_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_IMPACT_TYPE, ptr->type);
}

void idmef_impact_set_type(idmef_impact_t *ptr, idmef_impact_type_t type)
{
	ptr->type = type;
}

idmef_impact_type_t *idmef_impact_new_type(idmef_impact_t *ptr)
{
	return &ptr->type;
}

idmef_string_t *idmef_impact_get_description(idmef_impact_t *ptr)
{
	return &ptr->description;
}

idmef_value_t *idmef_impact_get_description_value(idmef_impact_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->description);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_impact_set_description(idmef_impact_t *ptr, idmef_string_t *description)
{
	idmef_string_destroy_internal(&ptr->description);
	memcpy(&ptr->description, description, sizeof (ptr->description));
	free(description);
}

idmef_string_t *idmef_impact_new_description(idmef_impact_t *ptr)
{
	idmef_string_destroy_internal(&ptr->description);

	return &ptr->description;
}

int idmef_action_category_to_numeric(const char *name)
{

	if ( strcasecmp(name, "other" ) == 0)
		return IDMEF_ACTION_CATEGORY_OTHER;

	if ( strcasecmp(name, "block-installed" ) == 0)
		return IDMEF_ACTION_CATEGORY_BLOCK_INSTALLED;

	if ( strcasecmp(name, "notification-sent" ) == 0)
		return IDMEF_ACTION_CATEGORY_NOTIFICATION_SENT;

	if ( strcasecmp(name, "taken-offline" ) == 0)
		return IDMEF_ACTION_CATEGORY_TAKEN_OFFLINE;


	return -1;
}	

const char *idmef_action_category_to_string(int val)
{
	switch ( val ) {

		case IDMEF_ACTION_CATEGORY_OTHER:
			return "other";

		case IDMEF_ACTION_CATEGORY_BLOCK_INSTALLED:
			return "block-installed";

		case IDMEF_ACTION_CATEGORY_NOTIFICATION_SENT:
			return "notification-sent";

		case IDMEF_ACTION_CATEGORY_TAKEN_OFFLINE:
			return "taken-offline";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         IS_LISTED;
 *         REFCOUNT;
 * 
 *         idmef_action_category_t category;
 *         idmef_string_t description;
 * } TYPE_ID(idmef_action_t, 38);
 */


idmef_action_t *idmef_action_new(void)
{
	idmef_action_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->list);

	ret->refcount = 1;

	return ret;

}

idmef_action_t *idmef_action_ref(idmef_action_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_action_get_child(void *p, idmef_child_t child)
{
	idmef_action_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_action_get_category_value(ptr);

		case 1:
			return idmef_action_get_description_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_action_new_child(void *p, idmef_child_t child, int n)
{
	idmef_action_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_action_new_category(ptr);

		case 1:
			return idmef_action_new_description(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_action_destroy_internal(idmef_action_t *ptr)
{

	prelude_list_del(&ptr->list);

	idmef_string_destroy_internal(&ptr->description);


	/* free() should be done by the caller */
}

void idmef_action_destroy(idmef_action_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_action_destroy_internal(ptr);
        free(ptr);
}

idmef_action_category_t idmef_action_get_category(idmef_action_t *ptr)
{
	return ptr->category;
}

idmef_value_t *idmef_action_get_category_value(idmef_action_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ACTION_CATEGORY, ptr->category);
}

void idmef_action_set_category(idmef_action_t *ptr, idmef_action_category_t category)
{
	ptr->category = category;
}

idmef_action_category_t *idmef_action_new_category(idmef_action_t *ptr)
{
	return &ptr->category;
}

idmef_string_t *idmef_action_get_description(idmef_action_t *ptr)
{
	return &ptr->description;
}

idmef_value_t *idmef_action_get_description_value(idmef_action_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->description);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_action_set_description(idmef_action_t *ptr, idmef_string_t *description)
{
	idmef_string_destroy_internal(&ptr->description);
	memcpy(&ptr->description, description, sizeof (ptr->description));
	free(description);
}

idmef_string_t *idmef_action_new_description(idmef_action_t *ptr)
{
	idmef_string_destroy_internal(&ptr->description);

	return &ptr->description;
}

int idmef_confidence_rating_to_numeric(const char *name)
{

	if ( strcasecmp(name, "numeric" ) == 0)
		return IDMEF_CONFIDENCE_RATING_NUMERIC;

	if ( strcasecmp(name, "low" ) == 0)
		return IDMEF_CONFIDENCE_RATING_LOW;

	if ( strcasecmp(name, "medium" ) == 0)
		return IDMEF_CONFIDENCE_RATING_MEDIUM;

	if ( strcasecmp(name, "high" ) == 0)
		return IDMEF_CONFIDENCE_RATING_HIGH;


	return -1;
}	

const char *idmef_confidence_rating_to_string(int val)
{
	switch ( val ) {

		case IDMEF_CONFIDENCE_RATING_NUMERIC:
			return "numeric";

		case IDMEF_CONFIDENCE_RATING_LOW:
			return "low";

		case IDMEF_CONFIDENCE_RATING_MEDIUM:
			return "medium";

		case IDMEF_CONFIDENCE_RATING_HIGH:
			return "high";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         REFCOUNT;
 * 
 *         idmef_confidence_rating_t rating;
 *         float confidence;
 * } TYPE_ID(idmef_confidence_t, 40);
 */


idmef_confidence_t *idmef_confidence_new(void)
{
	idmef_confidence_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

idmef_confidence_t *idmef_confidence_ref(idmef_confidence_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_confidence_get_child(void *p, idmef_child_t child)
{
	idmef_confidence_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_confidence_get_rating_value(ptr);

		case 1:
			return idmef_confidence_get_confidence_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_confidence_new_child(void *p, idmef_child_t child, int n)
{
	idmef_confidence_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_confidence_new_rating(ptr);

		case 1:
			return idmef_confidence_new_confidence(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_confidence_destroy_internal(idmef_confidence_t *ptr)
{


	/* free() should be done by the caller */
}

void idmef_confidence_destroy(idmef_confidence_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_confidence_destroy_internal(ptr);
        free(ptr);
}

idmef_confidence_rating_t idmef_confidence_get_rating(idmef_confidence_t *ptr)
{
	return ptr->rating;
}

idmef_value_t *idmef_confidence_get_rating_value(idmef_confidence_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_CONFIDENCE_RATING, ptr->rating);
}

void idmef_confidence_set_rating(idmef_confidence_t *ptr, idmef_confidence_rating_t rating)
{
	ptr->rating = rating;
}

idmef_confidence_rating_t *idmef_confidence_new_rating(idmef_confidence_t *ptr)
{
	return &ptr->rating;
}

float idmef_confidence_get_confidence(idmef_confidence_t *ptr)
{
	return ptr->confidence;
}

idmef_value_t *idmef_confidence_get_confidence_value(idmef_confidence_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_float(ptr->confidence);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_confidence_set_confidence(idmef_confidence_t *ptr, float confidence)
{
	ptr->confidence = confidence;
}

float *idmef_confidence_new_confidence(idmef_confidence_t *ptr)
{
	return &ptr->confidence;
}


/*
 * typedef struct {
 *         REFCOUNT;
 * 
 *         idmef_impact_t *impact;
 *         LISTED_OBJECT(action_list, idmef_action_t);
 *         idmef_confidence_t *confidence;
 * } TYPE_ID(idmef_assessment_t, 41);
 */


idmef_assessment_t *idmef_assessment_new(void)
{
	idmef_assessment_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->action_list);
    

	return ret;

}

idmef_assessment_t *idmef_assessment_ref(idmef_assessment_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_assessment_get_child(void *p, idmef_child_t child)
{
	idmef_assessment_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return ptr->impact;

		case 1:
			return &ptr->action_list;

		case 2:
			return ptr->confidence;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_assessment_new_child(void *p, idmef_child_t child, int n)
{
	idmef_assessment_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_assessment_new_impact(ptr);

		case 1: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_assessment_new_action(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->action_list) {
			    		entry = prelude_list_entry(tmp, idmef_action_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_assessment_new_action(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 2:
			return idmef_assessment_new_confidence(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_assessment_destroy_internal(idmef_assessment_t *ptr)
{

	if ( ptr->impact ) {
		idmef_impact_destroy(ptr->impact);
		ptr->impact = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_action_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->action_list) {
			entry = prelude_list_entry(tmp, idmef_action_t, list);
			idmef_action_destroy(entry);
		}
	}

	if ( ptr->confidence ) {
		idmef_confidence_destroy(ptr->confidence);
		ptr->confidence = NULL;
	}


	/* free() should be done by the caller */
}

void idmef_assessment_destroy(idmef_assessment_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_assessment_destroy_internal(ptr);
        free(ptr);
}

idmef_impact_t *idmef_assessment_get_impact(idmef_assessment_t *ptr)
{
	return ptr->impact;
}

idmef_value_t *idmef_assessment_get_impact_value(idmef_assessment_t *ptr)
{
	return idmef_value_new_object(ptr->impact, IDMEF_OBJECT_TYPE_IMPACT);
}

void idmef_assessment_set_impact(idmef_assessment_t *ptr, idmef_impact_t *impact)
{
	if ( ptr->impact )
		idmef_impact_destroy(ptr->impact);

	ptr->impact = impact;
}

idmef_impact_t *idmef_assessment_new_impact(idmef_assessment_t *ptr)
{
	if ( ! ptr->impact )
		ptr->impact = idmef_impact_new();

	return ptr->impact;
}

    
idmef_action_t *idmef_assessment_get_next_action(idmef_assessment_t *ptr, idmef_action_t *object)
{
    	return prelude_list_get_next(object, &ptr->action_list, idmef_action_t, list);
}

void idmef_assessment_set_action(idmef_assessment_t *ptr, idmef_action_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->action_list);
}

idmef_action_t *idmef_assessment_new_action(idmef_assessment_t *ptr)
{
	idmef_action_t *object;
	
	object = idmef_action_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->action_list);
	
	return object;
}

idmef_value_t *idmef_assessment_get_action_value(idmef_assessment_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_action_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->action_list) {
		entry = prelude_list_entry(tmp, idmef_action_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ACTION);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


idmef_confidence_t *idmef_assessment_get_confidence(idmef_assessment_t *ptr)
{
	return ptr->confidence;
}

idmef_value_t *idmef_assessment_get_confidence_value(idmef_assessment_t *ptr)
{
	return idmef_value_new_object(ptr->confidence, IDMEF_OBJECT_TYPE_CONFIDENCE);
}

void idmef_assessment_set_confidence(idmef_assessment_t *ptr, idmef_confidence_t *confidence)
{
	if ( ptr->confidence )
		idmef_confidence_destroy(ptr->confidence);

	ptr->confidence = confidence;
}

idmef_confidence_t *idmef_assessment_new_confidence(idmef_assessment_t *ptr)
{
	if ( ! ptr->confidence )
		ptr->confidence = idmef_confidence_new();

	return ptr->confidence;
}


/*
 * typedef struct {
 *         REFCOUNT;
 * 
 *         idmef_string_t name;
 *         idmef_string_t command;
 *         LISTED_OBJECT(alertident_list, idmef_alertident_t);
 * } TYPE_ID(idmef_tool_alert_t, 42);
 */


idmef_tool_alert_t *idmef_tool_alert_new(void)
{
	idmef_tool_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->alertident_list);
    

	return ret;

}

idmef_tool_alert_t *idmef_tool_alert_ref(idmef_tool_alert_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_tool_alert_get_child(void *p, idmef_child_t child)
{
	idmef_tool_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_tool_alert_get_name_value(ptr);

		case 1:
			return idmef_tool_alert_get_command_value(ptr);

		case 2:
			return &ptr->alertident_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_tool_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_tool_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_tool_alert_new_name(ptr);

		case 1:
			return idmef_tool_alert_new_command(ptr);

		case 2: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_tool_alert_new_alertident(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->alertident_list) {
			    		entry = prelude_list_entry(tmp, idmef_alertident_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_tool_alert_new_alertident(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_tool_alert_destroy_internal(idmef_tool_alert_t *ptr)
{

	idmef_string_destroy_internal(&ptr->name);

	idmef_string_destroy_internal(&ptr->command);

	{
		prelude_list_t *n, *tmp;
		idmef_alertident_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->alertident_list) {
			entry = prelude_list_entry(tmp, idmef_alertident_t, list);
			idmef_alertident_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_tool_alert_destroy(idmef_tool_alert_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_tool_alert_destroy_internal(ptr);
        free(ptr);
}

idmef_string_t *idmef_tool_alert_get_name(idmef_tool_alert_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_tool_alert_get_name_value(idmef_tool_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_tool_alert_set_name(idmef_tool_alert_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_tool_alert_new_name(idmef_tool_alert_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

idmef_string_t *idmef_tool_alert_get_command(idmef_tool_alert_t *ptr)
{
	return &ptr->command;
}

idmef_value_t *idmef_tool_alert_get_command_value(idmef_tool_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->command);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_tool_alert_set_command(idmef_tool_alert_t *ptr, idmef_string_t *command)
{
	idmef_string_destroy_internal(&ptr->command);
	memcpy(&ptr->command, command, sizeof (ptr->command));
	free(command);
}

idmef_string_t *idmef_tool_alert_new_command(idmef_tool_alert_t *ptr)
{
	idmef_string_destroy_internal(&ptr->command);

	return &ptr->command;
}

    
idmef_alertident_t *idmef_tool_alert_get_next_alertident(idmef_tool_alert_t *ptr, idmef_alertident_t *object)
{
    	return prelude_list_get_next(object, &ptr->alertident_list, idmef_alertident_t, list);
}

void idmef_tool_alert_set_alertident(idmef_tool_alert_t *ptr, idmef_alertident_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
}

idmef_alertident_t *idmef_tool_alert_new_alertident(idmef_tool_alert_t *ptr)
{
	idmef_alertident_t *object;
	
	object = idmef_alertident_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
	
	return object;
}

idmef_value_t *idmef_tool_alert_get_alertident_value(idmef_tool_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_alertident_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->alertident_list) {
		entry = prelude_list_entry(tmp, idmef_alertident_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ALERTIDENT);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}



/*
 * typedef struct {
 *         REFCOUNT;
 * 
 *         idmef_string_t name;
 *         LISTED_OBJECT(alertident_list, idmef_alertident_t);
 * } TYPE_ID(idmef_correlation_alert_t, 43);
 */


idmef_correlation_alert_t *idmef_correlation_alert_new(void)
{
	idmef_correlation_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	PRELUDE_INIT_LIST_HEAD(&ret->alertident_list);
    

	return ret;

}

idmef_correlation_alert_t *idmef_correlation_alert_ref(idmef_correlation_alert_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_correlation_alert_get_child(void *p, idmef_child_t child)
{
	idmef_correlation_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_correlation_alert_get_name_value(ptr);

		case 1:
			return &ptr->alertident_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_correlation_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_correlation_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_correlation_alert_new_name(ptr);

		case 1: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_correlation_alert_new_alertident(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->alertident_list) {
			    		entry = prelude_list_entry(tmp, idmef_alertident_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_correlation_alert_new_alertident(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_correlation_alert_destroy_internal(idmef_correlation_alert_t *ptr)
{

	idmef_string_destroy_internal(&ptr->name);

	{
		prelude_list_t *n, *tmp;
		idmef_alertident_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->alertident_list) {
			entry = prelude_list_entry(tmp, idmef_alertident_t, list);
			idmef_alertident_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_correlation_alert_destroy(idmef_correlation_alert_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_correlation_alert_destroy_internal(ptr);
        free(ptr);
}

idmef_string_t *idmef_correlation_alert_get_name(idmef_correlation_alert_t *ptr)
{
	return &ptr->name;
}

idmef_value_t *idmef_correlation_alert_get_name_value(idmef_correlation_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->name);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_correlation_alert_set_name(idmef_correlation_alert_t *ptr, idmef_string_t *name)
{
	idmef_string_destroy_internal(&ptr->name);
	memcpy(&ptr->name, name, sizeof (ptr->name));
	free(name);
}

idmef_string_t *idmef_correlation_alert_new_name(idmef_correlation_alert_t *ptr)
{
	idmef_string_destroy_internal(&ptr->name);

	return &ptr->name;
}

    
idmef_alertident_t *idmef_correlation_alert_get_next_alertident(idmef_correlation_alert_t *ptr, idmef_alertident_t *object)
{
    	return prelude_list_get_next(object, &ptr->alertident_list, idmef_alertident_t, list);
}

void idmef_correlation_alert_set_alertident(idmef_correlation_alert_t *ptr, idmef_alertident_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
}

idmef_alertident_t *idmef_correlation_alert_new_alertident(idmef_correlation_alert_t *ptr)
{
	idmef_alertident_t *object;
	
	object = idmef_alertident_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->alertident_list);
	
	return object;
}

idmef_value_t *idmef_correlation_alert_get_alertident_value(idmef_correlation_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_alertident_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->alertident_list) {
		entry = prelude_list_entry(tmp, idmef_alertident_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ALERTIDENT);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}



/*
 * typedef struct {
 *         REFCOUNT;
 * 
 *         idmef_string_t program;
 *         uint32_t *size;
 *         idmef_data_t *buffer;
 * } TYPE_ID(idmef_overflow_alert_t, 44);
 */


idmef_overflow_alert_t *idmef_overflow_alert_new(void)
{
	idmef_overflow_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	ret->refcount = 1;

	return ret;

}

idmef_overflow_alert_t *idmef_overflow_alert_ref(idmef_overflow_alert_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_overflow_alert_get_child(void *p, idmef_child_t child)
{
	idmef_overflow_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_overflow_alert_get_program_value(ptr);

		case 1:
			return idmef_overflow_alert_get_size_value(ptr);

		case 2:
			return idmef_overflow_alert_get_buffer_value(ptr);

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_overflow_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_overflow_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_overflow_alert_new_program(ptr);

		case 1:
			return idmef_overflow_alert_new_size(ptr);

		case 2:
			return idmef_overflow_alert_new_buffer(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_overflow_alert_destroy_internal(idmef_overflow_alert_t *ptr)
{

	idmef_string_destroy_internal(&ptr->program);

	if ( ptr->size )
		free(ptr->size);

	if ( ptr->buffer ) {
		idmef_data_destroy(ptr->buffer);
		ptr->buffer = NULL;
	}


	/* free() should be done by the caller */
}

void idmef_overflow_alert_destroy(idmef_overflow_alert_t *ptr)
{
	if ( --ptr->refcount )
		return;

	idmef_overflow_alert_destroy_internal(ptr);
        free(ptr);
}

idmef_string_t *idmef_overflow_alert_get_program(idmef_overflow_alert_t *ptr)
{
	return &ptr->program;
}

idmef_value_t *idmef_overflow_alert_get_program_value(idmef_overflow_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->program);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_overflow_alert_set_program(idmef_overflow_alert_t *ptr, idmef_string_t *program)
{
	idmef_string_destroy_internal(&ptr->program);
	memcpy(&ptr->program, program, sizeof (ptr->program));
	free(program);
}

idmef_string_t *idmef_overflow_alert_new_program(idmef_overflow_alert_t *ptr)
{
	idmef_string_destroy_internal(&ptr->program);

	return &ptr->program;
}

uint32_t idmef_overflow_alert_get_size(idmef_overflow_alert_t *ptr)
{
	return ptr->size ? *ptr->size : (uint32_t) 0;
}

idmef_value_t *idmef_overflow_alert_get_size_value(idmef_overflow_alert_t *ptr)
{
	return idmef_value_new_uint32(ptr->size ? *ptr->size : (uint32_t) 0);
}

void idmef_overflow_alert_set_size(idmef_overflow_alert_t *ptr, uint32_t size)
{
	if ( ptr->size )
		free(ptr->size);

	ptr->size = malloc(sizeof (*ptr->size));
	*ptr->size = size;
}

uint32_t *idmef_overflow_alert_new_size(idmef_overflow_alert_t *ptr)
{
	if ( ptr->size )
		free(ptr->size);

	ptr->size = calloc(1, sizeof (*ptr->size));

	return ptr->size;
}

idmef_data_t *idmef_overflow_alert_get_buffer(idmef_overflow_alert_t *ptr)
{
	return ptr->buffer;
}

idmef_value_t *idmef_overflow_alert_get_buffer_value(idmef_overflow_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_data(ptr->buffer);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_overflow_alert_set_buffer(idmef_overflow_alert_t *ptr, idmef_data_t *buffer)
{
	if ( ptr->buffer )
		idmef_data_destroy(ptr->buffer);

	ptr->buffer = buffer;
}

idmef_data_t *idmef_overflow_alert_new_buffer(idmef_overflow_alert_t *ptr)
{
	if ( ptr->buffer )
		idmef_data_destroy(ptr->buffer);
		
	ptr->buffer = idmef_data_new();

	return ptr->buffer;
}

int idmef_alert_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "default" ) == 0)
		return IDMEF_ALERT_TYPE_DEFAULT;

	if ( strcasecmp(name, "tool" ) == 0)
		return IDMEF_ALERT_TYPE_TOOL;

	if ( strcasecmp(name, "correlation" ) == 0)
		return IDMEF_ALERT_TYPE_CORRELATION;

	if ( strcasecmp(name, "overflow" ) == 0)
		return IDMEF_ALERT_TYPE_OVERFLOW;


	return -1;
}	

const char *idmef_alert_type_to_string(int val)
{
	switch ( val ) {

		case IDMEF_ALERT_TYPE_DEFAULT:
			return "default";

		case IDMEF_ALERT_TYPE_TOOL:
			return "tool";

		case IDMEF_ALERT_TYPE_CORRELATION:
			return "correlation";

		case IDMEF_ALERT_TYPE_OVERFLOW:
			return "overflow";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         DYNAMIC_IDENT(ident);
 * 
 *         idmef_assessment_t *assessment;
 * 
 *         idmef_analyzer_t *analyzer;
 * 
 *         idmef_time_t create_time;
 *         idmef_time_t *detect_time;
 *         idmef_time_t *analyzer_time;
 * 
 *         LISTED_OBJECT(source_list, idmef_source_t);
 *         LISTED_OBJECT(target_list, idmef_target_t);
 *         LISTED_OBJECT(classification_list, idmef_classification_t);
 *         LISTED_OBJECT(additional_data_list, idmef_additional_data_t);
 * 
 *         UNION(idmef_alert_type_t, type) {
 *                 UNION_MEMBER(IDMEF_ALERT_TYPE_TOOL, idmef_tool_alert_t, *tool_alert);
 *                 UNION_MEMBER(IDMEF_ALERT_TYPE_CORRELATION, idmef_correlation_alert_t, *correlation_alert);
 *                 UNION_MEMBER(IDMEF_ALERT_TYPE_OVERFLOW, idmef_overflow_alert_t, *overflow_alert);
 *         } detail;
 * 
 * } TYPE_ID(idmef_alert_t, 46);
 */


idmef_alert_t *idmef_alert_new(void)
{
	idmef_alert_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->source_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->target_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->classification_list);
    

	PRELUDE_INIT_LIST_HEAD(&ret->additional_data_list);
    

	return ret;

}

void *idmef_alert_get_child(void *p, idmef_child_t child)
{
	idmef_alert_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_alert_get_ident_value(ptr);

		case 1:
			return ptr->assessment;

		case 2:
			return ptr->analyzer;

		case 3:
			return idmef_alert_get_create_time_value(ptr);

		case 4:
			return idmef_alert_get_detect_time_value(ptr);

		case 5:
			return idmef_alert_get_analyzer_time_value(ptr);

		case 6:
			return &ptr->source_list;

		case 7:
			return &ptr->target_list;

		case 8:
			return &ptr->classification_list;

		case 9:
			return &ptr->additional_data_list;

		case 10:
			return idmef_alert_get_type_value(ptr);

		case 11: 
			if ( ptr->type == IDMEF_ALERT_TYPE_TOOL ) 
				return ptr->detail.tool_alert;
			return NULL;   	   

		case 12: 
			if ( ptr->type == IDMEF_ALERT_TYPE_CORRELATION ) 
				return ptr->detail.correlation_alert;
			return NULL;   	   

		case 13: 
			if ( ptr->type == IDMEF_ALERT_TYPE_OVERFLOW ) 
				return ptr->detail.overflow_alert;
			return NULL;   	   

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_alert_new_child(void *p, idmef_child_t child, int n)
{
	idmef_alert_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_alert_new_ident(ptr);

		case 1:
			return idmef_alert_new_assessment(ptr);

		case 2:
			return idmef_alert_new_analyzer(ptr);

		case 3:
			return idmef_alert_new_create_time(ptr);

		case 4:
			return idmef_alert_new_detect_time(ptr);

		case 5:
			return idmef_alert_new_analyzer_time(ptr);

		case 6: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_alert_new_source(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->source_list) {
			    		entry = prelude_list_entry(tmp, idmef_source_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_alert_new_source(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 7: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_alert_new_target(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->target_list) {
			    		entry = prelude_list_entry(tmp, idmef_target_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_alert_new_target(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 8: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_alert_new_classification(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->classification_list) {
			    		entry = prelude_list_entry(tmp, idmef_classification_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_alert_new_classification(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 9: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_alert_new_additional_data(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->additional_data_list) {
			    		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_alert_new_additional_data(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		case 11:
			return idmef_alert_new_tool_alert(ptr);

		case 12:
			return idmef_alert_new_correlation_alert(ptr);

		case 13:
			return idmef_alert_new_overflow_alert(ptr);

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_alert_destroy_internal(idmef_alert_t *ptr)
{

	if ( ptr->assessment ) {
		idmef_assessment_destroy(ptr->assessment);
		ptr->assessment = NULL;
	}

	if ( ptr->analyzer ) {
		idmef_analyzer_destroy(ptr->analyzer);
		ptr->analyzer = NULL;
	}

	idmef_time_destroy_internal(&ptr->create_time);

	if ( ptr->detect_time ) {
		idmef_time_destroy(ptr->detect_time);
		ptr->detect_time = NULL;
	}

	if ( ptr->analyzer_time ) {
		idmef_time_destroy(ptr->analyzer_time);
		ptr->analyzer_time = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_source_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->source_list) {
			entry = prelude_list_entry(tmp, idmef_source_t, list);
			idmef_source_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		idmef_target_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->target_list) {
			entry = prelude_list_entry(tmp, idmef_target_t, list);
			idmef_target_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		idmef_classification_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->classification_list) {
			entry = prelude_list_entry(tmp, idmef_classification_t, list);
			idmef_classification_destroy(entry);
		}
	}

	{
		prelude_list_t *n, *tmp;
		idmef_additional_data_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->additional_data_list) {
			entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
			idmef_additional_data_destroy(entry);
		}
	}

	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			ptr->detail.tool_alert = NULL;
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			ptr->detail.correlation_alert = NULL;
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			ptr->detail.overflow_alert = NULL;
			break;

		default:
			break;
	}


	/* free() should be done by the caller */
}

void idmef_alert_destroy(idmef_alert_t *ptr)
{
	idmef_alert_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_alert_get_ident(idmef_alert_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_alert_get_ident_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_alert_set_ident(idmef_alert_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_alert_new_ident(idmef_alert_t *ptr)
{
	return &ptr->ident;
}

idmef_assessment_t *idmef_alert_get_assessment(idmef_alert_t *ptr)
{
	return ptr->assessment;
}

idmef_value_t *idmef_alert_get_assessment_value(idmef_alert_t *ptr)
{
	return idmef_value_new_object(ptr->assessment, IDMEF_OBJECT_TYPE_ASSESSMENT);
}

void idmef_alert_set_assessment(idmef_alert_t *ptr, idmef_assessment_t *assessment)
{
	if ( ptr->assessment )
		idmef_assessment_destroy(ptr->assessment);

	ptr->assessment = assessment;
}

idmef_assessment_t *idmef_alert_new_assessment(idmef_alert_t *ptr)
{
	if ( ! ptr->assessment )
		ptr->assessment = idmef_assessment_new();

	return ptr->assessment;
}

idmef_analyzer_t *idmef_alert_get_analyzer(idmef_alert_t *ptr)
{
	return ptr->analyzer;
}

idmef_value_t *idmef_alert_get_analyzer_value(idmef_alert_t *ptr)
{
	return idmef_value_new_object(ptr->analyzer, IDMEF_OBJECT_TYPE_ANALYZER);
}

void idmef_alert_set_analyzer(idmef_alert_t *ptr, idmef_analyzer_t *analyzer)
{
	if ( ptr->analyzer )
		idmef_analyzer_destroy(ptr->analyzer);

	ptr->analyzer = analyzer;
}

idmef_analyzer_t *idmef_alert_new_analyzer(idmef_alert_t *ptr)
{
	if ( ! ptr->analyzer )
		ptr->analyzer = idmef_analyzer_new();

	return ptr->analyzer;
}

idmef_time_t *idmef_alert_get_create_time(idmef_alert_t *ptr)
{
	return &ptr->create_time;
}

idmef_value_t *idmef_alert_get_create_time_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(&ptr->create_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_alert_set_create_time(idmef_alert_t *ptr, idmef_time_t *create_time)
{
	idmef_time_destroy_internal(&ptr->create_time);
	memcpy(&ptr->create_time, create_time, sizeof (ptr->create_time));
	free(create_time);
}

idmef_time_t *idmef_alert_new_create_time(idmef_alert_t *ptr)
{
	idmef_time_destroy_internal(&ptr->create_time);

	return &ptr->create_time;
}

idmef_time_t *idmef_alert_get_detect_time(idmef_alert_t *ptr)
{
	return ptr->detect_time;
}

idmef_value_t *idmef_alert_get_detect_time_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(ptr->detect_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_alert_set_detect_time(idmef_alert_t *ptr, idmef_time_t *detect_time)
{
	if ( ptr->detect_time )
		idmef_time_destroy(ptr->detect_time);

	ptr->detect_time = detect_time;
}

idmef_time_t *idmef_alert_new_detect_time(idmef_alert_t *ptr)
{
	if ( ptr->detect_time )
		idmef_time_destroy(ptr->detect_time);
		
	ptr->detect_time = idmef_time_new();

	return ptr->detect_time;
}

idmef_time_t *idmef_alert_get_analyzer_time(idmef_alert_t *ptr)
{
	return ptr->analyzer_time;
}

idmef_value_t *idmef_alert_get_analyzer_time_value(idmef_alert_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(ptr->analyzer_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_alert_set_analyzer_time(idmef_alert_t *ptr, idmef_time_t *analyzer_time)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);

	ptr->analyzer_time = analyzer_time;
}

idmef_time_t *idmef_alert_new_analyzer_time(idmef_alert_t *ptr)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);
		
	ptr->analyzer_time = idmef_time_new();

	return ptr->analyzer_time;
}

    
idmef_source_t *idmef_alert_get_next_source(idmef_alert_t *ptr, idmef_source_t *object)
{
    	return prelude_list_get_next(object, &ptr->source_list, idmef_source_t, list);
}

void idmef_alert_set_source(idmef_alert_t *ptr, idmef_source_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->source_list);
}

idmef_source_t *idmef_alert_new_source(idmef_alert_t *ptr)
{
	idmef_source_t *object;
	
	object = idmef_source_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->source_list);
	
	return object;
}

idmef_value_t *idmef_alert_get_source_value(idmef_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_source_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->source_list) {
		entry = prelude_list_entry(tmp, idmef_source_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_SOURCE);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


    
idmef_target_t *idmef_alert_get_next_target(idmef_alert_t *ptr, idmef_target_t *object)
{
    	return prelude_list_get_next(object, &ptr->target_list, idmef_target_t, list);
}

void idmef_alert_set_target(idmef_alert_t *ptr, idmef_target_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->target_list);
}

idmef_target_t *idmef_alert_new_target(idmef_alert_t *ptr)
{
	idmef_target_t *object;
	
	object = idmef_target_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->target_list);
	
	return object;
}

idmef_value_t *idmef_alert_get_target_value(idmef_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_target_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->target_list) {
		entry = prelude_list_entry(tmp, idmef_target_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_TARGET);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


    
idmef_classification_t *idmef_alert_get_next_classification(idmef_alert_t *ptr, idmef_classification_t *object)
{
    	return prelude_list_get_next(object, &ptr->classification_list, idmef_classification_t, list);
}

void idmef_alert_set_classification(idmef_alert_t *ptr, idmef_classification_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->classification_list);
}

idmef_classification_t *idmef_alert_new_classification(idmef_alert_t *ptr)
{
	idmef_classification_t *object;
	
	object = idmef_classification_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->classification_list);
	
	return object;
}

idmef_value_t *idmef_alert_get_classification_value(idmef_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_classification_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->classification_list) {
		entry = prelude_list_entry(tmp, idmef_classification_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_CLASSIFICATION);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


    
idmef_additional_data_t *idmef_alert_get_next_additional_data(idmef_alert_t *ptr, idmef_additional_data_t *object)
{
    	return prelude_list_get_next(object, &ptr->additional_data_list, idmef_additional_data_t, list);
}

void idmef_alert_set_additional_data(idmef_alert_t *ptr, idmef_additional_data_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
}

idmef_additional_data_t *idmef_alert_new_additional_data(idmef_alert_t *ptr)
{
	idmef_additional_data_t *object;
	
	object = idmef_additional_data_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
	
	return object;
}

idmef_value_t *idmef_alert_get_additional_data_value(idmef_alert_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_additional_data_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->additional_data_list) {
		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ADDITIONAL_DATA);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


idmef_alert_type_t idmef_alert_get_type(idmef_alert_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_alert_get_type_value(idmef_alert_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_ALERT_TYPE, ptr->type);
}

idmef_tool_alert_t *idmef_alert_get_tool_alert(idmef_alert_t *ptr)
{
	return (ptr->type == IDMEF_ALERT_TYPE_TOOL) ? ptr->detail.tool_alert : NULL;
}

void idmef_alert_set_tool_alert(idmef_alert_t *ptr, idmef_tool_alert_t *tool_alert)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.tool_alert = tool_alert;
	ptr->type = IDMEF_ALERT_TYPE_TOOL;
}

idmef_value_t *idmef_alert_get_tool_alert_value(idmef_alert_t *ptr)
{
	return ((ptr->type == IDMEF_ALERT_TYPE_TOOL) ?
		idmef_value_new_object(ptr->detail.tool_alert, IDMEF_OBJECT_TYPE_TOOL_ALERT) :
		NULL);
}

idmef_tool_alert_t *idmef_alert_new_tool_alert(idmef_alert_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			return ptr->detail.tool_alert;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.tool_alert = idmef_tool_alert_new();
	ptr->type = IDMEF_ALERT_TYPE_TOOL;

	return ptr->detail.tool_alert;
}

idmef_correlation_alert_t *idmef_alert_get_correlation_alert(idmef_alert_t *ptr)
{
	return (ptr->type == IDMEF_ALERT_TYPE_CORRELATION) ? ptr->detail.correlation_alert : NULL;
}

void idmef_alert_set_correlation_alert(idmef_alert_t *ptr, idmef_correlation_alert_t *correlation_alert)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.correlation_alert = correlation_alert;
	ptr->type = IDMEF_ALERT_TYPE_CORRELATION;
}

idmef_value_t *idmef_alert_get_correlation_alert_value(idmef_alert_t *ptr)
{
	return ((ptr->type == IDMEF_ALERT_TYPE_CORRELATION) ?
		idmef_value_new_object(ptr->detail.correlation_alert, IDMEF_OBJECT_TYPE_CORRELATION_ALERT) :
		NULL);
}

idmef_correlation_alert_t *idmef_alert_new_correlation_alert(idmef_alert_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			return ptr->detail.correlation_alert;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.correlation_alert = idmef_correlation_alert_new();
	ptr->type = IDMEF_ALERT_TYPE_CORRELATION;

	return ptr->detail.correlation_alert;
}

idmef_overflow_alert_t *idmef_alert_get_overflow_alert(idmef_alert_t *ptr)
{
	return (ptr->type == IDMEF_ALERT_TYPE_OVERFLOW) ? ptr->detail.overflow_alert : NULL;
}

void idmef_alert_set_overflow_alert(idmef_alert_t *ptr, idmef_overflow_alert_t *overflow_alert)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			idmef_overflow_alert_destroy(ptr->detail.overflow_alert);
			break;

		default:
			break;
	}

	ptr->detail.overflow_alert = overflow_alert;
	ptr->type = IDMEF_ALERT_TYPE_OVERFLOW;
}

idmef_value_t *idmef_alert_get_overflow_alert_value(idmef_alert_t *ptr)
{
	return ((ptr->type == IDMEF_ALERT_TYPE_OVERFLOW) ?
		idmef_value_new_object(ptr->detail.overflow_alert, IDMEF_OBJECT_TYPE_OVERFLOW_ALERT) :
		NULL);
}

idmef_overflow_alert_t *idmef_alert_new_overflow_alert(idmef_alert_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_ALERT_TYPE_TOOL:
			idmef_tool_alert_destroy(ptr->detail.tool_alert);
			break;

		case IDMEF_ALERT_TYPE_CORRELATION:
			idmef_correlation_alert_destroy(ptr->detail.correlation_alert);
			break;

		case IDMEF_ALERT_TYPE_OVERFLOW:
			return ptr->detail.overflow_alert;

		default:
			break;
	}

	ptr->detail.overflow_alert = idmef_overflow_alert_new();
	ptr->type = IDMEF_ALERT_TYPE_OVERFLOW;

	return ptr->detail.overflow_alert;
}


/*
 * typedef struct {
 *         DYNAMIC_IDENT(ident);
 *         idmef_analyzer_t *analyzer;
 * 
 *         idmef_time_t create_time;
 *         idmef_time_t *analyzer_time;
 * 
 *         LISTED_OBJECT(additional_data_list, idmef_additional_data_t);
 * } TYPE_ID(idmef_heartbeat_t, 47);
 */


idmef_heartbeat_t *idmef_heartbeat_new(void)
{
	idmef_heartbeat_t *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;

	PRELUDE_INIT_LIST_HEAD(&ret->additional_data_list);
    

	return ret;

}

void *idmef_heartbeat_get_child(void *p, idmef_child_t child)
{
	idmef_heartbeat_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_heartbeat_get_ident_value(ptr);

		case 1:
			return ptr->analyzer;

		case 2:
			return idmef_heartbeat_get_create_time_value(ptr);

		case 3:
			return idmef_heartbeat_get_analyzer_time_value(ptr);

		case 4:
			return &ptr->additional_data_list;

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_heartbeat_new_child(void *p, idmef_child_t child, int n)
{
	idmef_heartbeat_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_heartbeat_new_ident(ptr);

		case 1:
			return idmef_heartbeat_new_analyzer(ptr);

		case 2:
			return idmef_heartbeat_new_create_time(ptr);

		case 3:
			return idmef_heartbeat_new_analyzer_time(ptr);

		case 4: {
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) {
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_heartbeat_new_additional_data(ptr);
			} else {
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->additional_data_list) {
			    		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
					if ( i++ == n )
						return entry;
				
				}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) {
			    		entry = idmef_heartbeat_new_additional_data(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				}
			}
			
			return entry;
		}

		default:
			return NULL;
	}

	return NULL;
}

static void idmef_heartbeat_destroy_internal(idmef_heartbeat_t *ptr)
{

	if ( ptr->analyzer ) {
		idmef_analyzer_destroy(ptr->analyzer);
		ptr->analyzer = NULL;
	}

	idmef_time_destroy_internal(&ptr->create_time);

	if ( ptr->analyzer_time ) {
		idmef_time_destroy(ptr->analyzer_time);
		ptr->analyzer_time = NULL;
	}

	{
		prelude_list_t *n, *tmp;
		idmef_additional_data_t *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->additional_data_list) {
			entry = prelude_list_entry(tmp, idmef_additional_data_t, list);
			idmef_additional_data_destroy(entry);
		}
	}


	/* free() should be done by the caller */
}

void idmef_heartbeat_destroy(idmef_heartbeat_t *ptr)
{
	idmef_heartbeat_destroy_internal(ptr);
        free(ptr);
}

uint64_t idmef_heartbeat_get_ident(idmef_heartbeat_t *ptr)
{
	return ptr->ident;
}

idmef_value_t *idmef_heartbeat_get_ident_value(idmef_heartbeat_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_uint64(ptr->ident);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_heartbeat_set_ident(idmef_heartbeat_t *ptr, uint64_t ident)
{
	ptr->ident = ident;
}

uint64_t *idmef_heartbeat_new_ident(idmef_heartbeat_t *ptr)
{
	return &ptr->ident;
}

idmef_analyzer_t *idmef_heartbeat_get_analyzer(idmef_heartbeat_t *ptr)
{
	return ptr->analyzer;
}

idmef_value_t *idmef_heartbeat_get_analyzer_value(idmef_heartbeat_t *ptr)
{
	return idmef_value_new_object(ptr->analyzer, IDMEF_OBJECT_TYPE_ANALYZER);
}

void idmef_heartbeat_set_analyzer(idmef_heartbeat_t *ptr, idmef_analyzer_t *analyzer)
{
	if ( ptr->analyzer )
		idmef_analyzer_destroy(ptr->analyzer);

	ptr->analyzer = analyzer;
}

idmef_analyzer_t *idmef_heartbeat_new_analyzer(idmef_heartbeat_t *ptr)
{
	if ( ! ptr->analyzer )
		ptr->analyzer = idmef_analyzer_new();

	return ptr->analyzer;
}

idmef_time_t *idmef_heartbeat_get_create_time(idmef_heartbeat_t *ptr)
{
	return &ptr->create_time;
}

idmef_value_t *idmef_heartbeat_get_create_time_value(idmef_heartbeat_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(&ptr->create_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_heartbeat_set_create_time(idmef_heartbeat_t *ptr, idmef_time_t *create_time)
{
	idmef_time_destroy_internal(&ptr->create_time);
	memcpy(&ptr->create_time, create_time, sizeof (ptr->create_time));
	free(create_time);
}

idmef_time_t *idmef_heartbeat_new_create_time(idmef_heartbeat_t *ptr)
{
	idmef_time_destroy_internal(&ptr->create_time);

	return &ptr->create_time;
}

idmef_time_t *idmef_heartbeat_get_analyzer_time(idmef_heartbeat_t *ptr)
{
	return ptr->analyzer_time;
}

idmef_value_t *idmef_heartbeat_get_analyzer_time_value(idmef_heartbeat_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_time(ptr->analyzer_time);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_heartbeat_set_analyzer_time(idmef_heartbeat_t *ptr, idmef_time_t *analyzer_time)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);

	ptr->analyzer_time = analyzer_time;
}

idmef_time_t *idmef_heartbeat_new_analyzer_time(idmef_heartbeat_t *ptr)
{
	if ( ptr->analyzer_time )
		idmef_time_destroy(ptr->analyzer_time);
		
	ptr->analyzer_time = idmef_time_new();

	return ptr->analyzer_time;
}

    
idmef_additional_data_t *idmef_heartbeat_get_next_additional_data(idmef_heartbeat_t *ptr, idmef_additional_data_t *object)
{
    	return prelude_list_get_next(object, &ptr->additional_data_list, idmef_additional_data_t, list);
}

void idmef_heartbeat_set_additional_data(idmef_heartbeat_t *ptr, idmef_additional_data_t *object)
{
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
}

idmef_additional_data_t *idmef_heartbeat_new_additional_data(idmef_heartbeat_t *ptr)
{
	idmef_additional_data_t *object;
	
	object = idmef_additional_data_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->additional_data_list);
	
	return object;
}

idmef_value_t *idmef_heartbeat_get_additional_data_value(idmef_heartbeat_t *ptr)
{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	idmef_additional_data_t *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->additional_data_list) {
		entry = prelude_list_entry(tmp, idmef_additional_data_t, list);

		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_ADDITIONAL_DATA);
		if ( ! val ) {
			idmef_value_destroy(list_val);
			return NULL;
		}

		if ( idmef_value_list_add(list_val, val) < 0 ) {
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		}
	}
	
	return list_val;
}


int idmef_message_type_to_numeric(const char *name)
{

	if ( strcasecmp(name, "alert" ) == 0)
		return IDMEF_MESSAGE_TYPE_ALERT;

	if ( strcasecmp(name, "heartbeat" ) == 0)
		return IDMEF_MESSAGE_TYPE_HEARTBEAT;


	return -1;
}	

const char *idmef_message_type_to_string(int val)
{
	switch ( val ) {

		case 0:
			return "NULL";

		case IDMEF_MESSAGE_TYPE_ALERT:
			return "alert";

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			return "heartbeat";

		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? "NULL" : NULL;
	}

	return NULL;
}


/*
 * typedef struct {
 *         REFCOUNT;
 * 
 *         idmef_string_t version;
 * 
 *         UNION(idmef_message_type_t, type) {
 *                 UNION_MEMBER(IDMEF_MESSAGE_TYPE_ALERT, idmef_alert_t, *alert);
 *                 UNION_MEMBER(IDMEF_MESSAGE_TYPE_HEARTBEAT, idmef_heartbeat_t, *heartbeat);
 *         } message;
 * 
 *         HIDE(prelude_msg_t *, pmsg);
 * 
 * } TYPE_ID(idmef_message_t, 49);
 */


idmef_message_t *idmef_message_ref(idmef_message_t *ptr)
{
	ptr->refcount++;

	return ptr;
}

void *idmef_message_get_child(void *p, idmef_child_t child)
{
	idmef_message_t *ptr = p;
	
	switch ( child ) {

		case 0:
			return idmef_message_get_version_value(ptr);

		case 1:
			return idmef_message_get_type_value(ptr);

		case 2: 
			if ( ptr->type == IDMEF_MESSAGE_TYPE_ALERT ) 
				return ptr->message.alert;
			return NULL;   	   

		case 3: 
			if ( ptr->type == IDMEF_MESSAGE_TYPE_HEARTBEAT ) 
				return ptr->message.heartbeat;
			return NULL;   	   

		default:
			return NULL;
	}

	return NULL;

}

void *idmef_message_new_child(void *p, idmef_child_t child, int n)
{
	idmef_message_t *ptr = p;
    
	switch ( child ) {

		case 0:
			return idmef_message_new_version(ptr);

		case 2:
			return idmef_message_new_alert(ptr);

		case 3:
			return idmef_message_new_heartbeat(ptr);

		default:
			return NULL;
	}

	return NULL;
}

void idmef_message_destroy_internal(idmef_message_t *ptr)
{

	idmef_string_destroy_internal(&ptr->version);

	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			ptr->message.alert = NULL;
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			ptr->message.heartbeat = NULL;
			break;

		default:
			break;
	}


	/* free() should be done by the caller */
}

idmef_string_t *idmef_message_get_version(idmef_message_t *ptr)
{
	return &ptr->version;
}

idmef_value_t *idmef_message_get_version_value(idmef_message_t *ptr)
{
	idmef_value_t *value;

	value = idmef_value_new_string(&ptr->version);
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;
}

void idmef_message_set_version(idmef_message_t *ptr, idmef_string_t *version)
{
	idmef_string_destroy_internal(&ptr->version);
	memcpy(&ptr->version, version, sizeof (ptr->version));
	free(version);
}

idmef_string_t *idmef_message_new_version(idmef_message_t *ptr)
{
	idmef_string_destroy_internal(&ptr->version);

	return &ptr->version;
}

idmef_message_type_t idmef_message_get_type(idmef_message_t *ptr)
{
	return ptr->type;
}

idmef_value_t *idmef_message_get_type_value(idmef_message_t *ptr)
{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_MESSAGE_TYPE, ptr->type);
}

idmef_alert_t *idmef_message_get_alert(idmef_message_t *ptr)
{
	return (ptr->type == IDMEF_MESSAGE_TYPE_ALERT) ? ptr->message.alert : NULL;
}

void idmef_message_set_alert(idmef_message_t *ptr, idmef_alert_t *alert)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			break;

		default:
			break;
	}

	ptr->message.alert = alert;
	ptr->type = IDMEF_MESSAGE_TYPE_ALERT;
}

idmef_value_t *idmef_message_get_alert_value(idmef_message_t *ptr)
{
	return ((ptr->type == IDMEF_MESSAGE_TYPE_ALERT) ?
		idmef_value_new_object(ptr->message.alert, IDMEF_OBJECT_TYPE_ALERT) :
		NULL);
}

idmef_alert_t *idmef_message_new_alert(idmef_message_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			return ptr->message.alert;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			break;

		default:
			break;
	}

	ptr->message.alert = idmef_alert_new();
	ptr->type = IDMEF_MESSAGE_TYPE_ALERT;

	return ptr->message.alert;
}

idmef_heartbeat_t *idmef_message_get_heartbeat(idmef_message_t *ptr)
{
	return (ptr->type == IDMEF_MESSAGE_TYPE_HEARTBEAT) ? ptr->message.heartbeat : NULL;
}

void idmef_message_set_heartbeat(idmef_message_t *ptr, idmef_heartbeat_t *heartbeat)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			idmef_heartbeat_destroy(ptr->message.heartbeat);
			break;

		default:
			break;
	}

	ptr->message.heartbeat = heartbeat;
	ptr->type = IDMEF_MESSAGE_TYPE_HEARTBEAT;
}

idmef_value_t *idmef_message_get_heartbeat_value(idmef_message_t *ptr)
{
	return ((ptr->type == IDMEF_MESSAGE_TYPE_HEARTBEAT) ?
		idmef_value_new_object(ptr->message.heartbeat, IDMEF_OBJECT_TYPE_HEARTBEAT) :
		NULL);
}

idmef_heartbeat_t *idmef_message_new_heartbeat(idmef_message_t *ptr)
{
	switch ( ptr->type ) {

		case IDMEF_MESSAGE_TYPE_ALERT:
			idmef_alert_destroy(ptr->message.alert);
			break;

		case IDMEF_MESSAGE_TYPE_HEARTBEAT:
			return ptr->message.heartbeat;

		default:
			break;
	}

	ptr->message.heartbeat = idmef_heartbeat_new();
	ptr->type = IDMEF_MESSAGE_TYPE_HEARTBEAT;

	return ptr->message.heartbeat;
}
