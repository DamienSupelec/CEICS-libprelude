
/* Auto-generated by the GenerateIDMEFMessageReadC package (Thu Sep 23 16:43:18 2004) */

#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "prelude-inttypes.h"
#include "prelude-list.h"
#include "prelude-log.h"
#include "extract.h"
#include "prelude-io.h"
#include "prelude-message.h"
#include "prelude-message-buffered.h"
#include "idmef-message-id.h"
#include "idmef.h"
#include "idmef-tree-wrap.h"

#include "idmef-message-read.h"
#include "idmef-util.h"


static inline int extract_string_safe(idmef_string_t **out, char *buf, size_t len)
{
        if ( buf[len - 1] ) {
                log(LOG_ERR, "Datatype error: buffer is not a string.\n");
                return -1;
        }

        *out = idmef_string_new_ref_fast(buf, len);
        if ( ! *out ) {
                log(LOG_ERR, "out of memory\n");
                return -2;
        }

        return 0;
}


static inline int extract_time_safe(idmef_time_t **out, void *buf, size_t len)
{
        if ( len != sizeof(**out) ) {
                log(LOG_ERR, "Datatype error: buffer is not a idmef time.\n");
                return -1;
        }

        *out = idmef_time_new();
        if ( ! *out ) {
                log(LOG_ERR, "out of memory\n");
                return -2;
        }

        idmef_time_set_sec(*out, extract_uint32(buf));
        idmef_time_set_usec(*out, extract_uint32(buf + 4));
        idmef_time_set_gmt_offset(*out, extract_int32(buf + 8));

        return 0;
}


static inline int extract_data_safe(idmef_data_t **out, void *buf, size_t len)
{
        *out = idmef_data_new_ref(buf, len);
        if ( ! *out ) {
                log(LOG_ERR, "out of memory\n");
                return -1;
        }

        return 0;
}



idmef_additional_data_t *idmef_read_additional_data(prelude_msg_t *msg, idmef_additional_data_t *additional_data)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_ADDITIONAL_DATA_TYPE: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_additional_data_set_type(additional_data, tmp);
				break;
			}

			case MSG_ADDITIONAL_DATA_MEANING: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_additional_data_set_meaning(additional_data, tmp);
				break;
			}

			case MSG_ADDITIONAL_DATA_DATA: {
                                idmef_data_t *tmp;

				if ( extract_data_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_additional_data_set_data(additional_data, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return additional_data;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return additional_data;

error:
	/* idmef_additional_data_destroy(additional_data); */
	return NULL;
}

idmef_classification_t *idmef_read_classification(prelude_msg_t *msg, idmef_classification_t *classification)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_CLASSIFICATION_ORIGIN: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_classification_set_origin(classification, tmp);
				break;
			}

			case MSG_CLASSIFICATION_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_classification_set_name(classification, tmp);
				break;
			}

			case MSG_CLASSIFICATION_URL: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_classification_set_url(classification, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return classification;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return classification;

error:
	/* idmef_classification_destroy(classification); */
	return NULL;
}

idmef_userid_t *idmef_read_userid(prelude_msg_t *msg, idmef_userid_t *userid)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_USERID_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_userid_set_ident(userid, tmp);
				break;
			}

			case MSG_USERID_TYPE: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_userid_set_type(userid, tmp);
				break;
			}

			case MSG_USERID_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_userid_set_name(userid, tmp);
				break;
			}

			case MSG_USERID_NUMBER: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_userid_set_number(userid, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return userid;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return userid;

error:
	/* idmef_userid_destroy(userid); */
	return NULL;
}

idmef_user_t *idmef_read_user(prelude_msg_t *msg, idmef_user_t *user)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_USER_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_user_set_ident(user, tmp);
				break;
			}

			case MSG_USER_CATEGORY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_user_set_category(user, tmp);
				break;
			}

			case MSG_USERID_TAG: {
				idmef_userid_t *tmp;

				tmp = idmef_user_new_userid(user);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_userid(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return user;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return user;

error:
	/* idmef_user_destroy(user); */
	return NULL;
}

idmef_address_t *idmef_read_address(prelude_msg_t *msg, idmef_address_t *address)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_ADDRESS_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_address_set_ident(address, tmp);
				break;
			}

			case MSG_ADDRESS_CATEGORY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_address_set_category(address, tmp);
				break;
			}

			case MSG_ADDRESS_VLAN_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_address_set_vlan_name(address, tmp);
				break;
			}

			case MSG_ADDRESS_VLAN_NUM: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_address_set_vlan_num(address, tmp);
				break;
			}

			case MSG_ADDRESS_ADDRESS: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_address_set_address(address, tmp);
				break;
			}

			case MSG_ADDRESS_NETMASK: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_address_set_netmask(address, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return address;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return address;

error:
	/* idmef_address_destroy(address); */
	return NULL;
}

idmef_process_t *idmef_read_process(prelude_msg_t *msg, idmef_process_t *process)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_PROCESS_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_process_set_ident(process, tmp);
				break;
			}

			case MSG_PROCESS_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_process_set_name(process, tmp);
				break;
			}

			case MSG_PROCESS_PID: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_process_set_pid(process, tmp);
				break;
			}

			case MSG_PROCESS_PATH: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_process_set_path(process, tmp);
				break;
			}

			case MSG_PROCESS_ARG: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_process_set_arg(process, tmp);
				break;
			}

			case MSG_PROCESS_ENV: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_process_set_env(process, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return process;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return process;

error:
	/* idmef_process_destroy(process); */
	return NULL;
}

idmef_webservice_t *idmef_read_webservice(prelude_msg_t *msg, idmef_webservice_t *webservice)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_WEBSERVICE_URL: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_webservice_set_url(webservice, tmp);
				break;
			}

			case MSG_WEBSERVICE_CGI: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_webservice_set_cgi(webservice, tmp);
				break;
			}

			case MSG_WEBSERVICE_HTTP_METHOD: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_webservice_set_http_method(webservice, tmp);
				break;
			}

			case MSG_WEBSERVICE_ARG: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_webservice_set_arg(webservice, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return webservice;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return webservice;

error:
	/* idmef_webservice_destroy(webservice); */
	return NULL;
}

idmef_snmpservice_t *idmef_read_snmpservice(prelude_msg_t *msg, idmef_snmpservice_t *snmpservice)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_SNMPSERVICE_OID: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_snmpservice_set_oid(snmpservice, tmp);
				break;
			}

			case MSG_SNMPSERVICE_COMMUNITY: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_snmpservice_set_community(snmpservice, tmp);
				break;
			}

			case MSG_SNMPSERVICE_COMMAND: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_snmpservice_set_command(snmpservice, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return snmpservice;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return snmpservice;

error:
	/* idmef_snmpservice_destroy(snmpservice); */
	return NULL;
}

idmef_service_t *idmef_read_service(prelude_msg_t *msg, idmef_service_t *service)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_SERVICE_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_service_set_ident(service, tmp);
				break;
			}

			case MSG_SERVICE_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_service_set_name(service, tmp);
				break;
			}

			case MSG_SERVICE_PORT: {
                                uint16_t tmp;

				if ( extract_uint16_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_service_set_port(service, tmp);
				break;
			}

			case MSG_SERVICE_PORTLIST: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_service_set_portlist(service, tmp);
				break;
			}

			case MSG_SERVICE_PROTOCOL: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_service_set_protocol(service, tmp);
				break;
			}

			case MSG_WEBSERVICE_TAG: {
				idmef_webservice_t *tmp;

				tmp = idmef_service_new_web(service);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_webservice(msg, tmp) )
					goto error;

				break;
			}

			case MSG_SNMPSERVICE_TAG: {
				idmef_snmpservice_t *tmp;

				tmp = idmef_service_new_snmp(service);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_snmpservice(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return service;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return service;

error:
	/* idmef_service_destroy(service); */
	return NULL;
}

idmef_node_t *idmef_read_node(prelude_msg_t *msg, idmef_node_t *node)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_NODE_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_node_set_ident(node, tmp);
				break;
			}

			case MSG_NODE_CATEGORY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_node_set_category(node, tmp);
				break;
			}

			case MSG_NODE_LOCATION: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_node_set_location(node, tmp);
				break;
			}

			case MSG_NODE_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_node_set_name(node, tmp);
				break;
			}

			case MSG_ADDRESS_TAG: {
				idmef_address_t *tmp;

				tmp = idmef_node_new_address(node);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_address(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return node;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return node;

error:
	/* idmef_node_destroy(node); */
	return NULL;
}

idmef_source_t *idmef_read_source(prelude_msg_t *msg, idmef_source_t *source)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_SOURCE_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_source_set_ident(source, tmp);
				break;
			}

			case MSG_SOURCE_SPOOFED: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_source_set_spoofed(source, tmp);
				break;
			}

			case MSG_SOURCE_INTERFACE: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_source_set_interface(source, tmp);
				break;
			}

			case MSG_NODE_TAG: {
				idmef_node_t *tmp;

				tmp = idmef_source_new_node(source);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_node(msg, tmp) )
					goto error;

				break;
			}

			case MSG_USER_TAG: {
				idmef_user_t *tmp;

				tmp = idmef_source_new_user(source);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_user(msg, tmp) )
					goto error;

				break;
			}

			case MSG_PROCESS_TAG: {
				idmef_process_t *tmp;

				tmp = idmef_source_new_process(source);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_process(msg, tmp) )
					goto error;

				break;
			}

			case MSG_SERVICE_TAG: {
				idmef_service_t *tmp;

				tmp = idmef_source_new_service(source);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_service(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return source;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return source;

error:
	/* idmef_source_destroy(source); */
	return NULL;
}

idmef_file_access_t *idmef_read_file_access(prelude_msg_t *msg, idmef_file_access_t *file_access)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_USERID_TAG: {
				idmef_userid_t *tmp;

				tmp = idmef_file_access_new_userid(file_access);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_userid(msg, tmp) )
					goto error;

				break;
			}

			case MSG_FILE_ACCESS_PERMISSION: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_access_set_permission(file_access, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return file_access;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return file_access;

error:
	/* idmef_file_access_destroy(file_access); */
	return NULL;
}

idmef_inode_t *idmef_read_inode(prelude_msg_t *msg, idmef_inode_t *inode)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_INODE_CHANGE_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_inode_set_change_time(inode, tmp);
				break;
			}

			case MSG_INODE_NUMBER: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_inode_set_number(inode, tmp);
				break;
			}

			case MSG_INODE_MAJOR_DEVICE: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_inode_set_major_device(inode, tmp);
				break;
			}

			case MSG_INODE_MINOR_DEVICE: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_inode_set_minor_device(inode, tmp);
				break;
			}

			case MSG_INODE_C_MAJOR_DEVICE: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_inode_set_c_major_device(inode, tmp);
				break;
			}

			case MSG_INODE_C_MINOR_DEVICE: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_inode_set_c_minor_device(inode, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return inode;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return inode;

error:
	/* idmef_inode_destroy(inode); */
	return NULL;
}

idmef_file_t *idmef_read_file(prelude_msg_t *msg, idmef_file_t *file)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_FILE_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_ident(file, tmp);
				break;
			}

			case MSG_FILE_CATEGORY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_category(file, tmp);
				break;
			}

			case MSG_FILE_FSTYPE: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_fstype(file, tmp);
				break;
			}

			case MSG_FILE_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_name(file, tmp);
				break;
			}

			case MSG_FILE_PATH: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_path(file, tmp);
				break;
			}

			case MSG_FILE_CREATE_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_create_time(file, tmp);
				break;
			}

			case MSG_FILE_MODIFY_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_modify_time(file, tmp);
				break;
			}

			case MSG_FILE_ACCESS_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_access_time(file, tmp);
				break;
			}

			case MSG_FILE_DATA_SIZE: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_data_size(file, tmp);
				break;
			}

			case MSG_FILE_DISK_SIZE: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_file_set_disk_size(file, tmp);
				break;
			}

			case MSG_FILE_ACCESS_TAG: {
				idmef_file_access_t *tmp;

				tmp = idmef_file_new_file_access(file);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_file_access(msg, tmp) )
					goto error;

				break;
			}

			case MSG_LINKAGE_TAG: {
				idmef_linkage_t *tmp;

				tmp = idmef_file_new_file_linkage(file);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_linkage(msg, tmp) )
					goto error;

				break;
			}

			case MSG_INODE_TAG: {
				idmef_inode_t *tmp;

				tmp = idmef_file_new_inode(file);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_inode(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return file;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return file;

error:
	/* idmef_file_destroy(file); */
	return NULL;
}

idmef_linkage_t *idmef_read_linkage(prelude_msg_t *msg, idmef_linkage_t *linkage)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_LINKAGE_CATEGORY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_linkage_set_category(linkage, tmp);
				break;
			}

			case MSG_LINKAGE_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_linkage_set_name(linkage, tmp);
				break;
			}

			case MSG_LINKAGE_PATH: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_linkage_set_path(linkage, tmp);
				break;
			}

			case MSG_FILE_TAG: {
				idmef_file_t *tmp;

				tmp = idmef_linkage_new_file(linkage);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_file(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return linkage;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return linkage;

error:
	/* idmef_linkage_destroy(linkage); */
	return NULL;
}

idmef_target_t *idmef_read_target(prelude_msg_t *msg, idmef_target_t *target)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_TARGET_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_target_set_ident(target, tmp);
				break;
			}

			case MSG_TARGET_DECOY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_target_set_decoy(target, tmp);
				break;
			}

			case MSG_TARGET_INTERFACE: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_target_set_interface(target, tmp);
				break;
			}

			case MSG_NODE_TAG: {
				idmef_node_t *tmp;

				tmp = idmef_target_new_node(target);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_node(msg, tmp) )
					goto error;

				break;
			}

			case MSG_USER_TAG: {
				idmef_user_t *tmp;

				tmp = idmef_target_new_user(target);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_user(msg, tmp) )
					goto error;

				break;
			}

			case MSG_PROCESS_TAG: {
				idmef_process_t *tmp;

				tmp = idmef_target_new_process(target);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_process(msg, tmp) )
					goto error;

				break;
			}

			case MSG_SERVICE_TAG: {
				idmef_service_t *tmp;

				tmp = idmef_target_new_service(target);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_service(msg, tmp) )
					goto error;

				break;
			}

			case MSG_FILE_TAG: {
				idmef_file_t *tmp;

				tmp = idmef_target_new_file(target);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_file(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return target;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return target;

error:
	/* idmef_target_destroy(target); */
	return NULL;
}

idmef_analyzer_t *idmef_read_analyzer(prelude_msg_t *msg, idmef_analyzer_t *analyzer)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_ANALYZER_ANALYZERID: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_analyzer_set_analyzerid(analyzer, tmp);
				break;
			}

			case MSG_ANALYZER_MANUFACTURER: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_analyzer_set_manufacturer(analyzer, tmp);
				break;
			}

			case MSG_ANALYZER_MODEL: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_analyzer_set_model(analyzer, tmp);
				break;
			}

			case MSG_ANALYZER_VERSION: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_analyzer_set_version(analyzer, tmp);
				break;
			}

			case MSG_ANALYZER_CLASS: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_analyzer_set_class(analyzer, tmp);
				break;
			}

			case MSG_ANALYZER_OSTYPE: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_analyzer_set_ostype(analyzer, tmp);
				break;
			}

			case MSG_ANALYZER_OSVERSION: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_analyzer_set_osversion(analyzer, tmp);
				break;
			}

			case MSG_NODE_TAG: {
				idmef_node_t *tmp;

				tmp = idmef_analyzer_new_node(analyzer);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_node(msg, tmp) )
					goto error;

				break;
			}

			case MSG_PROCESS_TAG: {
				idmef_process_t *tmp;

				tmp = idmef_analyzer_new_process(analyzer);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_process(msg, tmp) )
					goto error;

				break;
			}

			case MSG_ANALYZER_TAG: {
				idmef_analyzer_t *tmp;

				tmp = idmef_analyzer_new_analyzer(analyzer);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_analyzer(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return analyzer;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return analyzer;

error:
	/* idmef_analyzer_destroy(analyzer); */
	return NULL;
}

idmef_alertident_t *idmef_read_alertident(prelude_msg_t *msg, idmef_alertident_t *alertident)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_ALERTIDENT_ALERTIDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_alertident_set_alertident(alertident, tmp);
				break;
			}

			case MSG_ALERTIDENT_ANALYZERID: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_alertident_set_analyzerid(alertident, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return alertident;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return alertident;

error:
	/* idmef_alertident_destroy(alertident); */
	return NULL;
}

idmef_impact_t *idmef_read_impact(prelude_msg_t *msg, idmef_impact_t *impact)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_IMPACT_SEVERITY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_impact_set_severity(impact, tmp);
				break;
			}

			case MSG_IMPACT_COMPLETION: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_impact_set_completion(impact, tmp);
				break;
			}

			case MSG_IMPACT_TYPE: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_impact_set_type(impact, tmp);
				break;
			}

			case MSG_IMPACT_DESCRIPTION: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_impact_set_description(impact, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return impact;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return impact;

error:
	/* idmef_impact_destroy(impact); */
	return NULL;
}

idmef_action_t *idmef_read_action(prelude_msg_t *msg, idmef_action_t *action)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_ACTION_CATEGORY: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_action_set_category(action, tmp);
				break;
			}

			case MSG_ACTION_DESCRIPTION: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_action_set_description(action, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return action;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return action;

error:
	/* idmef_action_destroy(action); */
	return NULL;
}

idmef_confidence_t *idmef_read_confidence(prelude_msg_t *msg, idmef_confidence_t *confidence)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_CONFIDENCE_RATING: {
                                int32_t tmp;

				if ( extract_int32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_confidence_set_rating(confidence, tmp);
				break;
			}

			case MSG_CONFIDENCE_CONFIDENCE: {
                                float tmp;

				if ( extract_float_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_confidence_set_confidence(confidence, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return confidence;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return confidence;

error:
	/* idmef_confidence_destroy(confidence); */
	return NULL;
}

idmef_assessment_t *idmef_read_assessment(prelude_msg_t *msg, idmef_assessment_t *assessment)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_IMPACT_TAG: {
				idmef_impact_t *tmp;

				tmp = idmef_assessment_new_impact(assessment);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_impact(msg, tmp) )
					goto error;

				break;
			}

			case MSG_ACTION_TAG: {
				idmef_action_t *tmp;

				tmp = idmef_assessment_new_action(assessment);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_action(msg, tmp) )
					goto error;

				break;
			}

			case MSG_CONFIDENCE_TAG: {
				idmef_confidence_t *tmp;

				tmp = idmef_assessment_new_confidence(assessment);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_confidence(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return assessment;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return assessment;

error:
	/* idmef_assessment_destroy(assessment); */
	return NULL;
}

idmef_tool_alert_t *idmef_read_tool_alert(prelude_msg_t *msg, idmef_tool_alert_t *tool_alert)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_TOOL_ALERT_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_tool_alert_set_name(tool_alert, tmp);
				break;
			}

			case MSG_TOOL_ALERT_COMMAND: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_tool_alert_set_command(tool_alert, tmp);
				break;
			}

			case MSG_ALERTIDENT_TAG: {
				idmef_alertident_t *tmp;

				tmp = idmef_tool_alert_new_alertident(tool_alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_alertident(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return tool_alert;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return tool_alert;

error:
	/* idmef_tool_alert_destroy(tool_alert); */
	return NULL;
}

idmef_correlation_alert_t *idmef_read_correlation_alert(prelude_msg_t *msg, idmef_correlation_alert_t *correlation_alert)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_CORRELATION_ALERT_NAME: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_correlation_alert_set_name(correlation_alert, tmp);
				break;
			}

			case MSG_ALERTIDENT_TAG: {
				idmef_alertident_t *tmp;

				tmp = idmef_correlation_alert_new_alertident(correlation_alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_alertident(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return correlation_alert;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return correlation_alert;

error:
	/* idmef_correlation_alert_destroy(correlation_alert); */
	return NULL;
}

idmef_overflow_alert_t *idmef_read_overflow_alert(prelude_msg_t *msg, idmef_overflow_alert_t *overflow_alert)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_OVERFLOW_ALERT_PROGRAM: {
                                idmef_string_t *tmp;

				if ( extract_string_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_overflow_alert_set_program(overflow_alert, tmp);
				break;
			}

			case MSG_OVERFLOW_ALERT_SIZE: {
                                uint32_t tmp;

				if ( extract_uint32_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_overflow_alert_set_size(overflow_alert, tmp);
				break;
			}

			case MSG_OVERFLOW_ALERT_BUFFER: {
                                idmef_data_t *tmp;

				if ( extract_data_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_overflow_alert_set_buffer(overflow_alert, tmp);
				break;
			}

			case MSG_END_OF_TAG:
				return overflow_alert;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return overflow_alert;

error:
	/* idmef_overflow_alert_destroy(overflow_alert); */
	return NULL;
}

idmef_alert_t *idmef_read_alert(prelude_msg_t *msg, idmef_alert_t *alert)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_ALERT_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_alert_set_ident(alert, tmp);
				break;
			}

			case MSG_ASSESSMENT_TAG: {
				idmef_assessment_t *tmp;

				tmp = idmef_alert_new_assessment(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_assessment(msg, tmp) )
					goto error;

				break;
			}

			case MSG_ANALYZER_TAG: {
				idmef_analyzer_t *tmp;

				tmp = idmef_alert_new_analyzer(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_analyzer(msg, tmp) )
					goto error;

				break;
			}

			case MSG_ALERT_CREATE_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_alert_set_create_time(alert, tmp);
				break;
			}

			case MSG_ALERT_DETECT_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_alert_set_detect_time(alert, tmp);
				break;
			}

			case MSG_ALERT_ANALYZER_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_alert_set_analyzer_time(alert, tmp);
				break;
			}

			case MSG_SOURCE_TAG: {
				idmef_source_t *tmp;

				tmp = idmef_alert_new_source(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_source(msg, tmp) )
					goto error;

				break;
			}

			case MSG_TARGET_TAG: {
				idmef_target_t *tmp;

				tmp = idmef_alert_new_target(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_target(msg, tmp) )
					goto error;

				break;
			}

			case MSG_CLASSIFICATION_TAG: {
				idmef_classification_t *tmp;

				tmp = idmef_alert_new_classification(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_classification(msg, tmp) )
					goto error;

				break;
			}

			case MSG_ADDITIONAL_DATA_TAG: {
				idmef_additional_data_t *tmp;

				tmp = idmef_alert_new_additional_data(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_additional_data(msg, tmp) )
					goto error;

				break;
			}

			case MSG_TOOL_ALERT_TAG: {
				idmef_tool_alert_t *tmp;

				tmp = idmef_alert_new_tool_alert(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_tool_alert(msg, tmp) )
					goto error;

				break;
			}

			case MSG_CORRELATION_ALERT_TAG: {
				idmef_correlation_alert_t *tmp;

				tmp = idmef_alert_new_correlation_alert(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_correlation_alert(msg, tmp) )
					goto error;

				break;
			}

			case MSG_OVERFLOW_ALERT_TAG: {
				idmef_overflow_alert_t *tmp;

				tmp = idmef_alert_new_overflow_alert(alert);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_overflow_alert(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return alert;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return alert;

error:
	/* idmef_alert_destroy(alert); */
	return NULL;
}

idmef_heartbeat_t *idmef_read_heartbeat(prelude_msg_t *msg, idmef_heartbeat_t *heartbeat)
{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) {

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) {

			case MSG_HEARTBEAT_IDENT: {
                                uint64_t tmp;

				if ( extract_uint64_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_heartbeat_set_ident(heartbeat, tmp);
				break;
			}

			case MSG_ANALYZER_TAG: {
				idmef_analyzer_t *tmp;

				tmp = idmef_heartbeat_new_analyzer(heartbeat);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_analyzer(msg, tmp) )
					goto error;

				break;
			}

			case MSG_HEARTBEAT_CREATE_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_heartbeat_set_create_time(heartbeat, tmp);
				break;
			}

			case MSG_HEARTBEAT_ANALYZER_TIME: {
                                idmef_time_t *tmp;

				if ( extract_time_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_heartbeat_set_analyzer_time(heartbeat, tmp);
				break;
			}

			case MSG_ADDITIONAL_DATA_TAG: {
				idmef_additional_data_t *tmp;

				tmp = idmef_heartbeat_new_additional_data(heartbeat);
				if ( ! tmp)
					goto error;

				if ( ! idmef_read_additional_data(msg, tmp) )
					goto error;

				break;
			}

			case MSG_END_OF_TAG:
				return heartbeat;

			default:
				log(LOG_ERR, "couldn't handle tag %d.\n", tag);
				goto error;
		}

	}

	return heartbeat;

error:
	/* idmef_heartbeat_destroy(heartbeat); */
	return NULL;
}

/*
 * It is up to the caller to implement the toplevel function in order to handle
 * specific stuff
 */
