# Copyright (C) 2003 Nicolas Delon <delon.nicolas@wanadoo.fr>
# All Rights Reserved
#
# This file is part of the Prelude program.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

package GenerateIDMEFTreeWrapC;

use Generate;
@ISA = qw/Generate/;

use strict;
use IDMEFTree;

sub	header
{
    my	$self = shift;
    my	$file = $self->{file};
    my	$time = localtime;

    $self->output("
/* Auto-generated by the GenerateIDMEFTreeWrapC package ($time) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>

#include \"prelude-inttypes.h\"
#include \"prelude-list.h\"
#include \"prelude-message.h\"

#include \"idmef-string.h\"
#include \"idmef-time.h\"
#include \"idmef-data.h\"
#include \"idmef-type.h\"
#include \"idmef-value.h\"

#include \"idmef-tree-wrap.h\"

#define LISTED_OBJECT(name, type) prelude_list_t name

#define IS_LISTED prelude_list_t list

#define	UNION(type, var) type var; union

#define	UNION_MEMBER(value, type, name) type name

#define ENUM(...) typedef enum

#define PRE_DECLARE(type, class)

#define TYPE_ID(type, id) type

#define PRIMITIVE_TYPE(type)
#define PRIMITIVE_TYPE_STRUCT(type)

#define HIDE(type, name) type name

#define REFCOUNT int refcount

#define DYNAMIC_IDENT(x) uint64_t x

");
}

sub	struct_desc
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my $line;

    $self->output("\n\nstruct idmef_$struct->{short_typename} \{");

    foreach ( @{ $struct->{desc} } ) {
	$line = $_;
	$line =~ s/.*TYPE_ID.*//;
        $line =~ s/struct {//;
    $self->output(" $line\n");

    }
    #$self->output(" $_\n") foreach ( @{ $struct->{desc} } ~ s/.*TYPE_ID.*// );
    $self->output("\};\n\n");
}

sub	struct_constructor
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    $self->output("
$struct->{typename} *idmef_$struct->{short_typename}_new(void)
\{
	$struct->{typename} *ret;

	ret = calloc(1, sizeof(*ret));
	if ( ! ret )
		return NULL;
");

    if ( $struct->{is_listed} ) {
	$self->output("
	PRELUDE_INIT_LIST_HEAD(&ret->list);
");
    }

    if ( $struct->{refcount} ) {
	$self->output("
	ret->refcount = 1;
");
    }

    foreach my $field ( map { $_->{metatype} & &METATYPE_LIST ? $_ : () } @{ $struct->{field_list} } ) {
	$self->output("
	PRELUDE_INIT_LIST_HEAD(&ret->$field->{name});
    
");

    }
    $self->output("
	return ret;

\}
");
}

sub	struct_get_child
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$n = 0;

    $self->output("
void *idmef_$struct->{short_typename}_get_child(void *p, idmef_child_t child)
\{
	$struct->{typename} *ptr = p;
	
	switch ( child ) \{
");

    foreach my $field ( @{ $struct->{field_list} } ) {

	if ( $field->{metatype} & &METATYPE_LIST ) {

	    $self->output("
		case $n:
			return &ptr->$field->{name};
");
	} elsif ( $field->{metatype} & &METATYPE_UNION ) {

	    $self->output("
		case ${n}:
			return idmef_$struct->{short_typename}_get_$field->{var}_value(ptr);
");

	    $n++;

	    foreach my $member ( @{ $field->{member_list} } ) {
		$self->output("
		case $n: 
			if ( ptr->$field->{var} == $member->{value} ) 
				return ptr->$field->{name}.$member->{name};
			return NULL;   	   
");
		$n++;
	    }
	} elsif ( $field->{metatype} & (&METATYPE_PRIMITIVE | &METATYPE_ENUM) ) {

	    $self->output("
		case $n:
			return idmef_$struct->{short_typename}_get_$field->{short_name}_value(ptr);
");
	} else {
	    my $refer = $field->{ptr} ? "" : "&";

	    $self->output("
		case ${n}:
			return ${refer}ptr->$field->{name};
");
	}

	$n++;
    }

    $self->output("
		default:
			return NULL;
	\}

	return NULL;

\}
");
}

sub	struct_new_child
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$n = 0;

    $self->output("
void *idmef_$struct->{short_typename}_new_child(void *p, idmef_child_t child, int n)
\{
	$struct->{typename} *ptr = p;
    
	switch ( child ) \{
");

    foreach my $field ( @{ $struct->{field_list} } ) {

	if ( $field->{metatype} & &METATYPE_LIST ) {
	    $self->output("
		case $n: \{
                        int i, j;
			prelude_list_t *tmp;
			void *entry = NULL;

			if ( n < 0 ) \{
				 /* n < 0 denotes that we just have to add a list element */
				
				 entry = idmef_$struct->{short_typename}_new_$field->{short_name}(ptr);
			\} else \{
				/* n >= 0, so the new element has to be n-th in the list  */
			
				/* get n-th element of the list */
				i = 0;
				prelude_list_for_each(tmp, &ptr->$field->{name}) \{
			    		entry = prelude_list_entry(tmp, $field->{typename}, list);
					if ( i++ == n )
						return entry;
				
				\}
			
				/* we must add n-i list elements */
				for ( j = i; j <= n; j++ ) \{
			    		entry = idmef_$struct->{short_typename}_new_$field->{short_name}(ptr);
					if ( ! entry )
						return NULL; /* out of memory? */
				\}
			\}
			
			return entry;
		\}
");
	} elsif ( $field->{metatype} & &METATYPE_UNION ) {

	    $n++;

	    foreach my $member ( @{ $field->{member_list} } ) {
		$self->output("
		case $n:
			return idmef_$struct->{short_typename}_new_$member->{name}(ptr);
");
		$n++;
	    }
	    
	} elsif ( $field->{metatype} & &METATYPE_NORMAL ) {
	    $self->output("
		case $n:
			return idmef_$struct->{short_typename}_new_$field->{name}(ptr);
");
	}
	
	$n++;
    }

    $self->output("
		default:
			return NULL;
	\}

	return NULL;
\}
");
}

sub	struct_destroy_internal
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    $self->output("
static void idmef_$struct->{short_typename}_destroy_internal($struct->{typename} *ptr)
\{
");

    $self->output("
	prelude_list_del(&ptr->list);
") if ( $struct->{is_listed} );

    foreach my $field ( @{ $struct->{field_list} } ) {
	if ( $field->{metatype} & &METATYPE_LIST ) {

	    $self->output("
	\{
		prelude_list_t *n, *tmp;
		$field->{typename} *entry;

		prelude_list_for_each_safe(tmp, n, &ptr->$field->{name}) \{
			entry = prelude_list_entry(tmp, $field->{typename}, list);
			idmef_$field->{short_typename}_destroy(entry);
		\}
	\}
");

	} elsif ( $field->{metatype} & &METATYPE_UNION ) {
	    $self->output("
	switch ( ptr->$field->{var} ) {
");

	    foreach my $member ( @{ $field->{member_list} } ) {

		$self->output("
		case $member->{value}:
			idmef_$member->{short_typename}_destroy(ptr->$field->{name}.$member->{name});
			ptr->$field->{name}.$member->{name} = NULL;
			break;
");
	    }
	    $self->output("
		default:
			break;
	}
");
	} elsif ( $field->{metatype} & &METATYPE_STRUCT ) {

	    if ( $field->{ptr} ) {
		$self->output("
	if ( ptr->$field->{name} ) \{
		idmef_$field->{short_typename}_destroy(ptr->$field->{name});
		ptr->$field->{name} = NULL;
	\}
");
	    } else {
		$self->output("
	idmef_$field->{short_typename}_destroy_internal(&ptr->$field->{name});
");
	    }
	} elsif ( $field->{metatype} & &METATYPE_PRIMITIVE ) {

	    if ( $field->{ptr} ) {
		$self->output("
	if ( ptr->$field->{name} )
		free(ptr->$field->{name});
");
	    }
	}
    }

    $self->output("

	/* free() should be done by the caller */
\}
");
}

sub	struct_destroy
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    return if ( $struct->{toplevel} );
    if ( $struct->{refcount} ) {
	$self->output("
void idmef_$struct->{short_typename}_destroy($struct->{typename} *ptr)
\{
	if ( --ptr->refcount )
		return;

	idmef_$struct->{short_typename}_destroy_internal(ptr);
        free(ptr);
\}
");

    } else {
	$self->output("
void idmef_$struct->{short_typename}_destroy($struct->{typename} *ptr)
\{
	idmef_$struct->{short_typename}_destroy_internal(ptr);
        free(ptr);
\}
");
    }
}

sub	struct_ref
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    $struct->{refcount} or return;

    $self->output("
$struct->{typename} *idmef_$struct->{short_typename}_ref($struct->{typename} *ptr)
\{
	ptr->refcount++;

	return ptr;
\}
");
}

sub	struct_field_normal
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;
    my	$name = shift || $field->{name};
    my	$ptr = "";
    my	$refer = "";

    if ( $field->{ptr} ) {
	if ( $field->{metatype} & &METATYPE_STRUCT ) {
	    $ptr = "*";

	} else {
	    $refer = "*";
	}

    } else {
	if ( $field->{metatype} & &METATYPE_STRUCT ) {
	    $ptr = "*";
	    $refer = "&";
	}
    }

    ##############################
    # Generate *_get_* functions #
    ##############################

    $self->output("
$field->{typename} ${ptr}idmef_$struct->{short_typename}_get_${name}($struct->{typename} *ptr)
\{");

    if ( $field->{metatype} & &METATYPE_PRIMITIVE && !($field->{metatype} & &METATYPE_STRUCT) && $field->{ptr}) {
	$self->output("
	return ptr->$field->{name} ? *ptr->$field->{name} : ($field->{typename}) 0;");

    } else {
	$self->output("
	return ${refer}ptr->$field->{name};");
    }

    $self->output("
\}
");
    
    
    ####################################
    # Generate *_get_*_value functions #
    ####################################

    if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
	$self->output("
idmef_value_t *idmef_$struct->{short_typename}_get_${name}_value($struct->{typename} *ptr)
\{");
	if ( !($field->{metatype} & &METATYPE_STRUCT) && $field->{ptr} ) {
	    $self->output("
	return idmef_value_new_$field->{short_typename}(ptr->$field->{name} ? *ptr->$field->{name} : ($field->{typename}) 0);");
	    
	} else {
	    $self->output("
	idmef_value_t *value;

	value = idmef_value_new_$field->{short_typename}(${refer}ptr->$field->{name});
	if ( ! value )
		return NULL;

	idmef_value_dont_have_own_data(value);

	return value;");
	}

	$self->output("
\}
");

    } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
	$self->output("
idmef_value_t *idmef_$struct->{short_typename}_get_${name}_value($struct->{typename} *ptr)
\{
	return idmef_value_new_object(${refer}ptr->$field->{name}, IDMEF_OBJECT_TYPE_" . uc("$field->{short_typename}") . ");
\}
");

    } elsif ( $field->{metatype} & &METATYPE_ENUM ) {
	$self->output("
idmef_value_t *idmef_$struct->{short_typename}_get_${name}_value($struct->{typename} *ptr)
\{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_" . uc("$field->{short_typename}") . ", ptr->$field->{name});
\}
");

    }

    ##############################
    # Generate *_set_* functions #
    ##############################

    if ( $field->{metatype} & &METATYPE_STRUCT ) {
	if ( $field->{ptr} ) {
	    $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} *$field->{name})
\{
	if ( ptr->$field->{name} )
		idmef_$field->{short_typename}_destroy(ptr->$field->{name});

	ptr->$field->{name} = $field->{name};
\}
");
	} else {
	    $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} *$field->{name})
\{
	idmef_$field->{short_typename}_destroy_internal(&ptr->$field->{name});
	memcpy(&ptr->$field->{name}, $field->{name}, sizeof (ptr->$field->{name}));
	free($field->{name});
\}
");
	}
    } else {
	if ( $field->{ptr} ) {
	    $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} $field->{name})
\{
	if ( ptr->$field->{name} )
		free(ptr->$field->{name});

	ptr->$field->{name} = malloc(sizeof (*ptr->$field->{name}));
	*ptr->$field->{name} = $field->{name};
\}
");

	} else {
	    $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} $field->{name})
\{
	ptr->$field->{name} = $field->{name};
\}
");
	}
    }

    ##############################
    # Generate *_new_* functions #
    ##############################

    $self->output("
$field->{typename} *idmef_$struct->{short_typename}_new_${name}($struct->{typename} *ptr)
\{");

    if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {

	if ( $field->{metatype} & &METATYPE_STRUCT ) {

	    if ( $field->{ptr} ) {

		$self->output("
	if ( ptr->$field->{name} )
		idmef_$field->{short_typename}_destroy(ptr->$field->{name});
		
	ptr->$field->{name} = idmef_$field->{short_typename}_new();
");
	    } else {

		$self->output("
	idmef_$field->{short_typename}_destroy_internal(&ptr->$field->{name});
");
	    }

	} else {
	    if ( $field->{ptr} ) {
		$self->output("
	if ( ptr->$field->{name} )
		free(ptr->$field->{name});

	ptr->$field->{name} = calloc(1, sizeof (*ptr->$field->{name}));
");
	    }
	}

    } else {
	if ( $field->{metatype} & &METATYPE_STRUCT && $field->{ptr} ) {
	    $self->output("
	if ( ! ptr->$field->{name} )
		ptr->$field->{name} = idmef_$field->{short_typename}_new();
");
	}
    }

    $refer = $field->{ptr} ? "" : "&";

    $self->output("
	return ${refer}ptr->$field->{name};
\}
");
}

sub	struct_field_union
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;

    $self->output("
$field->{typename} idmef_$struct->{short_typename}_get_$field->{var}($struct->{typename} *ptr)
\{
	return ptr->$field->{var};
\}
");
    $self->output("
idmef_value_t *idmef_$struct->{short_typename}_get_$field->{var}_value($struct->{typename} *ptr)
\{
	return idmef_value_new_enum_numeric(IDMEF_OBJECT_TYPE_" . uc("$field->{short_typename}") . ", ptr->$field->{var});
\}
");

    foreach my $member ( @{ $field->{member_list} } ) {
	$self->output("
$member->{typename} *idmef_$struct->{short_typename}_get_$member->{name}($struct->{typename} *ptr)
\{
	return (ptr->$field->{var} == $member->{value}) ? ptr->$field->{name}.$member->{name} : NULL;
\}
"
);

	$self->output("
void idmef_$struct->{short_typename}_set_$member->{name}($struct->{typename} *ptr, $member->{typename} *$member->{name})
\{
	switch ( ptr->$field->{var} ) \{
");
	foreach my $member ( @{ $field->{member_list} } ) {
	    $self->output("
		case $member->{value}:
			idmef_$member->{short_typename}_destroy(ptr->$field->{name}.$member->{name});
			break;
");
	}

	$self->output("
		default:
			break;
	\}

	ptr->$field->{name}.$member->{name} = $member->{name};
	ptr->$field->{var} = $member->{value};
\}
");
	

	$self->output("
idmef_value_t *idmef_$struct->{short_typename}_get_$member->{name}_value($struct->{typename} *ptr)
\{
	return ((ptr->$field->{var} == $member->{value}) ?
		idmef_value_new_object(ptr->$field->{name}.$member->{name}, IDMEF_OBJECT_TYPE_" . uc("$member->{short_typename}") . ") :
		NULL);
\}
");

	$self->output("
$member->{typename} *idmef_$struct->{short_typename}_new_$member->{name}($struct->{typename} *ptr)
\{
	switch ( ptr->$field->{var} ) \{
");
	foreach my $other_member ( @{ $field->{member_list} } ) {

	    if ( $other_member == $member ) {
		$self->output("
		case $member->{value}:
			return ptr->$field->{name}.$member->{name};
"); 
	    } else {
		$self->output("
		case $other_member->{value}:
			idmef_$other_member->{short_typename}_destroy(ptr->$field->{name}.$other_member->{name});
			break;
");
	    }
	}

	$self->output("
		default:
			break;
	\}

	ptr->$field->{name}.$member->{name} = idmef_$member->{short_typename}_new();
	ptr->$field->{var} = $member->{value};

	return ptr->$field->{name}.$member->{name};
\}
");
    }
}

sub	struct_field_list
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;

    $self->output("
    
$field->{typename} *idmef_$struct->{short_typename}_get_next_$field->{short_name}($struct->{typename} *ptr, $field->{typename} *object)
\{
    	return prelude_list_get_next(object, &ptr->$field->{name}, $field->{typename}, list);
\}

void idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{typename} *ptr, $field->{typename} *object)
\{
	prelude_list_add_tail(&object->list, &ptr->$field->{name});
\}

$field->{typename} *idmef_$struct->{short_typename}_new_$field->{short_name}($struct->{typename} *ptr)
\{
	$field->{typename} *object;
	
	object = idmef_$field->{short_typename}_new();
	if ( ! object )
		return NULL;
	
	prelude_list_add_tail(&object->list, &ptr->$field->{name});
	
	return object;
\}

idmef_value_t *idmef_$struct->{short_typename}_get_$field->{short_name}_value($struct->{typename} *ptr)
\{
        prelude_list_t *tmp;
	idmef_value_t *val, *list_val;
	$field->{typename} *entry;
	
	list_val = idmef_value_new_list();
	if ( ! list_val )
		return NULL;
	
	prelude_list_for_each(tmp, &ptr->$field->{name}) \{
		entry = prelude_list_entry(tmp, $field->{typename}, list);
");

    if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
	$self->output("
		val = idmef_value_new_$field->{short_typename}(entry);
		if ( ! val ) \{
			idmef_value_destroy(list_val);
			return NULL;
		\}
		idmef_value_dont_have_own_data(val);
");

    } else {
	$self->output("
		val = idmef_value_new_object(entry, IDMEF_OBJECT_TYPE_" . uc("$field->{short_typename}") . ");
		if ( ! val ) \{
			idmef_value_destroy(list_val);
			return NULL;
		\}
");
    }

    $self->output("
		if ( idmef_value_list_add(list_val, val) < 0 ) \{
			idmef_value_destroy(list_val);
			idmef_value_destroy(val);
			return NULL;
		\}
	\}
	
	return list_val;
\}

");
}

sub	struct_fields
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    foreach my $field ( @{ $struct->{field_list} } ) {
	$self->struct_field_normal($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_NORMAL );
 	$self->struct_field_list($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_LIST );
 	$self->struct_field_union($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_UNION );
    }
}

sub	struct
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    $self->struct_desc($tree, $struct);
}

sub	struct_func
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    $self->struct_constructor($tree, $struct);
    $self->struct_ref($tree, $struct);
    $self->struct_get_child($tree, $struct);
    $self->struct_new_child($tree, $struct);
    $self->struct_destroy_internal($tree, $struct);
    $self->struct_destroy($tree, $struct);
    $self->struct_fields($tree, $struct);
}

sub	enum
{
    my	$self = shift;
    my	$tree = shift;
    my	$enum = shift;

    $self->output("
int idmef_$enum->{short_typename}_to_numeric(const char *name)
\{
");

    foreach my $field ( @{ $enum->{field_list} } ) {
	my $fullname = 'IDMEF_' . uc($enum->{short_typename});
	my $fieldname = $field->{name};
	$fieldname =~ s/^${fullname}_//;
	$fieldname = lc($fieldname);
	$fieldname =~ tr/_/-/;

	$self->output("
	if ( strcasecmp(name, \"$fieldname\" ) == 0)
		return $field->{name};
");
    }

    $self->output("

	return -1;
\}	
");

        $self->output("
const char *idmef_$enum->{short_typename}_to_string(int val)
\{
	switch ( val ) \{
");

    my $cnt = 0;

    foreach my $field ( @{ $enum->{field_list} } ) {

	if ( $cnt == 0 && $field->{value} != 0 ) {
	    $self->output("
		case 0:
			return \"NULL\";
");
	}
	
	my $fullname = 'IDMEF_' . uc($enum->{short_typename});
	my $fieldname = $field->{name};
	$fieldname =~ s/^${fullname}_//;
	$fieldname = lc($fieldname);
	$fieldname =~ tr/_/-/;

	$self->output("
		case $field->{name}:
			return \"$fieldname\";
");

	$cnt++;
    }


    $self->output("
		default:
			/* if we did not hit 0 earlier, we treat is as undefined/NULL */
			return ( val == 0 ) ? \"NULL\" : NULL;
	\}

	return NULL;
\}
");
}


sub footer 
{
    my $self = shift;

    $self->output("
void idmef_message_set_pmsg(idmef_message_t *message, prelude_msg_t *msg)
\{
        message->pmsg = msg;
\}


prelude_msg_t *idmef_message_get_pmsg(idmef_message_t *message)
\{
        return message->pmsg;
\}


void idmef_message_destroy(idmef_message_t *message)
\{
        if ( --message->refcount )
                return;

        idmef_message_destroy_internal(message);

        if ( message->pmsg )
                prelude_msg_destroy(message->pmsg);

        free(message);
\}
");

}
1;
