# Copyright (C) 2003 Nicolas Delon <delon.nicolas@wanadoo.fr>
# All Rights Reserved
#
# This file is part of the Prelude program.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

package GenerateIDMEFMessageRecvC;

use Generate;
@ISA = qw/Generate/;

use strict;
use IDMEFTree;

sub	header
{
     my	$self = shift;
     my	$time = localtime;

     $self->output("
/* Auto-generated by the GenerateIDMEFMessageRecvC package ($time) */

#include <stdio.h>
#include <unistd.h>
#include <inttypes.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include \"list.h\"
#include \"prelude-log.h\"
#include \"extract.h\"
#include \"prelude-io.h\"
#include \"prelude-message.h\"
#include \"prelude-message-buffered.h\"
#include \"idmef-message-id.h\"
#include \"idmef.h\"
#include \"idmef-tree-wrap.h\"

#include \"idmef-message-recv.h\"
#include \"idmef-util.h\"


static inline int extract_string_safe(idmef_string_t **out, char *buf, size_t len)
\{
        if ( buf[len - 1] ) \{
                log(LOG_ERR, \"Datatype error: buffer is not a string.\\n\");
                return -1;
        \}

        *out = idmef_string_new_ref_fast(buf, len + 1);
        if ( ! *out ) \{
                log(LOG_ERR, \"out of memory\\n\");
                return -2;
        \}

        return 0;
\}


static inline int extract_time_safe(idmef_time_t **out, void *buf, size_t len)
\{
        if ( len != sizeof(**out) ) \{
                log(LOG_ERR, \"Datatype error: buffer is not a idmef time.\\n\");
                return -1;
        \}

        *out = idmef_time_new();
        if ( ! *out ) \{
                log(LOG_ERR, \"out of memory\\n\");
                return -2;
        \}

        idmef_time_set_sec(*out, ntohl(((uint32_t *) buf)[0]));
        idmef_time_set_usec(*out, ntohl(((uint32_t *) buf)[1]));

        return 0;
\}


static inline int extract_data_safe(idmef_data_t **out, void *buf, size_t len)
\{
        *out = idmef_data_new_ref(buf, len);
        if ( ! *out ) \{
                log(LOG_ERR, \"out of memory\\n\");
                return -1;
        \}

        return 0;
\}


");
}

sub	struct_field_normal
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;
    my	$ptr = ($field->{metatype} & (&METATYPE_STRUCT | &METATYPE_LIST)) ? "*" : "";
    my	$type = shift || $field->{short_typename};
    my	$var_type = shift || "$field->{typename}";

    $self->output("
			case MSG_",  uc($struct->{short_typename}), "_", uc($field->{short_name}), ": \{
                                ${var_type} ${ptr}tmp;

				if ( extract_${type}_safe(&tmp, buf, len) < 0 )
					goto error;

				idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, tmp);
				break;
			\}
");
}

sub	struct_field_struct
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;
    my	$name = shift || $field->{name};

    $self->output("
			case MSG_",  uc($field->{short_typename}), "_TAG", ": \{
				$field->{typename} *tmp;

				tmp = idmef_$struct->{short_typename}_new_${name}($struct->{short_typename});
				if ( ! tmp)
					goto error;

				if ( ! idmef_recv_$field->{short_typename}(msg, tmp) )
					goto error;

				break;
			\}
");
}

sub	struct_field_union
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;

    foreach my $member ( @{$field->{member_list}} ) {
	$self->struct_field_struct($tree, $struct, $member);
    }
}

sub	struct
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    if ( $struct->{toplevel} ) {
	$self->output("
/*
 * It is up to the caller to implement the toplevel function in order to handle
 * specific stuff
 */
");
	return;
    }

    $self->output("
$struct->{typename} *idmef_recv_$struct->{short_typename}(prelude_msg_t *msg, $struct->{typename} *$struct->{short_typename})
\{
	void *buf;
	uint8_t tag;
	uint32_t len;

	while ( 1 ) \{

		if ( prelude_msg_get(msg, &tag, &len, &buf) < 0 )
			goto error;

		switch ( tag ) \{
");

    foreach my $field ( @{$struct->{field_list}} ) {

	if ( $field->{metatype} & &METATYPE_NORMAL ) {

	    if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
		$self->struct_field_normal($tree, $struct, $field);

	    } elsif ( $field->{metatype} & &METATYPE_ENUM ) {
		$self->struct_field_normal($tree, $struct, $field, "int32", "int32_t");

	    } else {
		$self->struct_field_struct($tree, $struct, $field);
	    }

	} elsif ( $field->{metatype} & &METATYPE_LIST ) {
	    if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
		$self->struct_field_normal($tree, $struct, $field);

	    } else {
		$self->struct_field_struct($tree, $struct, $field, $field->{short_name});
	    }

	} elsif ( $field->{metatype} & &METATYPE_UNION ) {
	    $self->struct_field_union($tree, $struct, $field);
	}
    }

    $self->output("
			case MSG_END_OF_TAG:
				return $struct->{short_typename};

			default:
				log(LOG_ERR, \"couldn't handle tag %d.\\n\", tag);
				goto error;
		\}

	\}

	return $struct->{short_typename};

error:
	/* idmef_$struct->{short_typename}_destroy($struct->{short_typename}); */
	return NULL;
\}
");
}

1;
