# Copyright (C) 2003 Nicolas Delon <delon.nicolas@wanadoo.fr>
# All Rights Reserved
#
# This file is part of the Prelude program.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

package GenerateIDMEFTreePrintC;

use Generate;
@ISA = qw/Generate/;

use strict;
use IDMEFTree; 

sub	header
{
    my	$self = shift;
    my	$time = localtime;

    $self->output("
/* Auto-generated by the GenerateIDMEFTreePrintC package ($time) */

#include \"idmef.h\"
#include \"idmef-tree-wrap.h\"
#include \"idmef-tree-print.h\"
#include <stdio.h>
#include <time.h>

static int indent = 0;

static void print_indent(void)
\{
	int cnt;

	for ( cnt = 0; cnt < indent; cnt++ )
		printf(\" \");
\}



static void print_string(idmef_string_t *string)
\{
	const char *s;

	s = idmef_string_get_string(string);
	printf(\"\%s\", s ? s : \"<empty>\");
\}



static void print_int16(int16_t i)
\{
	printf(\"\%hd\", i);
\}



static void print_uint16(uint16_t i)
\{
	printf(\"\%hu\", i);
\}



static void print_int32(int32_t i)
\{
	printf(\"\%d\", i);
\}



static void print_uint32(uint32_t i)
\{
	printf(\"\%u\", i);
\}



static void print_int64(int64_t i)
\{
	printf(\"\%lld\", i);
\}



static void print_uint64(uint64_t i)
\{
	printf(\"\%llu\", i);
\}



static void print_float(float f)
\{
	printf(\"\%f\", f);
\}




static void print_time(idmef_time_t *t)
\{
	char buf[32];
	time_t _time;
	struct tm _tm;

	_time = idmef_time_get_sec(t);

	if ( ! localtime_r(&_time, &_tm) )
		return;

	if ( strftime(buf, sizeof (buf), \"%H:%M:%S %d/%m/%Y\", &_tm) == 0 )
		return;

	printf(\"%s (\%u.\%u)\", buf, idmef_time_get_sec(t), idmef_time_get_usec(t));
\}



/* print data as a string */

static void print_data(idmef_data_t *data)
\{
	printf(\"\%s\", idmef_data_get_data(data));
\}



static void print_enum(const char *s, int i)
\{
	printf(\"\%s (\%d)\", s, i);
\}

");
}

sub	struct_field_normal
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;

    if ( $field->{metatype} & &METATYPE_ENUM ) {
	$self->output("
	\{
		int i = idmef_$struct->{short_typename}_get_$field->{name}(ptr);

		print_indent();
		printf(\"$field->{name}: \");
		print_enum(idmef_$field->{short_typename}_to_string(i), i);
		printf(\"\\n\");
        \}
");

    } elsif ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
	if ( $field->{metatype} & &METATYPE_STRUCT ) {
	    $self->output("
	\{
		$field->{typename} *field;

		field = idmef_$struct->{short_typename}_get_$field->{name}(ptr);

		if ( field ) \{
			print_indent();
			printf(\"$field->{name}: \");
			print_$field->{short_typename}(field);
			printf(\"\\n\");
		\}
	\}
"); 

	} else {
	    $self->output("
	print_indent();
	printf(\"$field->{name}: \");
	print_$field->{short_typename}(idmef_$struct->{short_typename}_get_$field->{name}(ptr));
	printf(\"\\n\");
");
	}

    } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
	$self->output("
	\{
		$field->{typename} *field;

		field = idmef_$struct->{short_typename}_get_$field->{name}(ptr);

		if ( field ) \{
			print_indent();
			printf(\"$field->{name}:\\n\");
			idmef_$field->{short_typename}_print(field);
		\}
	\}	
");
    }
}

sub	struct_field_union
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;

    $self->output("
	switch ( idmef_$struct->{short_typename}_get_$field->{var}(ptr) ) \{");

    foreach my $member ( @{ $field->{member_list} } ) {
	$self->output("
	case $member->{value}:
		print_indent();
		printf(\"$member->{name}:\\n\");
		idmef_$member->{short_typename}_print(idmef_$struct->{short_typename}_get_$member->{name}(ptr));
		break;
 ");
    }

    $self->output("
	default:
		break;
	\}
");

}

sub	struct_field_list
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;
    my	$field = shift;

    $self->output("
	\{
		$field->{typename} *elem = NULL;
		int cnt = 0;

		while ( (elem = idmef_$struct->{short_typename}_get_next_$field->{short_name}(ptr, elem)) ) \{
			print_indent();
");

    if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
	$self->output("
			printf(\"$field->{short_name}(%d): \", cnt);
			print_$field->{short_typename}(elem);
			printf(\"\\n\");
");

    } else {
	$self->output("
			printf(\"$field->{short_name}(%d):\\n\", cnt);
			idmef_$field->{short_typename}_print(elem);
");
    }

    $self->output("
			cnt++;
		\}
	\}
");
}

sub	struct
{
    my	$self = shift;
    my	$tree = shift;
    my	$struct = shift;

    $self->output("
void idmef_$struct->{short_typename}_print($struct->{typename} *ptr)
\{
	if ( ! ptr )
		return;

	indent += 8;
");

    foreach my $field ( @{ $struct->{field_list} } ) {

	if ( $field->{metatype} & &METATYPE_NORMAL ) {
	    $self->struct_field_normal($tree, $struct, $field);

	} elsif ( $field->{metatype} & &METATYPE_UNION ) {
	    $self->struct_field_union($tree, $struct, $field);

	} elsif ( $field->{metatype} & &METATYPE_LIST ) {
	    $self->struct_field_list($tree, $struct, $field);
	}
    }

    $self->output("
	indent -= 8;
\}
");
}

sub	footer
{
    my	$self = shift;
    my	$tree = shift;
}

1;
